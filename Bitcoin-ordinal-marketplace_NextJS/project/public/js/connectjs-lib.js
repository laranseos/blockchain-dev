(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.connect = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){

},{}],2:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],3:[function(require,module,exports){
(function (setImmediate,clearImmediate){(function (){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this)}).call(this,require("timers").setImmediate,require("timers").clearImmediate)
},{"process/browser.js":2,"timers":3}],4:[function(require,module,exports){
module.exports = require('@stacks/connect');

},{"@stacks/connect":47}],5:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;
function number(n) {
    if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`Wrong positive integer: ${n}`);
}
exports.number = number;
function bool(b) {
    if (typeof b !== 'boolean')
        throw new Error(`Expected boolean, not ${b}`);
}
exports.bool = bool;
function bytes(b, ...lengths) {
    if (!(b instanceof Uint8Array))
        throw new TypeError('Expected Uint8Array');
    if (lengths.length > 0 && !lengths.includes(b.length))
        throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
exports.bytes = bytes;
function hash(hash) {
    if (typeof hash !== 'function' || typeof hash.create !== 'function')
        throw new Error('Hash should be wrapped by utils.wrapConstructor');
    number(hash.outputLen);
    number(hash.blockLen);
}
exports.hash = hash;
function exists(instance, checkFinished = true) {
    if (instance.destroyed)
        throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished)
        throw new Error('Hash#digest() has already been called');
}
exports.exists = exists;
function output(out, instance) {
    bytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
}
exports.output = output;
const assert = {
    number,
    bool,
    bytes,
    hash,
    exists,
    output,
};
exports.default = assert;

},{}],6:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SHA2 = void 0;
const _assert_js_1 = require("./_assert.js");
const utils_js_1 = require("./utils.js");
// Polyfill for Safari 14
function setBigUint64(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === 'function')
        return view.setBigUint64(byteOffset, value, isLE);
    const _32n = BigInt(32);
    const _u32_max = BigInt(0xffffffff);
    const wh = Number((value >> _32n) & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE ? 4 : 0;
    const l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
}
// Base SHA2 class (RFC 6234)
class SHA2 extends utils_js_1.Hash {
    constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_js_1.createView)(this.buffer);
    }
    update(data) {
        _assert_js_1.default.exists(this);
        const { view, buffer, blockLen } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            // Fast path: we have at least one block in input, cast it to view and process
            if (take === blockLen) {
                const dataView = (0, utils_js_1.createView)(data);
                for (; blockLen <= len - pos; pos += blockLen)
                    this.process(dataView, pos);
                continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
                this.process(view, 0);
                this.pos = 0;
            }
        }
        this.length += data.length;
        this.roundClean();
        return this;
    }
    digestInto(out) {
        _assert_js_1.default.exists(this);
        _assert_js_1.default.output(out, this);
        this.finished = true;
        // Padding
        // We can avoid allocation of buffer for padding completely if it
        // was previously not allocated here. But it won't change performance.
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        // append the bit '1' to the message
        buffer[pos++] = 0b10000000;
        this.buffer.subarray(pos).fill(0);
        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again
        if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
        }
        // Pad until full block byte with zeros
        for (let i = pos; i < blockLen; i++)
            buffer[i] = 0;
        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
        // So we just write lowest 64 bits of that value.
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_js_1.createView)(out);
        const len = this.outputLen;
        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT
        if (len % 4)
            throw new Error('_sha2: outputLen should be aligned to 32bit');
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
            throw new Error('_sha2: outputLen bigger than state');
        for (let i = 0; i < outLen; i++)
            oview.setUint32(4 * i, state[i], isLE);
    }
    digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
    }
    _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
            to.buffer.set(buffer);
        return to;
    }
}
exports.SHA2 = SHA2;

},{"./_assert.js":5,"./utils.js":14}],7:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.add = exports.toBig = exports.split = exports.fromBig = void 0;
const U32_MASK64 = BigInt(2 ** 32 - 1);
const _32n = BigInt(32);
// We are not using BigUint64Array, because they are extremely slow as per 2022
function fromBig(n, le = false) {
    if (le)
        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };
    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
exports.fromBig = fromBig;
function split(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i = 0; i < lst.length; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
}
exports.split = split;
const toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);
exports.toBig = toBig;
// for Shift in [0, 32)
const shrSH = (h, l, s) => h >>> s;
const shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
// Right rotate for Shift in [1, 32)
const rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));
const rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
// Right rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));
const rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));
// Right rotate for shift===32 (just swaps l&h)
const rotr32H = (h, l) => l;
const rotr32L = (h, l) => h;
// Left rotate for Shift in [1, 32)
const rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));
const rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));
const rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));
// JS uses 32-bit signed integers for bitwise operations which means we cannot
// simple take carry out of low bit sum by shift, we need to use division.
// Removing "export" has 5% perf penalty -_-
function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };
}
exports.add = add;
// Addition with more than 2 elements
const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
const add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;
const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
const add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;
const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
const add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;
// prettier-ignore
const u64 = {
    fromBig, split, toBig: exports.toBig,
    shrSH, shrSL,
    rotrSH, rotrSL, rotrBH, rotrBL,
    rotr32H, rotr32L,
    rotlSH, rotlSL, rotlBH, rotlBL,
    add, add3L, add3H, add4L, add4H, add5H, add5L,
};
exports.default = u64;

},{}],8:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.crypto = void 0;
exports.crypto = {
    node: undefined,
    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,
};

},{}],9:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hmac = void 0;
const _assert_js_1 = require("./_assert.js");
const utils_js_1 = require("./utils.js");
// HMAC (RFC 2104)
class HMAC extends utils_js_1.Hash {
    constructor(hash, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        _assert_js_1.default.hash(hash);
        const key = (0, utils_js_1.toBytes)(_key);
        this.iHash = hash.create();
        if (typeof this.iHash.update !== 'function')
            throw new TypeError('Expected instance of class which extends utils.Hash');
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        // blockLen can be bigger than outputLen
        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
        for (let i = 0; i < pad.length; i++)
            pad[i] ^= 0x36;
        this.iHash.update(pad);
        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone
        this.oHash = hash.create();
        // Undo internal XOR && apply outer XOR
        for (let i = 0; i < pad.length; i++)
            pad[i] ^= 0x36 ^ 0x5c;
        this.oHash.update(pad);
        pad.fill(0);
    }
    update(buf) {
        _assert_js_1.default.exists(this);
        this.iHash.update(buf);
        return this;
    }
    digestInto(out) {
        _assert_js_1.default.exists(this);
        _assert_js_1.default.bytes(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
    }
    digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
    }
    _cloneInto(to) {
        // Create new instance without calling constructor since key already in state and we don't know it.
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
    }
    destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
    }
}
/**
 * HMAC: RFC2104 message authentication code.
 * @param hash - function that would be used e.g. sha256
 * @param key - message key
 * @param message - message data
 */
const hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
exports.hmac = hmac;
exports.hmac.create = (hash, key) => new HMAC(hash, key);

},{"./_assert.js":5,"./utils.js":14}],10:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pbkdf2Async = exports.pbkdf2 = void 0;
const _assert_js_1 = require("./_assert.js");
const hmac_js_1 = require("./hmac.js");
const utils_js_1 = require("./utils.js");
// Common prologue and epilogue for sync/async functions
function pbkdf2Init(hash, _password, _salt, _opts) {
    _assert_js_1.default.hash(hash);
    const opts = (0, utils_js_1.checkOpts)({ dkLen: 32, asyncTick: 10 }, _opts);
    const { c, dkLen, asyncTick } = opts;
    _assert_js_1.default.number(c);
    _assert_js_1.default.number(dkLen);
    _assert_js_1.default.number(asyncTick);
    if (c < 1)
        throw new Error('PBKDF2: iterations (c) should be >= 1');
    const password = (0, utils_js_1.toBytes)(_password);
    const salt = (0, utils_js_1.toBytes)(_salt);
    // DK = PBKDF2(PRF, Password, Salt, c, dkLen);
    const DK = new Uint8Array(dkLen);
    // U1 = PRF(Password, Salt + INT_32_BE(i))
    const PRF = hmac_js_1.hmac.create(hash, password);
    const PRFSalt = PRF._cloneInto().update(salt);
    return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
}
function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
    PRF.destroy();
    PRFSalt.destroy();
    if (prfW)
        prfW.destroy();
    u.fill(0);
    return DK;
}
/**
 * PBKDF2-HMAC: RFC 2898 key derivation function
 * @param hash - hash function that would be used e.g. sha256
 * @param password - password from which a derived key is generated
 * @param salt - cryptographic salt
 * @param opts - {c, dkLen} where c is work factor and dkLen is output message size
 */
function pbkdf2(hash, password, salt, opts) {
    const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
    let prfW; // Working copy
    const arr = new Uint8Array(4);
    const view = (0, utils_js_1.createView)(arr);
    const u = new Uint8Array(PRF.outputLen);
    // DK = T1 + T2 + ⋯ + Tdklen/hlen
    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
        // Ti = F(Password, Salt, c, i)
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti, false);
        // F(Password, Salt, c, i) = U1 ^ U2 ^ ⋯ ^ Uc
        // U1 = PRF(Password, Salt + INT_32_BE(i))
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
        Ti.set(u.subarray(0, Ti.length));
        for (let ui = 1; ui < c; ui++) {
            // Uc = PRF(Password, Uc−1)
            PRF._cloneInto(prfW).update(u).digestInto(u);
            for (let i = 0; i < Ti.length; i++)
                Ti[i] ^= u[i];
        }
    }
    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}
exports.pbkdf2 = pbkdf2;
async function pbkdf2Async(hash, password, salt, opts) {
    const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
    let prfW; // Working copy
    const arr = new Uint8Array(4);
    const view = (0, utils_js_1.createView)(arr);
    const u = new Uint8Array(PRF.outputLen);
    // DK = T1 + T2 + ⋯ + Tdklen/hlen
    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
        // Ti = F(Password, Salt, c, i)
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti, false);
        // F(Password, Salt, c, i) = U1 ^ U2 ^ ⋯ ^ Uc
        // U1 = PRF(Password, Salt + INT_32_BE(i))
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
        Ti.set(u.subarray(0, Ti.length));
        await (0, utils_js_1.asyncLoop)(c - 1, asyncTick, (i) => {
            // Uc = PRF(Password, Uc−1)
            PRF._cloneInto(prfW).update(u).digestInto(u);
            for (let i = 0; i < Ti.length; i++)
                Ti[i] ^= u[i];
        });
    }
    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}
exports.pbkdf2Async = pbkdf2Async;

},{"./_assert.js":5,"./hmac.js":9,"./utils.js":14}],11:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ripemd160 = exports.RIPEMD160 = void 0;
const _sha2_js_1 = require("./_sha2.js");
const utils_js_1 = require("./utils.js");
// https://homes.esat.kuleuven.be/~bosselae/ripemd160.html
// https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf
const Rho = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
const Id = Uint8Array.from({ length: 16 }, (_, i) => i);
const Pi = Id.map((i) => (9 * i + 5) % 16);
let idxL = [Id];
let idxR = [Pi];
for (let i = 0; i < 4; i++)
    for (let j of [idxL, idxR])
        j.push(j[i].map((k) => Rho[k]));
const shifts = [
    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],
].map((i) => new Uint8Array(i));
const shiftsL = idxL.map((idx, i) => idx.map((j) => shifts[i][j]));
const shiftsR = idxR.map((idx, i) => idx.map((j) => shifts[i][j]));
const Kl = new Uint32Array([0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e]);
const Kr = new Uint32Array([0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000]);
// The rotate left (circular left shift) operation for uint32
const rotl = (word, shift) => (word << shift) | (word >>> (32 - shift));
// It's called f() in spec.
function f(group, x, y, z) {
    if (group === 0)
        return x ^ y ^ z;
    else if (group === 1)
        return (x & y) | (~x & z);
    else if (group === 2)
        return (x | ~y) ^ z;
    else if (group === 3)
        return (x & z) | (y & ~z);
    else
        return x ^ (y | ~z);
}
// Temporary buffer, not used to store anything between runs
const BUF = new Uint32Array(16);
class RIPEMD160 extends _sha2_js_1.SHA2 {
    constructor() {
        super(64, 20, 8, true);
        this.h0 = 0x67452301 | 0;
        this.h1 = 0xefcdab89 | 0;
        this.h2 = 0x98badcfe | 0;
        this.h3 = 0x10325476 | 0;
        this.h4 = 0xc3d2e1f0 | 0;
    }
    get() {
        const { h0, h1, h2, h3, h4 } = this;
        return [h0, h1, h2, h3, h4];
    }
    set(h0, h1, h2, h3, h4) {
        this.h0 = h0 | 0;
        this.h1 = h1 | 0;
        this.h2 = h2 | 0;
        this.h3 = h3 | 0;
        this.h4 = h4 | 0;
    }
    process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
            BUF[i] = view.getUint32(offset, true);
        // prettier-ignore
        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
        // Instead of iterating 0 to 80, we split it into 5 groups
        // And use the groups in constants, functions, etc. Much simpler
        for (let group = 0; group < 5; group++) {
            const rGroup = 4 - group;
            const hbl = Kl[group], hbr = Kr[group]; // prettier-ignore
            const rl = idxL[group], rr = idxR[group]; // prettier-ignore
            const sl = shiftsL[group], sr = shiftsR[group]; // prettier-ignore
            for (let i = 0; i < 16; i++) {
                const tl = (rotl(al + f(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) + el) | 0;
                al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore
            }
            // 2 loops are 10% faster
            for (let i = 0; i < 16; i++) {
                const tr = (rotl(ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er) | 0;
                ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr; // prettier-ignore
            }
        }
        // Add the compressed chunk to the current hash value
        this.set((this.h1 + cl + dr) | 0, (this.h2 + dl + er) | 0, (this.h3 + el + ar) | 0, (this.h4 + al + br) | 0, (this.h0 + bl + cr) | 0);
    }
    roundClean() {
        BUF.fill(0);
    }
    destroy() {
        this.destroyed = true;
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0);
    }
}
exports.RIPEMD160 = RIPEMD160;
/**
 * RIPEMD-160 - a hash function from 1990s.
 * @param message - msg that would be hashed
 */
exports.ripemd160 = (0, utils_js_1.wrapConstructor)(() => new RIPEMD160());

},{"./_sha2.js":6,"./utils.js":14}],12:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sha224 = exports.sha256 = void 0;
const _sha2_js_1 = require("./_sha2.js");
const utils_js_1 = require("./utils.js");
// Choice: a ? b : c
const Chi = (a, b, c) => (a & b) ^ (~a & c);
// Majority function, true if any two inpust is true
const Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);
// Round constants:
// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)
// prettier-ignore
const SHA256_K = new Uint32Array([
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
]);
// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):
// prettier-ignore
const IV = new Uint32Array([
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
]);
// Temporary buffer, not used to store anything between runs
// Named this way because it matches specification.
const SHA256_W = new Uint32Array(64);
class SHA256 extends _sha2_js_1.SHA2 {
    constructor() {
        super(64, 32, 8, false);
        // We cannot use array here since array allows indexing by variable
        // which means optimizer/compiler cannot use registers.
        this.A = IV[0] | 0;
        this.B = IV[1] | 0;
        this.C = IV[2] | 0;
        this.D = IV[3] | 0;
        this.E = IV[4] | 0;
        this.F = IV[5] | 0;
        this.G = IV[6] | 0;
        this.H = IV[7] | 0;
    }
    get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
        for (let i = 0; i < 16; i++, offset += 4)
            SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
            const W15 = SHA256_W[i - 15];
            const W2 = SHA256_W[i - 2];
            const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ (W15 >>> 3);
            const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ (W2 >>> 10);
            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;
        }
        // Compression function main loop, 64 rounds
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
            const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
            const T2 = (sigma0 + Maj(A, B, C)) | 0;
            H = G;
            G = F;
            F = E;
            E = (D + T1) | 0;
            D = C;
            C = B;
            B = A;
            A = (T1 + T2) | 0;
        }
        // Add the compressed chunk to the current hash value
        A = (A + this.A) | 0;
        B = (B + this.B) | 0;
        C = (C + this.C) | 0;
        D = (D + this.D) | 0;
        E = (E + this.E) | 0;
        F = (F + this.F) | 0;
        G = (G + this.G) | 0;
        H = (H + this.H) | 0;
        this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
        SHA256_W.fill(0);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
    }
}
// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf
class SHA224 extends SHA256 {
    constructor() {
        super();
        this.A = 0xc1059ed8 | 0;
        this.B = 0x367cd507 | 0;
        this.C = 0x3070dd17 | 0;
        this.D = 0xf70e5939 | 0;
        this.E = 0xffc00b31 | 0;
        this.F = 0x68581511 | 0;
        this.G = 0x64f98fa7 | 0;
        this.H = 0xbefa4fa4 | 0;
        this.outputLen = 28;
    }
}
/**
 * SHA2-256 hash function
 * @param message - data that would be hashed
 */
exports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
exports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());

},{"./_sha2.js":6,"./utils.js":14}],13:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sha384 = exports.sha512_256 = exports.sha512_224 = exports.sha512 = exports.SHA512 = void 0;
const _sha2_js_1 = require("./_sha2.js");
const _u64_js_1 = require("./_u64.js");
const utils_js_1 = require("./utils.js");
// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):
// prettier-ignore
const [SHA512_Kh, SHA512_Kl] = _u64_js_1.default.split([
    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',
    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',
    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',
    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',
    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',
    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',
    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',
    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',
    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',
    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',
    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',
    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',
    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',
    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',
    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',
    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',
    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',
    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',
    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',
    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'
].map(n => BigInt(n)));
// Temporary buffer, not used to store anything between runs
const SHA512_W_H = new Uint32Array(80);
const SHA512_W_L = new Uint32Array(80);
class SHA512 extends _sha2_js_1.SHA2 {
    constructor() {
        super(128, 64, 16, false);
        // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.
        // Also looks cleaner and easier to verify with spec.
        // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = 0x6a09e667 | 0;
        this.Al = 0xf3bcc908 | 0;
        this.Bh = 0xbb67ae85 | 0;
        this.Bl = 0x84caa73b | 0;
        this.Ch = 0x3c6ef372 | 0;
        this.Cl = 0xfe94f82b | 0;
        this.Dh = 0xa54ff53a | 0;
        this.Dl = 0x5f1d36f1 | 0;
        this.Eh = 0x510e527f | 0;
        this.El = 0xade682d1 | 0;
        this.Fh = 0x9b05688c | 0;
        this.Fl = 0x2b3e6c1f | 0;
        this.Gh = 0x1f83d9ab | 0;
        this.Gl = 0xfb41bd6b | 0;
        this.Hh = 0x5be0cd19 | 0;
        this.Hl = 0x137e2179 | 0;
    }
    // prettier-ignore
    get() {
        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
    }
    // prettier-ignore
    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array
        for (let i = 0; i < 16; i++, offset += 4) {
            SHA512_W_H[i] = view.getUint32(offset);
            SHA512_W_L[i] = view.getUint32((offset += 4));
        }
        for (let i = 16; i < 80; i++) {
            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)
            const W15h = SHA512_W_H[i - 15] | 0;
            const W15l = SHA512_W_L[i - 15] | 0;
            const s0h = _u64_js_1.default.rotrSH(W15h, W15l, 1) ^ _u64_js_1.default.rotrSH(W15h, W15l, 8) ^ _u64_js_1.default.shrSH(W15h, W15l, 7);
            const s0l = _u64_js_1.default.rotrSL(W15h, W15l, 1) ^ _u64_js_1.default.rotrSL(W15h, W15l, 8) ^ _u64_js_1.default.shrSL(W15h, W15l, 7);
            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)
            const W2h = SHA512_W_H[i - 2] | 0;
            const W2l = SHA512_W_L[i - 2] | 0;
            const s1h = _u64_js_1.default.rotrSH(W2h, W2l, 19) ^ _u64_js_1.default.rotrBH(W2h, W2l, 61) ^ _u64_js_1.default.shrSH(W2h, W2l, 6);
            const s1l = _u64_js_1.default.rotrSL(W2h, W2l, 19) ^ _u64_js_1.default.rotrBL(W2h, W2l, 61) ^ _u64_js_1.default.shrSL(W2h, W2l, 6);
            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];
            const SUMl = _u64_js_1.default.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
            const SUMh = _u64_js_1.default.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
            SHA512_W_H[i] = SUMh | 0;
            SHA512_W_L[i] = SUMl | 0;
        }
        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        // Compression function main loop, 80 rounds
        for (let i = 0; i < 80; i++) {
            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)
            const sigma1h = _u64_js_1.default.rotrSH(Eh, El, 14) ^ _u64_js_1.default.rotrSH(Eh, El, 18) ^ _u64_js_1.default.rotrBH(Eh, El, 41);
            const sigma1l = _u64_js_1.default.rotrSL(Eh, El, 14) ^ _u64_js_1.default.rotrSL(Eh, El, 18) ^ _u64_js_1.default.rotrBL(Eh, El, 41);
            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            const CHIh = (Eh & Fh) ^ (~Eh & Gh);
            const CHIl = (El & Fl) ^ (~El & Gl);
            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]
            // prettier-ignore
            const T1ll = _u64_js_1.default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
            const T1h = _u64_js_1.default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
            const T1l = T1ll | 0;
            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)
            const sigma0h = _u64_js_1.default.rotrSH(Ah, Al, 28) ^ _u64_js_1.default.rotrBH(Ah, Al, 34) ^ _u64_js_1.default.rotrBH(Ah, Al, 39);
            const sigma0l = _u64_js_1.default.rotrSL(Ah, Al, 28) ^ _u64_js_1.default.rotrBL(Ah, Al, 34) ^ _u64_js_1.default.rotrBL(Ah, Al, 39);
            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);
            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);
            Hh = Gh | 0;
            Hl = Gl | 0;
            Gh = Fh | 0;
            Gl = Fl | 0;
            Fh = Eh | 0;
            Fl = El | 0;
            ({ h: Eh, l: El } = _u64_js_1.default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
            Dh = Ch | 0;
            Dl = Cl | 0;
            Ch = Bh | 0;
            Cl = Bl | 0;
            Bh = Ah | 0;
            Bl = Al | 0;
            const All = _u64_js_1.default.add3L(T1l, sigma0l, MAJl);
            Ah = _u64_js_1.default.add3H(All, T1h, sigma0h, MAJh);
            Al = All | 0;
        }
        // Add the compressed chunk to the current hash value
        ({ h: Ah, l: Al } = _u64_js_1.default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
        ({ h: Bh, l: Bl } = _u64_js_1.default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
        ({ h: Ch, l: Cl } = _u64_js_1.default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
        ({ h: Dh, l: Dl } = _u64_js_1.default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
        ({ h: Eh, l: El } = _u64_js_1.default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
        ({ h: Fh, l: Fl } = _u64_js_1.default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
        ({ h: Gh, l: Gl } = _u64_js_1.default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
        ({ h: Hh, l: Hl } = _u64_js_1.default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
    }
    roundClean() {
        SHA512_W_H.fill(0);
        SHA512_W_L.fill(0);
    }
    destroy() {
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
}
exports.SHA512 = SHA512;
class SHA512_224 extends SHA512 {
    constructor() {
        super();
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = 0x8c3d37c8 | 0;
        this.Al = 0x19544da2 | 0;
        this.Bh = 0x73e19966 | 0;
        this.Bl = 0x89dcd4d6 | 0;
        this.Ch = 0x1dfab7ae | 0;
        this.Cl = 0x32ff9c82 | 0;
        this.Dh = 0x679dd514 | 0;
        this.Dl = 0x582f9fcf | 0;
        this.Eh = 0x0f6d2b69 | 0;
        this.El = 0x7bd44da8 | 0;
        this.Fh = 0x77e36f73 | 0;
        this.Fl = 0x04c48942 | 0;
        this.Gh = 0x3f9d85a8 | 0;
        this.Gl = 0x6a1d36c8 | 0;
        this.Hh = 0x1112e6ad | 0;
        this.Hl = 0x91d692a1 | 0;
        this.outputLen = 28;
    }
}
class SHA512_256 extends SHA512 {
    constructor() {
        super();
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = 0x22312194 | 0;
        this.Al = 0xfc2bf72c | 0;
        this.Bh = 0x9f555fa3 | 0;
        this.Bl = 0xc84c64c2 | 0;
        this.Ch = 0x2393b86b | 0;
        this.Cl = 0x6f53b151 | 0;
        this.Dh = 0x96387719 | 0;
        this.Dl = 0x5940eabd | 0;
        this.Eh = 0x96283ee2 | 0;
        this.El = 0xa88effe3 | 0;
        this.Fh = 0xbe5e1e25 | 0;
        this.Fl = 0x53863992 | 0;
        this.Gh = 0x2b0199fc | 0;
        this.Gl = 0x2c85b8aa | 0;
        this.Hh = 0x0eb72ddc | 0;
        this.Hl = 0x81c52ca2 | 0;
        this.outputLen = 32;
    }
}
class SHA384 extends SHA512 {
    constructor() {
        super();
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = 0xcbbb9d5d | 0;
        this.Al = 0xc1059ed8 | 0;
        this.Bh = 0x629a292a | 0;
        this.Bl = 0x367cd507 | 0;
        this.Ch = 0x9159015a | 0;
        this.Cl = 0x3070dd17 | 0;
        this.Dh = 0x152fecd8 | 0;
        this.Dl = 0xf70e5939 | 0;
        this.Eh = 0x67332667 | 0;
        this.El = 0xffc00b31 | 0;
        this.Fh = 0x8eb44a87 | 0;
        this.Fl = 0x68581511 | 0;
        this.Gh = 0xdb0c2e0d | 0;
        this.Gl = 0x64f98fa7 | 0;
        this.Hh = 0x47b5481d | 0;
        this.Hl = 0xbefa4fa4 | 0;
        this.outputLen = 48;
    }
}
exports.sha512 = (0, utils_js_1.wrapConstructor)(() => new SHA512());
exports.sha512_224 = (0, utils_js_1.wrapConstructor)(() => new SHA512_224());
exports.sha512_256 = (0, utils_js_1.wrapConstructor)(() => new SHA512_256());
exports.sha384 = (0, utils_js_1.wrapConstructor)(() => new SHA384());

},{"./_sha2.js":6,"./_u64.js":7,"./utils.js":14}],14:[function(require,module,exports){
"use strict";
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
Object.defineProperty(exports, "__esModule", { value: true });
exports.randomBytes = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
// The import here is via the package name. This is to ensure
// that exports mapping/resolution does fall into place.
const crypto_1 = require("@noble/hashes/crypto");
// Cast array to different type
const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
exports.u8 = u8;
const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
exports.u32 = u32;
// Cast array to view
const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
exports.createView = createView;
// The rotate right (circular right shift) operation for uint32
const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);
exports.rotr = rotr;
exports.isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;
// There is almost no big endian hardware, but js typed arrays uses platform specific endianness.
// So, just to be sure not to corrupt anything.
if (!exports.isLE)
    throw new Error('Non little-endian hardware is not supported');
const hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));
/**
 * @example bytesToHex(Uint8Array.from([0xde, 0xad, 0xbe, 0xef]))
 */
function bytesToHex(uint8a) {
    // pre-caching improves the speed 6x
    if (!(uint8a instanceof Uint8Array))
        throw new Error('Uint8Array expected');
    let hex = '';
    for (let i = 0; i < uint8a.length; i++) {
        hex += hexes[uint8a[i]];
    }
    return hex;
}
exports.bytesToHex = bytesToHex;
/**
 * @example hexToBytes('deadbeef')
 */
function hexToBytes(hex) {
    if (typeof hex !== 'string') {
        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);
    }
    if (hex.length % 2)
        throw new Error('hexToBytes: received invalid unpadded hex');
    const array = new Uint8Array(hex.length / 2);
    for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
            throw new Error('Invalid byte sequence');
        array[i] = byte;
    }
    return array;
}
exports.hexToBytes = hexToBytes;
// There is no setImmediate in browser and setTimeout is slow. However, call to async function will return Promise
// which will be fullfiled only on next scheduler queue processing step and this is exactly what we need.
const nextTick = async () => { };
exports.nextTick = nextTick;
// Returns control to thread each 'tick' ms to avoid blocking
async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for (let i = 0; i < iters; i++) {
        cb(i);
        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
            continue;
        await (0, exports.nextTick)();
        ts += diff;
    }
}
exports.asyncLoop = asyncLoop;
function utf8ToBytes(str) {
    if (typeof str !== 'string') {
        throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);
    }
    return new TextEncoder().encode(str);
}
exports.utf8ToBytes = utf8ToBytes;
function toBytes(data) {
    if (typeof data === 'string')
        data = utf8ToBytes(data);
    if (!(data instanceof Uint8Array))
        throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);
    return data;
}
exports.toBytes = toBytes;
/**
 * Concats Uint8Array-s into one; like `Buffer.concat([buf1, buf2])`
 * @example concatBytes(buf1, buf2)
 */
function concatBytes(...arrays) {
    if (!arrays.every((a) => a instanceof Uint8Array))
        throw new Error('Uint8Array list expected');
    if (arrays.length === 1)
        return arrays[0];
    const length = arrays.reduce((a, arr) => a + arr.length, 0);
    const result = new Uint8Array(length);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
        const arr = arrays[i];
        result.set(arr, pad);
        pad += arr.length;
    }
    return result;
}
exports.concatBytes = concatBytes;
// For runtime check if class implements interface
class Hash {
    // Safe version that clones internal state
    clone() {
        return this._cloneInto();
    }
}
exports.Hash = Hash;
// Check if object doens't have custom constructor (like Uint8Array/Array)
const isPlainObject = (obj) => Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;
function checkOpts(defaults, opts) {
    if (opts !== undefined && (typeof opts !== 'object' || !isPlainObject(opts)))
        throw new TypeError('Options should be object or undefined');
    const merged = Object.assign(defaults, opts);
    return merged;
}
exports.checkOpts = checkOpts;
function wrapConstructor(hashConstructor) {
    const hashC = (message) => hashConstructor().update(toBytes(message)).digest();
    const tmp = hashConstructor();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashConstructor();
    return hashC;
}
exports.wrapConstructor = wrapConstructor;
function wrapConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
}
exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
/**
 * Secure PRNG
 */
function randomBytes(bytesLength = 32) {
    if (crypto_1.crypto.web) {
        return crypto_1.crypto.web.getRandomValues(new Uint8Array(bytesLength));
    }
    else if (crypto_1.crypto.node) {
        return new Uint8Array(crypto_1.crypto.node.randomBytes(bytesLength).buffer);
    }
    else {
        throw new Error("The environment doesn't have randomBytes function");
    }
}
exports.randomBytes = randomBytes;

},{"@noble/hashes/crypto":8}],15:[function(require,module,exports){
"use strict";
/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
Object.defineProperty(exports, "__esModule", { value: true });
exports.utils = exports.schnorr = exports.verify = exports.signSync = exports.sign = exports.getSharedSecret = exports.recoverPublicKey = exports.getPublicKey = exports.Signature = exports.Point = exports.CURVE = void 0;
const nodeCrypto = require("crypto");
const _0n = BigInt(0);
const _1n = BigInt(1);
const _2n = BigInt(2);
const _3n = BigInt(3);
const _8n = BigInt(8);
const CURVE = Object.freeze({
    a: _0n,
    b: BigInt(7),
    P: BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'),
    n: BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'),
    h: _1n,
    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),
    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),
    beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),
});
exports.CURVE = CURVE;
const divNearest = (a, b) => (a + b / _2n) / b;
const endo = {
    beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),
    splitScalar(k) {
        const { n } = CURVE;
        const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');
        const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');
        const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');
        const b2 = a1;
        const POW_2_128 = BigInt('0x100000000000000000000000000000000');
        const c1 = divNearest(b2 * k, n);
        const c2 = divNearest(-b1 * k, n);
        let k1 = mod(k - c1 * a1 - c2 * a2, n);
        let k2 = mod(-c1 * b1 - c2 * b2, n);
        const k1neg = k1 > POW_2_128;
        const k2neg = k2 > POW_2_128;
        if (k1neg)
            k1 = n - k1;
        if (k2neg)
            k2 = n - k2;
        if (k1 > POW_2_128 || k2 > POW_2_128) {
            throw new Error('splitScalarEndo: Endomorphism failed, k=' + k);
        }
        return { k1neg, k1, k2neg, k2 };
    },
};
const fieldLen = 32;
const groupLen = 32;
const hashLen = 32;
const compressedLen = fieldLen + 1;
const uncompressedLen = 2 * fieldLen + 1;
function weierstrass(x) {
    const { a, b } = CURVE;
    const x2 = mod(x * x);
    const x3 = mod(x2 * x);
    return mod(x3 + a * x + b);
}
const USE_ENDOMORPHISM = CURVE.a === _0n;
class ShaError extends Error {
    constructor(message) {
        super(message);
    }
}
function assertJacPoint(other) {
    if (!(other instanceof JacobianPoint))
        throw new TypeError('JacobianPoint expected');
}
class JacobianPoint {
    constructor(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
    }
    static fromAffine(p) {
        if (!(p instanceof Point)) {
            throw new TypeError('JacobianPoint#fromAffine: expected Point');
        }
        if (p.equals(Point.ZERO))
            return JacobianPoint.ZERO;
        return new JacobianPoint(p.x, p.y, _1n);
    }
    static toAffineBatch(points) {
        const toInv = invertBatch(points.map((p) => p.z));
        return points.map((p, i) => p.toAffine(toInv[i]));
    }
    static normalizeZ(points) {
        return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);
    }
    equals(other) {
        assertJacPoint(other);
        const { x: X1, y: Y1, z: Z1 } = this;
        const { x: X2, y: Y2, z: Z2 } = other;
        const Z1Z1 = mod(Z1 * Z1);
        const Z2Z2 = mod(Z2 * Z2);
        const U1 = mod(X1 * Z2Z2);
        const U2 = mod(X2 * Z1Z1);
        const S1 = mod(mod(Y1 * Z2) * Z2Z2);
        const S2 = mod(mod(Y2 * Z1) * Z1Z1);
        return U1 === U2 && S1 === S2;
    }
    negate() {
        return new JacobianPoint(this.x, mod(-this.y), this.z);
    }
    double() {
        const { x: X1, y: Y1, z: Z1 } = this;
        const A = mod(X1 * X1);
        const B = mod(Y1 * Y1);
        const C = mod(B * B);
        const x1b = X1 + B;
        const D = mod(_2n * (mod(x1b * x1b) - A - C));
        const E = mod(_3n * A);
        const F = mod(E * E);
        const X3 = mod(F - _2n * D);
        const Y3 = mod(E * (D - X3) - _8n * C);
        const Z3 = mod(_2n * Y1 * Z1);
        return new JacobianPoint(X3, Y3, Z3);
    }
    add(other) {
        assertJacPoint(other);
        const { x: X1, y: Y1, z: Z1 } = this;
        const { x: X2, y: Y2, z: Z2 } = other;
        if (X2 === _0n || Y2 === _0n)
            return this;
        if (X1 === _0n || Y1 === _0n)
            return other;
        const Z1Z1 = mod(Z1 * Z1);
        const Z2Z2 = mod(Z2 * Z2);
        const U1 = mod(X1 * Z2Z2);
        const U2 = mod(X2 * Z1Z1);
        const S1 = mod(mod(Y1 * Z2) * Z2Z2);
        const S2 = mod(mod(Y2 * Z1) * Z1Z1);
        const H = mod(U2 - U1);
        const r = mod(S2 - S1);
        if (H === _0n) {
            if (r === _0n) {
                return this.double();
            }
            else {
                return JacobianPoint.ZERO;
            }
        }
        const HH = mod(H * H);
        const HHH = mod(H * HH);
        const V = mod(U1 * HH);
        const X3 = mod(r * r - HHH - _2n * V);
        const Y3 = mod(r * (V - X3) - S1 * HHH);
        const Z3 = mod(Z1 * Z2 * H);
        return new JacobianPoint(X3, Y3, Z3);
    }
    subtract(other) {
        return this.add(other.negate());
    }
    multiplyUnsafe(scalar) {
        const P0 = JacobianPoint.ZERO;
        if (typeof scalar === 'bigint' && scalar === _0n)
            return P0;
        let n = normalizeScalar(scalar);
        if (n === _1n)
            return this;
        if (!USE_ENDOMORPHISM) {
            let p = P0;
            let d = this;
            while (n > _0n) {
                if (n & _1n)
                    p = p.add(d);
                d = d.double();
                n >>= _1n;
            }
            return p;
        }
        let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
        let k1p = P0;
        let k2p = P0;
        let d = this;
        while (k1 > _0n || k2 > _0n) {
            if (k1 & _1n)
                k1p = k1p.add(d);
            if (k2 & _1n)
                k2p = k2p.add(d);
            d = d.double();
            k1 >>= _1n;
            k2 >>= _1n;
        }
        if (k1neg)
            k1p = k1p.negate();
        if (k2neg)
            k2p = k2p.negate();
        k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);
        return k1p.add(k2p);
    }
    precomputeWindow(W) {
        const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;
        const points = [];
        let p = this;
        let base = p;
        for (let window = 0; window < windows; window++) {
            base = p;
            points.push(base);
            for (let i = 1; i < 2 ** (W - 1); i++) {
                base = base.add(p);
                points.push(base);
            }
            p = base.double();
        }
        return points;
    }
    wNAF(n, affinePoint) {
        if (!affinePoint && this.equals(JacobianPoint.BASE))
            affinePoint = Point.BASE;
        const W = (affinePoint && affinePoint._WINDOW_SIZE) || 1;
        if (256 % W) {
            throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');
        }
        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);
        if (!precomputes) {
            precomputes = this.precomputeWindow(W);
            if (affinePoint && W !== 1) {
                precomputes = JacobianPoint.normalizeZ(precomputes);
                pointPrecomputes.set(affinePoint, precomputes);
            }
        }
        let p = JacobianPoint.ZERO;
        let f = JacobianPoint.BASE;
        const windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);
        const windowSize = 2 ** (W - 1);
        const mask = BigInt(2 ** W - 1);
        const maxNumber = 2 ** W;
        const shiftBy = BigInt(W);
        for (let window = 0; window < windows; window++) {
            const offset = window * windowSize;
            let wbits = Number(n & mask);
            n >>= shiftBy;
            if (wbits > windowSize) {
                wbits -= maxNumber;
                n += _1n;
            }
            const offset1 = offset;
            const offset2 = offset + Math.abs(wbits) - 1;
            const cond1 = window % 2 !== 0;
            const cond2 = wbits < 0;
            if (wbits === 0) {
                f = f.add(constTimeNegate(cond1, precomputes[offset1]));
            }
            else {
                p = p.add(constTimeNegate(cond2, precomputes[offset2]));
            }
        }
        return { p, f };
    }
    multiply(scalar, affinePoint) {
        let n = normalizeScalar(scalar);
        let point;
        let fake;
        if (USE_ENDOMORPHISM) {
            const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
            let { p: k1p, f: f1p } = this.wNAF(k1, affinePoint);
            let { p: k2p, f: f2p } = this.wNAF(k2, affinePoint);
            k1p = constTimeNegate(k1neg, k1p);
            k2p = constTimeNegate(k2neg, k2p);
            k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);
            point = k1p.add(k2p);
            fake = f1p.add(f2p);
        }
        else {
            const { p, f } = this.wNAF(n, affinePoint);
            point = p;
            fake = f;
        }
        return JacobianPoint.normalizeZ([point, fake])[0];
    }
    toAffine(invZ) {
        const { x, y, z } = this;
        const is0 = this.equals(JacobianPoint.ZERO);
        if (invZ == null)
            invZ = is0 ? _8n : invert(z);
        const iz1 = invZ;
        const iz2 = mod(iz1 * iz1);
        const iz3 = mod(iz2 * iz1);
        const ax = mod(x * iz2);
        const ay = mod(y * iz3);
        const zz = mod(z * iz1);
        if (is0)
            return Point.ZERO;
        if (zz !== _1n)
            throw new Error('invZ was invalid');
        return new Point(ax, ay);
    }
}
JacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n);
JacobianPoint.ZERO = new JacobianPoint(_0n, _1n, _0n);
function constTimeNegate(condition, item) {
    const neg = item.negate();
    return condition ? neg : item;
}
const pointPrecomputes = new WeakMap();
class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    _setWindowSize(windowSize) {
        this._WINDOW_SIZE = windowSize;
        pointPrecomputes.delete(this);
    }
    hasEvenY() {
        return this.y % _2n === _0n;
    }
    static fromCompressedHex(bytes) {
        const isShort = bytes.length === 32;
        const x = bytesToNumber(isShort ? bytes : bytes.subarray(1));
        if (!isValidFieldElement(x))
            throw new Error('Point is not on curve');
        const y2 = weierstrass(x);
        let y = sqrtMod(y2);
        const isYOdd = (y & _1n) === _1n;
        if (isShort) {
            if (isYOdd)
                y = mod(-y);
        }
        else {
            const isFirstByteOdd = (bytes[0] & 1) === 1;
            if (isFirstByteOdd !== isYOdd)
                y = mod(-y);
        }
        const point = new Point(x, y);
        point.assertValidity();
        return point;
    }
    static fromUncompressedHex(bytes) {
        const x = bytesToNumber(bytes.subarray(1, fieldLen + 1));
        const y = bytesToNumber(bytes.subarray(fieldLen + 1, fieldLen * 2 + 1));
        const point = new Point(x, y);
        point.assertValidity();
        return point;
    }
    static fromHex(hex) {
        const bytes = ensureBytes(hex);
        const len = bytes.length;
        const header = bytes[0];
        if (len === fieldLen)
            return this.fromCompressedHex(bytes);
        if (len === compressedLen && (header === 0x02 || header === 0x03)) {
            return this.fromCompressedHex(bytes);
        }
        if (len === uncompressedLen && header === 0x04)
            return this.fromUncompressedHex(bytes);
        throw new Error(`Point.fromHex: received invalid point. Expected 32-${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes, not ${len}`);
    }
    static fromPrivateKey(privateKey) {
        return Point.BASE.multiply(normalizePrivateKey(privateKey));
    }
    static fromSignature(msgHash, signature, recovery) {
        const { r, s } = normalizeSignature(signature);
        if (![0, 1, 2, 3].includes(recovery))
            throw new Error('Cannot recover: invalid recovery bit');
        const h = truncateHash(ensureBytes(msgHash));
        const { n } = CURVE;
        const radj = recovery === 2 || recovery === 3 ? r + n : r;
        const rinv = invert(radj, n);
        const u1 = mod(-h * rinv, n);
        const u2 = mod(s * rinv, n);
        const prefix = recovery & 1 ? '03' : '02';
        const R = Point.fromHex(prefix + numTo32bStr(radj));
        const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
        if (!Q)
            throw new Error('Cannot recover signature: point at infinify');
        Q.assertValidity();
        return Q;
    }
    toRawBytes(isCompressed = false) {
        return hexToBytes(this.toHex(isCompressed));
    }
    toHex(isCompressed = false) {
        const x = numTo32bStr(this.x);
        if (isCompressed) {
            const prefix = this.hasEvenY() ? '02' : '03';
            return `${prefix}${x}`;
        }
        else {
            return `04${x}${numTo32bStr(this.y)}`;
        }
    }
    toHexX() {
        return this.toHex(true).slice(2);
    }
    toRawX() {
        return this.toRawBytes(true).slice(1);
    }
    assertValidity() {
        const msg = 'Point is not on elliptic curve';
        const { x, y } = this;
        if (!isValidFieldElement(x) || !isValidFieldElement(y))
            throw new Error(msg);
        const left = mod(y * y);
        const right = weierstrass(x);
        if (mod(left - right) !== _0n)
            throw new Error(msg);
    }
    equals(other) {
        return this.x === other.x && this.y === other.y;
    }
    negate() {
        return new Point(this.x, mod(-this.y));
    }
    double() {
        return JacobianPoint.fromAffine(this).double().toAffine();
    }
    add(other) {
        return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();
    }
    subtract(other) {
        return this.add(other.negate());
    }
    multiply(scalar) {
        return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();
    }
    multiplyAndAddUnsafe(Q, a, b) {
        const P = JacobianPoint.fromAffine(this);
        const aP = a === _0n || a === _1n || this !== Point.BASE ? P.multiplyUnsafe(a) : P.multiply(a);
        const bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);
        const sum = aP.add(bQ);
        return sum.equals(JacobianPoint.ZERO) ? undefined : sum.toAffine();
    }
}
exports.Point = Point;
Point.BASE = new Point(CURVE.Gx, CURVE.Gy);
Point.ZERO = new Point(_0n, _0n);
function sliceDER(s) {
    return Number.parseInt(s[0], 16) >= 8 ? '00' + s : s;
}
function parseDERInt(data) {
    if (data.length < 2 || data[0] !== 0x02) {
        throw new Error(`Invalid signature integer tag: ${bytesToHex(data)}`);
    }
    const len = data[1];
    const res = data.subarray(2, len + 2);
    if (!len || res.length !== len) {
        throw new Error(`Invalid signature integer: wrong length`);
    }
    if (res[0] === 0x00 && res[1] <= 0x7f) {
        throw new Error('Invalid signature integer: trailing length');
    }
    return { data: bytesToNumber(res), left: data.subarray(len + 2) };
}
function parseDERSignature(data) {
    if (data.length < 2 || data[0] != 0x30) {
        throw new Error(`Invalid signature tag: ${bytesToHex(data)}`);
    }
    if (data[1] !== data.length - 2) {
        throw new Error('Invalid signature: incorrect length');
    }
    const { data: r, left: sBytes } = parseDERInt(data.subarray(2));
    const { data: s, left: rBytesLeft } = parseDERInt(sBytes);
    if (rBytesLeft.length) {
        throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex(rBytesLeft)}`);
    }
    return { r, s };
}
class Signature {
    constructor(r, s) {
        this.r = r;
        this.s = s;
        this.assertValidity();
    }
    static fromCompact(hex) {
        const arr = hex instanceof Uint8Array;
        const name = 'Signature.fromCompact';
        if (typeof hex !== 'string' && !arr)
            throw new TypeError(`${name}: Expected string or Uint8Array`);
        const str = arr ? bytesToHex(hex) : hex;
        if (str.length !== 128)
            throw new Error(`${name}: Expected 64-byte hex`);
        return new Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));
    }
    static fromDER(hex) {
        const arr = hex instanceof Uint8Array;
        if (typeof hex !== 'string' && !arr)
            throw new TypeError(`Signature.fromDER: Expected string or Uint8Array`);
        const { r, s } = parseDERSignature(arr ? hex : hexToBytes(hex));
        return new Signature(r, s);
    }
    static fromHex(hex) {
        return this.fromDER(hex);
    }
    assertValidity() {
        const { r, s } = this;
        if (!isWithinCurveOrder(r))
            throw new Error('Invalid Signature: r must be 0 < r < n');
        if (!isWithinCurveOrder(s))
            throw new Error('Invalid Signature: s must be 0 < s < n');
    }
    hasHighS() {
        const HALF = CURVE.n >> _1n;
        return this.s > HALF;
    }
    normalizeS() {
        return this.hasHighS() ? new Signature(this.r, mod(-this.s, CURVE.n)) : this;
    }
    toDERRawBytes() {
        return hexToBytes(this.toDERHex());
    }
    toDERHex() {
        const sHex = sliceDER(numberToHexUnpadded(this.s));
        const rHex = sliceDER(numberToHexUnpadded(this.r));
        const sHexL = sHex.length / 2;
        const rHexL = rHex.length / 2;
        const sLen = numberToHexUnpadded(sHexL);
        const rLen = numberToHexUnpadded(rHexL);
        const length = numberToHexUnpadded(rHexL + sHexL + 4);
        return `30${length}02${rLen}${rHex}02${sLen}${sHex}`;
    }
    toRawBytes() {
        return this.toDERRawBytes();
    }
    toHex() {
        return this.toDERHex();
    }
    toCompactRawBytes() {
        return hexToBytes(this.toCompactHex());
    }
    toCompactHex() {
        return numTo32bStr(this.r) + numTo32bStr(this.s);
    }
}
exports.Signature = Signature;
function concatBytes(...arrays) {
    if (!arrays.every((b) => b instanceof Uint8Array))
        throw new Error('Uint8Array list expected');
    if (arrays.length === 1)
        return arrays[0];
    const length = arrays.reduce((a, arr) => a + arr.length, 0);
    const result = new Uint8Array(length);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
        const arr = arrays[i];
        result.set(arr, pad);
        pad += arr.length;
    }
    return result;
}
const hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));
function bytesToHex(uint8a) {
    if (!(uint8a instanceof Uint8Array))
        throw new Error('Expected Uint8Array');
    let hex = '';
    for (let i = 0; i < uint8a.length; i++) {
        hex += hexes[uint8a[i]];
    }
    return hex;
}
const POW_2_256 = BigInt('0x10000000000000000000000000000000000000000000000000000000000000000');
function numTo32bStr(num) {
    if (typeof num !== 'bigint')
        throw new Error('Expected bigint');
    if (!(_0n <= num && num < POW_2_256))
        throw new Error('Expected number 0 <= n < 2^256');
    return num.toString(16).padStart(64, '0');
}
function numTo32b(num) {
    const b = hexToBytes(numTo32bStr(num));
    if (b.length !== 32)
        throw new Error('Error: expected 32 bytes');
    return b;
}
function numberToHexUnpadded(num) {
    const hex = num.toString(16);
    return hex.length & 1 ? `0${hex}` : hex;
}
function hexToNumber(hex) {
    if (typeof hex !== 'string') {
        throw new TypeError('hexToNumber: expected string, got ' + typeof hex);
    }
    return BigInt(`0x${hex}`);
}
function hexToBytes(hex) {
    if (typeof hex !== 'string') {
        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);
    }
    if (hex.length % 2)
        throw new Error('hexToBytes: received invalid unpadded hex' + hex.length);
    const array = new Uint8Array(hex.length / 2);
    for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
            throw new Error('Invalid byte sequence');
        array[i] = byte;
    }
    return array;
}
function bytesToNumber(bytes) {
    return hexToNumber(bytesToHex(bytes));
}
function ensureBytes(hex) {
    return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);
}
function normalizeScalar(num) {
    if (typeof num === 'number' && Number.isSafeInteger(num) && num > 0)
        return BigInt(num);
    if (typeof num === 'bigint' && isWithinCurveOrder(num))
        return num;
    throw new TypeError('Expected valid private scalar: 0 < scalar < curve.n');
}
function mod(a, b = CURVE.P) {
    const result = a % b;
    return result >= _0n ? result : b + result;
}
function pow2(x, power) {
    const { P } = CURVE;
    let res = x;
    while (power-- > _0n) {
        res *= res;
        res %= P;
    }
    return res;
}
function sqrtMod(x) {
    const { P } = CURVE;
    const _6n = BigInt(6);
    const _11n = BigInt(11);
    const _22n = BigInt(22);
    const _23n = BigInt(23);
    const _44n = BigInt(44);
    const _88n = BigInt(88);
    const b2 = (x * x * x) % P;
    const b3 = (b2 * b2 * x) % P;
    const b6 = (pow2(b3, _3n) * b3) % P;
    const b9 = (pow2(b6, _3n) * b3) % P;
    const b11 = (pow2(b9, _2n) * b2) % P;
    const b22 = (pow2(b11, _11n) * b11) % P;
    const b44 = (pow2(b22, _22n) * b22) % P;
    const b88 = (pow2(b44, _44n) * b44) % P;
    const b176 = (pow2(b88, _88n) * b88) % P;
    const b220 = (pow2(b176, _44n) * b44) % P;
    const b223 = (pow2(b220, _3n) * b3) % P;
    const t1 = (pow2(b223, _23n) * b22) % P;
    const t2 = (pow2(t1, _6n) * b2) % P;
    const rt = pow2(t2, _2n);
    const xc = (rt * rt) % P;
    if (xc !== x)
        throw new Error('Cannot find square root');
    return rt;
}
function invert(number, modulo = CURVE.P) {
    if (number === _0n || modulo <= _0n) {
        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
    }
    let a = mod(number, modulo);
    let b = modulo;
    let x = _0n, y = _1n, u = _1n, v = _0n;
    while (a !== _0n) {
        const q = b / a;
        const r = b % a;
        const m = x - u * q;
        const n = y - v * q;
        b = a, a = r, x = u, y = v, u = m, v = n;
    }
    const gcd = b;
    if (gcd !== _1n)
        throw new Error('invert: does not exist');
    return mod(x, modulo);
}
function invertBatch(nums, p = CURVE.P) {
    const scratch = new Array(nums.length);
    const lastMultiplied = nums.reduce((acc, num, i) => {
        if (num === _0n)
            return acc;
        scratch[i] = acc;
        return mod(acc * num, p);
    }, _1n);
    const inverted = invert(lastMultiplied, p);
    nums.reduceRight((acc, num, i) => {
        if (num === _0n)
            return acc;
        scratch[i] = mod(acc * scratch[i], p);
        return mod(acc * num, p);
    }, inverted);
    return scratch;
}
function bits2int_2(bytes) {
    const delta = bytes.length * 8 - groupLen * 8;
    const num = bytesToNumber(bytes);
    return delta > 0 ? num >> BigInt(delta) : num;
}
function truncateHash(hash, truncateOnly = false) {
    const h = bits2int_2(hash);
    if (truncateOnly)
        return h;
    const { n } = CURVE;
    return h >= n ? h - n : h;
}
let _sha256Sync;
let _hmacSha256Sync;
class HmacDrbg {
    constructor(hashLen, qByteLen) {
        this.hashLen = hashLen;
        this.qByteLen = qByteLen;
        if (typeof hashLen !== 'number' || hashLen < 2)
            throw new Error('hashLen must be a number');
        if (typeof qByteLen !== 'number' || qByteLen < 2)
            throw new Error('qByteLen must be a number');
        this.v = new Uint8Array(hashLen).fill(1);
        this.k = new Uint8Array(hashLen).fill(0);
        this.counter = 0;
    }
    hmac(...values) {
        return exports.utils.hmacSha256(this.k, ...values);
    }
    hmacSync(...values) {
        return _hmacSha256Sync(this.k, ...values);
    }
    checkSync() {
        if (typeof _hmacSha256Sync !== 'function')
            throw new ShaError('hmacSha256Sync needs to be set');
    }
    incr() {
        if (this.counter >= 1000)
            throw new Error('Tried 1,000 k values for sign(), all were invalid');
        this.counter += 1;
    }
    async reseed(seed = new Uint8Array()) {
        this.k = await this.hmac(this.v, Uint8Array.from([0x00]), seed);
        this.v = await this.hmac(this.v);
        if (seed.length === 0)
            return;
        this.k = await this.hmac(this.v, Uint8Array.from([0x01]), seed);
        this.v = await this.hmac(this.v);
    }
    reseedSync(seed = new Uint8Array()) {
        this.checkSync();
        this.k = this.hmacSync(this.v, Uint8Array.from([0x00]), seed);
        this.v = this.hmacSync(this.v);
        if (seed.length === 0)
            return;
        this.k = this.hmacSync(this.v, Uint8Array.from([0x01]), seed);
        this.v = this.hmacSync(this.v);
    }
    async generate() {
        this.incr();
        let len = 0;
        const out = [];
        while (len < this.qByteLen) {
            this.v = await this.hmac(this.v);
            const sl = this.v.slice();
            out.push(sl);
            len += this.v.length;
        }
        return concatBytes(...out);
    }
    generateSync() {
        this.checkSync();
        this.incr();
        let len = 0;
        const out = [];
        while (len < this.qByteLen) {
            this.v = this.hmacSync(this.v);
            const sl = this.v.slice();
            out.push(sl);
            len += this.v.length;
        }
        return concatBytes(...out);
    }
}
function isWithinCurveOrder(num) {
    return _0n < num && num < CURVE.n;
}
function isValidFieldElement(num) {
    return _0n < num && num < CURVE.P;
}
function kmdToSig(kBytes, m, d, lowS = true) {
    const { n } = CURVE;
    const k = truncateHash(kBytes, true);
    if (!isWithinCurveOrder(k))
        return;
    const kinv = invert(k, n);
    const q = Point.BASE.multiply(k);
    const r = mod(q.x, n);
    if (r === _0n)
        return;
    const s = mod(kinv * mod(m + d * r, n), n);
    if (s === _0n)
        return;
    let sig = new Signature(r, s);
    let recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n);
    if (lowS && sig.hasHighS()) {
        sig = sig.normalizeS();
        recovery ^= 1;
    }
    return { sig, recovery };
}
function normalizePrivateKey(key) {
    let num;
    if (typeof key === 'bigint') {
        num = key;
    }
    else if (typeof key === 'number' && Number.isSafeInteger(key) && key > 0) {
        num = BigInt(key);
    }
    else if (typeof key === 'string') {
        if (key.length !== 2 * groupLen)
            throw new Error('Expected 32 bytes of private key');
        num = hexToNumber(key);
    }
    else if (key instanceof Uint8Array) {
        if (key.length !== groupLen)
            throw new Error('Expected 32 bytes of private key');
        num = bytesToNumber(key);
    }
    else {
        throw new TypeError('Expected valid private key');
    }
    if (!isWithinCurveOrder(num))
        throw new Error('Expected private key: 0 < key < n');
    return num;
}
function normalizePublicKey(publicKey) {
    if (publicKey instanceof Point) {
        publicKey.assertValidity();
        return publicKey;
    }
    else {
        return Point.fromHex(publicKey);
    }
}
function normalizeSignature(signature) {
    if (signature instanceof Signature) {
        signature.assertValidity();
        return signature;
    }
    try {
        return Signature.fromDER(signature);
    }
    catch (error) {
        return Signature.fromCompact(signature);
    }
}
function getPublicKey(privateKey, isCompressed = false) {
    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
}
exports.getPublicKey = getPublicKey;
function recoverPublicKey(msgHash, signature, recovery, isCompressed = false) {
    return Point.fromSignature(msgHash, signature, recovery).toRawBytes(isCompressed);
}
exports.recoverPublicKey = recoverPublicKey;
function isProbPub(item) {
    const arr = item instanceof Uint8Array;
    const str = typeof item === 'string';
    const len = (arr || str) && item.length;
    if (arr)
        return len === compressedLen || len === uncompressedLen;
    if (str)
        return len === compressedLen * 2 || len === uncompressedLen * 2;
    if (item instanceof Point)
        return true;
    return false;
}
function getSharedSecret(privateA, publicB, isCompressed = false) {
    if (isProbPub(privateA))
        throw new TypeError('getSharedSecret: first arg must be private key');
    if (!isProbPub(publicB))
        throw new TypeError('getSharedSecret: second arg must be public key');
    const b = normalizePublicKey(publicB);
    b.assertValidity();
    return b.multiply(normalizePrivateKey(privateA)).toRawBytes(isCompressed);
}
exports.getSharedSecret = getSharedSecret;
function bits2int(bytes) {
    const slice = bytes.length > fieldLen ? bytes.slice(0, fieldLen) : bytes;
    return bytesToNumber(slice);
}
function bits2octets(bytes) {
    const z1 = bits2int(bytes);
    const z2 = mod(z1, CURVE.n);
    return int2octets(z2 < _0n ? z1 : z2);
}
function int2octets(num) {
    return numTo32b(num);
}
function initSigArgs(msgHash, privateKey, extraEntropy) {
    if (msgHash == null)
        throw new Error(`sign: expected valid message hash, not "${msgHash}"`);
    const h1 = ensureBytes(msgHash);
    const d = normalizePrivateKey(privateKey);
    const seedArgs = [int2octets(d), bits2octets(h1)];
    if (extraEntropy != null) {
        if (extraEntropy === true)
            extraEntropy = exports.utils.randomBytes(fieldLen);
        const e = ensureBytes(extraEntropy);
        if (e.length !== fieldLen)
            throw new Error(`sign: Expected ${fieldLen} bytes of extra data`);
        seedArgs.push(e);
    }
    const seed = concatBytes(...seedArgs);
    const m = bits2int(h1);
    return { seed, m, d };
}
function finalizeSig(recSig, opts) {
    const { sig, recovery } = recSig;
    const { der, recovered } = Object.assign({ canonical: true, der: true }, opts);
    const hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();
    return recovered ? [hashed, recovery] : hashed;
}
async function sign(msgHash, privKey, opts = {}) {
    const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);
    const drbg = new HmacDrbg(hashLen, groupLen);
    await drbg.reseed(seed);
    let sig;
    while (!(sig = kmdToSig(await drbg.generate(), m, d, opts.canonical)))
        await drbg.reseed();
    return finalizeSig(sig, opts);
}
exports.sign = sign;
function signSync(msgHash, privKey, opts = {}) {
    const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);
    const drbg = new HmacDrbg(hashLen, groupLen);
    drbg.reseedSync(seed);
    let sig;
    while (!(sig = kmdToSig(drbg.generateSync(), m, d, opts.canonical)))
        drbg.reseedSync();
    return finalizeSig(sig, opts);
}
exports.signSync = signSync;
const vopts = { strict: true };
function verify(signature, msgHash, publicKey, opts = vopts) {
    let sig;
    try {
        sig = normalizeSignature(signature);
        msgHash = ensureBytes(msgHash);
    }
    catch (error) {
        return false;
    }
    const { r, s } = sig;
    if (opts.strict && sig.hasHighS())
        return false;
    const h = truncateHash(msgHash);
    let P;
    try {
        P = normalizePublicKey(publicKey);
    }
    catch (error) {
        return false;
    }
    const { n } = CURVE;
    const sinv = invert(s, n);
    const u1 = mod(h * sinv, n);
    const u2 = mod(r * sinv, n);
    const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2);
    if (!R)
        return false;
    const v = mod(R.x, n);
    return v === r;
}
exports.verify = verify;
function schnorrChallengeFinalize(ch) {
    return mod(bytesToNumber(ch), CURVE.n);
}
class SchnorrSignature {
    constructor(r, s) {
        this.r = r;
        this.s = s;
        this.assertValidity();
    }
    static fromHex(hex) {
        const bytes = ensureBytes(hex);
        if (bytes.length !== 64)
            throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${bytes.length}`);
        const r = bytesToNumber(bytes.subarray(0, 32));
        const s = bytesToNumber(bytes.subarray(32, 64));
        return new SchnorrSignature(r, s);
    }
    assertValidity() {
        const { r, s } = this;
        if (!isValidFieldElement(r) || !isWithinCurveOrder(s))
            throw new Error('Invalid signature');
    }
    toHex() {
        return numTo32bStr(this.r) + numTo32bStr(this.s);
    }
    toRawBytes() {
        return hexToBytes(this.toHex());
    }
}
function schnorrGetPublicKey(privateKey) {
    return Point.fromPrivateKey(privateKey).toRawX();
}
class InternalSchnorrSignature {
    constructor(message, privateKey, auxRand = exports.utils.randomBytes()) {
        if (message == null)
            throw new TypeError(`sign: Expected valid message, not "${message}"`);
        this.m = ensureBytes(message);
        const { x, scalar } = this.getScalar(normalizePrivateKey(privateKey));
        this.px = x;
        this.d = scalar;
        this.rand = ensureBytes(auxRand);
        if (this.rand.length !== 32)
            throw new TypeError('sign: Expected 32 bytes of aux randomness');
    }
    getScalar(priv) {
        const point = Point.fromPrivateKey(priv);
        const scalar = point.hasEvenY() ? priv : CURVE.n - priv;
        return { point, scalar, x: point.toRawX() };
    }
    initNonce(d, t0h) {
        return numTo32b(d ^ bytesToNumber(t0h));
    }
    finalizeNonce(k0h) {
        const k0 = mod(bytesToNumber(k0h), CURVE.n);
        if (k0 === _0n)
            throw new Error('sign: Creation of signature failed. k is zero');
        const { point: R, x: rx, scalar: k } = this.getScalar(k0);
        return { R, rx, k };
    }
    finalizeSig(R, k, e, d) {
        return new SchnorrSignature(R.x, mod(k + e * d, CURVE.n)).toRawBytes();
    }
    error() {
        throw new Error('sign: Invalid signature produced');
    }
    async calc() {
        const { m, d, px, rand } = this;
        const tag = exports.utils.taggedHash;
        const t = this.initNonce(d, await tag(TAGS.aux, rand));
        const { R, rx, k } = this.finalizeNonce(await tag(TAGS.nonce, t, px, m));
        const e = schnorrChallengeFinalize(await tag(TAGS.challenge, rx, px, m));
        const sig = this.finalizeSig(R, k, e, d);
        if (!(await schnorrVerify(sig, m, px)))
            this.error();
        return sig;
    }
    calcSync() {
        const { m, d, px, rand } = this;
        const tag = exports.utils.taggedHashSync;
        const t = this.initNonce(d, tag(TAGS.aux, rand));
        const { R, rx, k } = this.finalizeNonce(tag(TAGS.nonce, t, px, m));
        const e = schnorrChallengeFinalize(tag(TAGS.challenge, rx, px, m));
        const sig = this.finalizeSig(R, k, e, d);
        if (!schnorrVerifySync(sig, m, px))
            this.error();
        return sig;
    }
}
async function schnorrSign(msg, privKey, auxRand) {
    return new InternalSchnorrSignature(msg, privKey, auxRand).calc();
}
function schnorrSignSync(msg, privKey, auxRand) {
    return new InternalSchnorrSignature(msg, privKey, auxRand).calcSync();
}
function initSchnorrVerify(signature, message, publicKey) {
    const raw = signature instanceof SchnorrSignature;
    const sig = raw ? signature : SchnorrSignature.fromHex(signature);
    if (raw)
        sig.assertValidity();
    return {
        ...sig,
        m: ensureBytes(message),
        P: normalizePublicKey(publicKey),
    };
}
function finalizeSchnorrVerify(r, P, s, e) {
    const R = Point.BASE.multiplyAndAddUnsafe(P, normalizePrivateKey(s), mod(-e, CURVE.n));
    if (!R || !R.hasEvenY() || R.x !== r)
        return false;
    return true;
}
async function schnorrVerify(signature, message, publicKey) {
    try {
        const { r, s, m, P } = initSchnorrVerify(signature, message, publicKey);
        const e = schnorrChallengeFinalize(await exports.utils.taggedHash(TAGS.challenge, numTo32b(r), P.toRawX(), m));
        return finalizeSchnorrVerify(r, P, s, e);
    }
    catch (error) {
        return false;
    }
}
function schnorrVerifySync(signature, message, publicKey) {
    try {
        const { r, s, m, P } = initSchnorrVerify(signature, message, publicKey);
        const e = schnorrChallengeFinalize(exports.utils.taggedHashSync(TAGS.challenge, numTo32b(r), P.toRawX(), m));
        return finalizeSchnorrVerify(r, P, s, e);
    }
    catch (error) {
        if (error instanceof ShaError)
            throw error;
        return false;
    }
}
exports.schnorr = {
    Signature: SchnorrSignature,
    getPublicKey: schnorrGetPublicKey,
    sign: schnorrSign,
    verify: schnorrVerify,
    signSync: schnorrSignSync,
    verifySync: schnorrVerifySync,
};
Point.BASE._setWindowSize(8);
const crypto = {
    node: nodeCrypto,
    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,
};
const TAGS = {
    challenge: 'BIP0340/challenge',
    aux: 'BIP0340/aux',
    nonce: 'BIP0340/nonce',
};
const TAGGED_HASH_PREFIXES = {};
exports.utils = {
    bytesToHex,
    hexToBytes,
    concatBytes,
    mod,
    invert,
    isValidPrivateKey(privateKey) {
        try {
            normalizePrivateKey(privateKey);
            return true;
        }
        catch (error) {
            return false;
        }
    },
    _bigintTo32Bytes: numTo32b,
    _normalizePrivateKey: normalizePrivateKey,
    hashToPrivateKey: (hash) => {
        hash = ensureBytes(hash);
        const minLen = groupLen + 8;
        if (hash.length < minLen || hash.length > 1024) {
            throw new Error(`Expected valid bytes of private key as per FIPS 186`);
        }
        const num = mod(bytesToNumber(hash), CURVE.n - _1n) + _1n;
        return numTo32b(num);
    },
    randomBytes: (bytesLength = 32) => {
        if (crypto.web) {
            return crypto.web.getRandomValues(new Uint8Array(bytesLength));
        }
        else if (crypto.node) {
            const { randomBytes } = crypto.node;
            return Uint8Array.from(randomBytes(bytesLength));
        }
        else {
            throw new Error("The environment doesn't have randomBytes function");
        }
    },
    randomPrivateKey: () => exports.utils.hashToPrivateKey(exports.utils.randomBytes(groupLen + 8)),
    precompute(windowSize = 8, point = Point.BASE) {
        const cached = point === Point.BASE ? point : new Point(point.x, point.y);
        cached._setWindowSize(windowSize);
        cached.multiply(_3n);
        return cached;
    },
    sha256: async (...messages) => {
        if (crypto.web) {
            const buffer = await crypto.web.subtle.digest('SHA-256', concatBytes(...messages));
            return new Uint8Array(buffer);
        }
        else if (crypto.node) {
            const { createHash } = crypto.node;
            const hash = createHash('sha256');
            messages.forEach((m) => hash.update(m));
            return Uint8Array.from(hash.digest());
        }
        else {
            throw new Error("The environment doesn't have sha256 function");
        }
    },
    hmacSha256: async (key, ...messages) => {
        if (crypto.web) {
            const ckey = await crypto.web.subtle.importKey('raw', key, { name: 'HMAC', hash: { name: 'SHA-256' } }, false, ['sign']);
            const message = concatBytes(...messages);
            const buffer = await crypto.web.subtle.sign('HMAC', ckey, message);
            return new Uint8Array(buffer);
        }
        else if (crypto.node) {
            const { createHmac } = crypto.node;
            const hash = createHmac('sha256', key);
            messages.forEach((m) => hash.update(m));
            return Uint8Array.from(hash.digest());
        }
        else {
            throw new Error("The environment doesn't have hmac-sha256 function");
        }
    },
    sha256Sync: undefined,
    hmacSha256Sync: undefined,
    taggedHash: async (tag, ...messages) => {
        let tagP = TAGGED_HASH_PREFIXES[tag];
        if (tagP === undefined) {
            const tagH = await exports.utils.sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
            tagP = concatBytes(tagH, tagH);
            TAGGED_HASH_PREFIXES[tag] = tagP;
        }
        return exports.utils.sha256(tagP, ...messages);
    },
    taggedHashSync: (tag, ...messages) => {
        if (typeof _sha256Sync !== 'function')
            throw new ShaError('sha256Sync is undefined, you need to set it');
        let tagP = TAGGED_HASH_PREFIXES[tag];
        if (tagP === undefined) {
            const tagH = _sha256Sync(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
            tagP = concatBytes(tagH, tagH);
            TAGGED_HASH_PREFIXES[tag] = tagP;
        }
        return _sha256Sync(tagP, ...messages);
    },
    _JacobianPoint: JacobianPoint,
};
Object.defineProperties(exports.utils, {
    sha256Sync: {
        configurable: false,
        get() {
            return _sha256Sync;
        },
        set(val) {
            if (!_sha256Sync)
                _sha256Sync = val;
        },
    },
    hmacSha256Sync: {
        configurable: false,
        get() {
            return _hmacSha256Sync;
        },
        set(val) {
            if (!_hmacSha256Sync)
                _hmacSha256Sync = val;
        },
    },
});

},{"crypto":1}],16:[function(require,module,exports){
"use strict";
/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
Object.defineProperty(exports, "__esModule", { value: true });
exports.bytes = exports.stringToBytes = exports.str = exports.bytesToString = exports.hex = exports.utf8 = exports.bech32m = exports.bech32 = exports.base58check = exports.base58xmr = exports.base58xrp = exports.base58flickr = exports.base58 = exports.base64url = exports.base64 = exports.base32crockford = exports.base32hex = exports.base32 = exports.base16 = exports.utils = exports.assertNumber = void 0;
function assertNumber(n) {
    if (!Number.isSafeInteger(n))
        throw new Error(`Wrong integer: ${n}`);
}
exports.assertNumber = assertNumber;
function chain(...args) {
    const wrap = (a, b) => (c) => a(b(c));
    const encode = Array.from(args)
        .reverse()
        .reduce((acc, i) => (acc ? wrap(acc, i.encode) : i.encode), undefined);
    const decode = args.reduce((acc, i) => (acc ? wrap(acc, i.decode) : i.decode), undefined);
    return { encode, decode };
}
function alphabet(alphabet) {
    return {
        encode: (digits) => {
            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))
                throw new Error('alphabet.encode input should be an array of numbers');
            return digits.map((i) => {
                assertNumber(i);
                if (i < 0 || i >= alphabet.length)
                    throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);
                return alphabet[i];
            });
        },
        decode: (input) => {
            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))
                throw new Error('alphabet.decode input should be array of strings');
            return input.map((letter) => {
                if (typeof letter !== 'string')
                    throw new Error(`alphabet.decode: not string element=${letter}`);
                const index = alphabet.indexOf(letter);
                if (index === -1)
                    throw new Error(`Unknown letter: "${letter}". Allowed: ${alphabet}`);
                return index;
            });
        },
    };
}
function join(separator = '') {
    if (typeof separator !== 'string')
        throw new Error('join separator should be string');
    return {
        encode: (from) => {
            if (!Array.isArray(from) || (from.length && typeof from[0] !== 'string'))
                throw new Error('join.encode input should be array of strings');
            for (let i of from)
                if (typeof i !== 'string')
                    throw new Error(`join.encode: non-string input=${i}`);
            return from.join(separator);
        },
        decode: (to) => {
            if (typeof to !== 'string')
                throw new Error('join.decode input should be string');
            return to.split(separator);
        },
    };
}
function padding(bits, chr = '=') {
    assertNumber(bits);
    if (typeof chr !== 'string')
        throw new Error('padding chr should be string');
    return {
        encode(data) {
            if (!Array.isArray(data) || (data.length && typeof data[0] !== 'string'))
                throw new Error('padding.encode input should be array of strings');
            for (let i of data)
                if (typeof i !== 'string')
                    throw new Error(`padding.encode: non-string input=${i}`);
            while ((data.length * bits) % 8)
                data.push(chr);
            return data;
        },
        decode(input) {
            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))
                throw new Error('padding.encode input should be array of strings');
            for (let i of input)
                if (typeof i !== 'string')
                    throw new Error(`padding.decode: non-string input=${i}`);
            let end = input.length;
            if ((end * bits) % 8)
                throw new Error('Invalid padding: string should have whole number of bytes');
            for (; end > 0 && input[end - 1] === chr; end--) {
                if (!(((end - 1) * bits) % 8))
                    throw new Error('Invalid padding: string has too much padding');
            }
            return input.slice(0, end);
        },
    };
}
function normalize(fn) {
    if (typeof fn !== 'function')
        throw new Error('normalize fn should be function');
    return { encode: (from) => from, decode: (to) => fn(to) };
}
function convertRadix(data, from, to) {
    if (from < 2)
        throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);
    if (to < 2)
        throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);
    if (!Array.isArray(data))
        throw new Error('convertRadix: data should be array');
    if (!data.length)
        return [];
    let pos = 0;
    const res = [];
    const digits = Array.from(data);
    digits.forEach((d) => {
        assertNumber(d);
        if (d < 0 || d >= from)
            throw new Error(`Wrong integer: ${d}`);
    });
    while (true) {
        let carry = 0;
        let done = true;
        for (let i = pos; i < digits.length; i++) {
            const digit = digits[i];
            const digitBase = from * carry + digit;
            if (!Number.isSafeInteger(digitBase) ||
                (from * carry) / from !== carry ||
                digitBase - digit !== from * carry) {
                throw new Error('convertRadix: carry overflow');
            }
            carry = digitBase % to;
            digits[i] = Math.floor(digitBase / to);
            if (!Number.isSafeInteger(digits[i]) || digits[i] * to + carry !== digitBase)
                throw new Error('convertRadix: carry overflow');
            if (!done)
                continue;
            else if (!digits[i])
                pos = i;
            else
                done = false;
        }
        res.push(carry);
        if (done)
            break;
    }
    for (let i = 0; i < data.length - 1 && data[i] === 0; i++)
        res.push(0);
    return res.reverse();
}
const gcd = (a, b) => (!b ? a : gcd(b, a % b));
const radix2carry = (from, to) => from + (to - gcd(from, to));
function convertRadix2(data, from, to, padding) {
    if (!Array.isArray(data))
        throw new Error('convertRadix2: data should be array');
    if (from <= 0 || from > 32)
        throw new Error(`convertRadix2: wrong from=${from}`);
    if (to <= 0 || to > 32)
        throw new Error(`convertRadix2: wrong to=${to}`);
    if (radix2carry(from, to) > 32) {
        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);
    }
    let carry = 0;
    let pos = 0;
    const mask = 2 ** to - 1;
    const res = [];
    for (const n of data) {
        assertNumber(n);
        if (n >= 2 ** from)
            throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);
        carry = (carry << from) | n;
        if (pos + from > 32)
            throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
        pos += from;
        for (; pos >= to; pos -= to)
            res.push(((carry >> (pos - to)) & mask) >>> 0);
        carry &= 2 ** pos - 1;
    }
    carry = (carry << (to - pos)) & mask;
    if (!padding && pos >= from)
        throw new Error('Excess padding');
    if (!padding && carry)
        throw new Error(`Non-zero padding: ${carry}`);
    if (padding && pos > 0)
        res.push(carry >>> 0);
    return res;
}
function radix(num) {
    assertNumber(num);
    return {
        encode: (bytes) => {
            if (!(bytes instanceof Uint8Array))
                throw new Error('radix.encode input should be Uint8Array');
            return convertRadix(Array.from(bytes), 2 ** 8, num);
        },
        decode: (digits) => {
            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))
                throw new Error('radix.decode input should be array of strings');
            return Uint8Array.from(convertRadix(digits, num, 2 ** 8));
        },
    };
}
function radix2(bits, revPadding = false) {
    assertNumber(bits);
    if (bits <= 0 || bits > 32)
        throw new Error('radix2: bits should be in (0..32]');
    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)
        throw new Error('radix2: carry overflow');
    return {
        encode: (bytes) => {
            if (!(bytes instanceof Uint8Array))
                throw new Error('radix2.encode input should be Uint8Array');
            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);
        },
        decode: (digits) => {
            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))
                throw new Error('radix2.decode input should be array of strings');
            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
        },
    };
}
function unsafeWrapper(fn) {
    if (typeof fn !== 'function')
        throw new Error('unsafeWrapper fn should be function');
    return function (...args) {
        try {
            return fn.apply(null, args);
        }
        catch (e) { }
    };
}
function checksum(len, fn) {
    assertNumber(len);
    if (typeof fn !== 'function')
        throw new Error('checksum fn should be function');
    return {
        encode(data) {
            if (!(data instanceof Uint8Array))
                throw new Error('checksum.encode: input should be Uint8Array');
            const checksum = fn(data).slice(0, len);
            const res = new Uint8Array(data.length + len);
            res.set(data);
            res.set(checksum, data.length);
            return res;
        },
        decode(data) {
            if (!(data instanceof Uint8Array))
                throw new Error('checksum.decode: input should be Uint8Array');
            const payload = data.slice(0, -len);
            const newChecksum = fn(payload).slice(0, len);
            const oldChecksum = data.slice(-len);
            for (let i = 0; i < len; i++)
                if (newChecksum[i] !== oldChecksum[i])
                    throw new Error('Invalid checksum');
            return payload;
        },
    };
}
exports.utils = { alphabet, chain, checksum, radix, radix2, join, padding };
exports.base16 = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));
exports.base32 = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));
exports.base32hex = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));
exports.base32crockford = chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize((s) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));
exports.base64 = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));
exports.base64url = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));
const genBase58 = (abc) => chain(radix(58), alphabet(abc), join(''));
exports.base58 = genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');
exports.base58flickr = genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');
exports.base58xrp = genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');
const XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];
exports.base58xmr = {
    encode(data) {
        let res = '';
        for (let i = 0; i < data.length; i += 8) {
            const block = data.subarray(i, i + 8);
            res += exports.base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');
        }
        return res;
    },
    decode(str) {
        let res = [];
        for (let i = 0; i < str.length; i += 11) {
            const slice = str.slice(i, i + 11);
            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);
            const block = exports.base58.decode(slice);
            for (let j = 0; j < block.length - blockLen; j++) {
                if (block[j] !== 0)
                    throw new Error('base58xmr: wrong padding');
            }
            res = res.concat(Array.from(block.slice(block.length - blockLen)));
        }
        return Uint8Array.from(res);
    },
};
const base58check = (sha256) => chain(checksum(4, (data) => sha256(sha256(data))), exports.base58);
exports.base58check = base58check;
const BECH_ALPHABET = chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));
const POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];
function bech32Polymod(pre) {
    const b = pre >> 25;
    let chk = (pre & 0x1ffffff) << 5;
    for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {
        if (((b >> i) & 1) === 1)
            chk ^= POLYMOD_GENERATORS[i];
    }
    return chk;
}
function bechChecksum(prefix, words, encodingConst = 1) {
    const len = prefix.length;
    let chk = 1;
    for (let i = 0; i < len; i++) {
        const c = prefix.charCodeAt(i);
        if (c < 33 || c > 126)
            throw new Error(`Invalid prefix (${prefix})`);
        chk = bech32Polymod(chk) ^ (c >> 5);
    }
    chk = bech32Polymod(chk);
    for (let i = 0; i < len; i++)
        chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);
    for (let v of words)
        chk = bech32Polymod(chk) ^ v;
    for (let i = 0; i < 6; i++)
        chk = bech32Polymod(chk);
    chk ^= encodingConst;
    return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));
}
function genBech32(encoding) {
    const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;
    const _words = radix2(5);
    const fromWords = _words.decode;
    const toWords = _words.encode;
    const fromWordsUnsafe = unsafeWrapper(fromWords);
    function encode(prefix, words, limit = 90) {
        if (typeof prefix !== 'string')
            throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);
        if (!Array.isArray(words) || (words.length && typeof words[0] !== 'number'))
            throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);
        const actualLength = prefix.length + 7 + words.length;
        if (limit !== false && actualLength > limit)
            throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
        prefix = prefix.toLowerCase();
        return `${prefix}1${BECH_ALPHABET.encode(words)}${bechChecksum(prefix, words, ENCODING_CONST)}`;
    }
    function decode(str, limit = 90) {
        if (typeof str !== 'string')
            throw new Error(`bech32.decode input should be string, not ${typeof str}`);
        if (str.length < 8 || (limit !== false && str.length > limit))
            throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);
        const lowered = str.toLowerCase();
        if (str !== lowered && str !== str.toUpperCase())
            throw new Error(`String must be lowercase or uppercase`);
        str = lowered;
        const sepIndex = str.lastIndexOf('1');
        if (sepIndex === 0 || sepIndex === -1)
            throw new Error(`Letter "1" must be present between prefix and data only`);
        const prefix = str.slice(0, sepIndex);
        const _words = str.slice(sepIndex + 1);
        if (_words.length < 6)
            throw new Error('Data must be at least 6 characters long');
        const words = BECH_ALPHABET.decode(_words).slice(0, -6);
        const sum = bechChecksum(prefix, words, ENCODING_CONST);
        if (!_words.endsWith(sum))
            throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
        return { prefix, words };
    }
    const decodeUnsafe = unsafeWrapper(decode);
    function decodeToBytes(str) {
        const { prefix, words } = decode(str, false);
        return { prefix, words, bytes: fromWords(words) };
    }
    return { encode, decode, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };
}
exports.bech32 = genBech32('bech32');
exports.bech32m = genBech32('bech32m');
exports.utf8 = {
    encode: (data) => new TextDecoder().decode(data),
    decode: (str) => new TextEncoder().encode(str),
};
exports.hex = chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize((s) => {
    if (typeof s !== 'string' || s.length % 2)
        throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);
    return s.toLowerCase();
}));
const CODERS = {
    utf8: exports.utf8, hex: exports.hex, base16: exports.base16, base32: exports.base32, base64: exports.base64, base64url: exports.base64url, base58: exports.base58, base58xmr: exports.base58xmr
};
const coderTypeError = `Invalid encoding type. Available types: ${Object.keys(CODERS).join(', ')}`;
const bytesToString = (type, bytes) => {
    if (typeof type !== 'string' || !CODERS.hasOwnProperty(type))
        throw new TypeError(coderTypeError);
    if (!(bytes instanceof Uint8Array))
        throw new TypeError('bytesToString() expects Uint8Array');
    return CODERS[type].encode(bytes);
};
exports.bytesToString = bytesToString;
exports.str = exports.bytesToString;
const stringToBytes = (type, str) => {
    if (!CODERS.hasOwnProperty(type))
        throw new TypeError(coderTypeError);
    if (typeof str !== 'string')
        throw new TypeError('stringToBytes() expects string');
    return CODERS[type].decode(str);
};
exports.stringToBytes = stringToBytes;
exports.bytes = exports.stringToBytes;

},{}],17:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mnemonicToSeedSync = exports.mnemonicToSeed = exports.validateMnemonic = exports.entropyToMnemonic = exports.mnemonicToEntropy = exports.generateMnemonic = void 0;
/*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */
const _assert_1 = require("@noble/hashes/_assert");
const pbkdf2_1 = require("@noble/hashes/pbkdf2");
const sha256_1 = require("@noble/hashes/sha256");
const sha512_1 = require("@noble/hashes/sha512");
const utils_1 = require("@noble/hashes/utils");
const base_1 = require("@scure/base");
// Japanese wordlist
const isJapanese = (wordlist) => wordlist[0] === '\u3042\u3044\u3053\u304f\u3057\u3093';
// Normalization replaces equivalent sequences of characters
// so that any two texts that are equivalent will be reduced
// to the same sequence of code points, called the normal form of the original text.
function nfkd(str) {
    if (typeof str !== 'string')
        throw new TypeError(`Invalid mnemonic type: ${typeof str}`);
    return str.normalize('NFKD');
}
function normalize(str) {
    const norm = nfkd(str);
    const words = norm.split(' ');
    if (![12, 15, 18, 21, 24].includes(words.length))
        throw new Error('Invalid mnemonic');
    return { nfkd: norm, words };
}
function assertEntropy(entropy) {
    _assert_1.default.bytes(entropy, 16, 20, 24, 28, 32);
}
/**
 * Generate x random words. Uses Cryptographically-Secure Random Number Generator.
 * @param wordlist imported wordlist for specific language
 * @param strength mnemonic strength 128-256 bits
 * @example
 * generateMnemonic(wordlist, 128)
 * // 'legal winner thank year wave sausage worth useful legal winner thank yellow'
 */
function generateMnemonic(wordlist, strength = 128) {
    _assert_1.default.number(strength);
    if (strength % 32 !== 0 || strength > 256)
        throw new TypeError('Invalid entropy');
    return entropyToMnemonic((0, utils_1.randomBytes)(strength / 8), wordlist);
}
exports.generateMnemonic = generateMnemonic;
const calcChecksum = (entropy) => {
    // Checksum is ent.length/4 bits long
    const bitsLeft = 8 - entropy.length / 4;
    // Zero rightmost "bitsLeft" bits in byte
    // For example: bitsLeft=4 val=10111101 -> 10110000
    return new Uint8Array([((0, sha256_1.sha256)(entropy)[0] >> bitsLeft) << bitsLeft]);
};
function getCoder(wordlist) {
    if (!Array.isArray(wordlist) || wordlist.length !== 2 ** 11 || typeof wordlist[0] !== 'string')
        throw new Error('Worlist: expected array of 2048 strings');
    wordlist.forEach((i) => {
        if (typeof i !== 'string')
            throw new Error(`Wordlist: non-string element: ${i}`);
    });
    return base_1.utils.chain(base_1.utils.checksum(1, calcChecksum), base_1.utils.radix2(11, true), base_1.utils.alphabet(wordlist));
}
/**
 * Reversible: Converts mnemonic string to raw entropy in form of byte array.
 * @param mnemonic 12-24 words
 * @param wordlist imported wordlist for specific language
 * @example
 * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';
 * mnemonicToEntropy(mnem, wordlist)
 * // Produces
 * new Uint8Array([
 *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,
 *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f
 * ])
 */
function mnemonicToEntropy(mnemonic, wordlist) {
    const { words } = normalize(mnemonic);
    const entropy = getCoder(wordlist).decode(words);
    assertEntropy(entropy);
    return entropy;
}
exports.mnemonicToEntropy = mnemonicToEntropy;
/**
 * Reversible: Converts raw entropy in form of byte array to mnemonic string.
 * @param entropy byte array
 * @param wordlist imported wordlist for specific language
 * @returns 12-24 words
 * @example
 * const ent = new Uint8Array([
 *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,
 *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f
 * ]);
 * entropyToMnemonic(ent, wordlist);
 * // 'legal winner thank year wave sausage worth useful legal winner thank yellow'
 */
function entropyToMnemonic(entropy, wordlist) {
    assertEntropy(entropy);
    const words = getCoder(wordlist).encode(entropy);
    return words.join(isJapanese(wordlist) ? '\u3000' : ' ');
}
exports.entropyToMnemonic = entropyToMnemonic;
/**
 * Validates mnemonic for being 12-24 words contained in `wordlist`.
 */
function validateMnemonic(mnemonic, wordlist) {
    try {
        mnemonicToEntropy(mnemonic, wordlist);
    }
    catch (e) {
        return false;
    }
    return true;
}
exports.validateMnemonic = validateMnemonic;
const salt = (passphrase) => nfkd(`mnemonic${passphrase}`);
/**
 * Irreversible: Uses KDF to derive 64 bytes of key data from mnemonic + optional password.
 * @param mnemonic 12-24 words
 * @param passphrase string that will additionally protect the key
 * @returns 64 bytes of key data
 * @example
 * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';
 * await mnemonicToSeed(mnem, 'password');
 * // new Uint8Array([...64 bytes])
 */
function mnemonicToSeed(mnemonic, passphrase = '') {
    return (0, pbkdf2_1.pbkdf2Async)(sha512_1.sha512, normalize(mnemonic).nfkd, salt(passphrase), { c: 2048, dkLen: 64 });
}
exports.mnemonicToSeed = mnemonicToSeed;
/**
 * Irreversible: Uses KDF to derive 64 bytes of key data from mnemonic + optional password.
 * @param mnemonic 12-24 words
 * @param passphrase string that will additionally protect the key
 * @returns 64 bytes of key data
 * @example
 * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';
 * mnemonicToSeedSync(mnem, 'password');
 * // new Uint8Array([...64 bytes])
 */
function mnemonicToSeedSync(mnemonic, passphrase = '') {
    return (0, pbkdf2_1.pbkdf2)(sha512_1.sha512, normalize(mnemonic).nfkd, salt(passphrase), { c: 2048, dkLen: 64 });
}
exports.mnemonicToSeedSync = mnemonicToSeedSync;

},{"@noble/hashes/_assert":5,"@noble/hashes/pbkdf2":10,"@noble/hashes/sha256":12,"@noble/hashes/sha512":13,"@noble/hashes/utils":14,"@scure/base":16}],18:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.wordlist = void 0;
exports.wordlist = `abandon
ability
able
about
above
absent
absorb
abstract
absurd
abuse
access
accident
account
accuse
achieve
acid
acoustic
acquire
across
act
action
actor
actress
actual
adapt
add
addict
address
adjust
admit
adult
advance
advice
aerobic
affair
afford
afraid
again
age
agent
agree
ahead
aim
air
airport
aisle
alarm
album
alcohol
alert
alien
all
alley
allow
almost
alone
alpha
already
also
alter
always
amateur
amazing
among
amount
amused
analyst
anchor
ancient
anger
angle
angry
animal
ankle
announce
annual
another
answer
antenna
antique
anxiety
any
apart
apology
appear
apple
approve
april
arch
arctic
area
arena
argue
arm
armed
armor
army
around
arrange
arrest
arrive
arrow
art
artefact
artist
artwork
ask
aspect
assault
asset
assist
assume
asthma
athlete
atom
attack
attend
attitude
attract
auction
audit
august
aunt
author
auto
autumn
average
avocado
avoid
awake
aware
away
awesome
awful
awkward
axis
baby
bachelor
bacon
badge
bag
balance
balcony
ball
bamboo
banana
banner
bar
barely
bargain
barrel
base
basic
basket
battle
beach
bean
beauty
because
become
beef
before
begin
behave
behind
believe
below
belt
bench
benefit
best
betray
better
between
beyond
bicycle
bid
bike
bind
biology
bird
birth
bitter
black
blade
blame
blanket
blast
bleak
bless
blind
blood
blossom
blouse
blue
blur
blush
board
boat
body
boil
bomb
bone
bonus
book
boost
border
boring
borrow
boss
bottom
bounce
box
boy
bracket
brain
brand
brass
brave
bread
breeze
brick
bridge
brief
bright
bring
brisk
broccoli
broken
bronze
broom
brother
brown
brush
bubble
buddy
budget
buffalo
build
bulb
bulk
bullet
bundle
bunker
burden
burger
burst
bus
business
busy
butter
buyer
buzz
cabbage
cabin
cable
cactus
cage
cake
call
calm
camera
camp
can
canal
cancel
candy
cannon
canoe
canvas
canyon
capable
capital
captain
car
carbon
card
cargo
carpet
carry
cart
case
cash
casino
castle
casual
cat
catalog
catch
category
cattle
caught
cause
caution
cave
ceiling
celery
cement
census
century
cereal
certain
chair
chalk
champion
change
chaos
chapter
charge
chase
chat
cheap
check
cheese
chef
cherry
chest
chicken
chief
child
chimney
choice
choose
chronic
chuckle
chunk
churn
cigar
cinnamon
circle
citizen
city
civil
claim
clap
clarify
claw
clay
clean
clerk
clever
click
client
cliff
climb
clinic
clip
clock
clog
close
cloth
cloud
clown
club
clump
cluster
clutch
coach
coast
coconut
code
coffee
coil
coin
collect
color
column
combine
come
comfort
comic
common
company
concert
conduct
confirm
congress
connect
consider
control
convince
cook
cool
copper
copy
coral
core
corn
correct
cost
cotton
couch
country
couple
course
cousin
cover
coyote
crack
cradle
craft
cram
crane
crash
crater
crawl
crazy
cream
credit
creek
crew
cricket
crime
crisp
critic
crop
cross
crouch
crowd
crucial
cruel
cruise
crumble
crunch
crush
cry
crystal
cube
culture
cup
cupboard
curious
current
curtain
curve
cushion
custom
cute
cycle
dad
damage
damp
dance
danger
daring
dash
daughter
dawn
day
deal
debate
debris
decade
december
decide
decline
decorate
decrease
deer
defense
define
defy
degree
delay
deliver
demand
demise
denial
dentist
deny
depart
depend
deposit
depth
deputy
derive
describe
desert
design
desk
despair
destroy
detail
detect
develop
device
devote
diagram
dial
diamond
diary
dice
diesel
diet
differ
digital
dignity
dilemma
dinner
dinosaur
direct
dirt
disagree
discover
disease
dish
dismiss
disorder
display
distance
divert
divide
divorce
dizzy
doctor
document
dog
doll
dolphin
domain
donate
donkey
donor
door
dose
double
dove
draft
dragon
drama
drastic
draw
dream
dress
drift
drill
drink
drip
drive
drop
drum
dry
duck
dumb
dune
during
dust
dutch
duty
dwarf
dynamic
eager
eagle
early
earn
earth
easily
east
easy
echo
ecology
economy
edge
edit
educate
effort
egg
eight
either
elbow
elder
electric
elegant
element
elephant
elevator
elite
else
embark
embody
embrace
emerge
emotion
employ
empower
empty
enable
enact
end
endless
endorse
enemy
energy
enforce
engage
engine
enhance
enjoy
enlist
enough
enrich
enroll
ensure
enter
entire
entry
envelope
episode
equal
equip
era
erase
erode
erosion
error
erupt
escape
essay
essence
estate
eternal
ethics
evidence
evil
evoke
evolve
exact
example
excess
exchange
excite
exclude
excuse
execute
exercise
exhaust
exhibit
exile
exist
exit
exotic
expand
expect
expire
explain
expose
express
extend
extra
eye
eyebrow
fabric
face
faculty
fade
faint
faith
fall
false
fame
family
famous
fan
fancy
fantasy
farm
fashion
fat
fatal
father
fatigue
fault
favorite
feature
february
federal
fee
feed
feel
female
fence
festival
fetch
fever
few
fiber
fiction
field
figure
file
film
filter
final
find
fine
finger
finish
fire
firm
first
fiscal
fish
fit
fitness
fix
flag
flame
flash
flat
flavor
flee
flight
flip
float
flock
floor
flower
fluid
flush
fly
foam
focus
fog
foil
fold
follow
food
foot
force
forest
forget
fork
fortune
forum
forward
fossil
foster
found
fox
fragile
frame
frequent
fresh
friend
fringe
frog
front
frost
frown
frozen
fruit
fuel
fun
funny
furnace
fury
future
gadget
gain
galaxy
gallery
game
gap
garage
garbage
garden
garlic
garment
gas
gasp
gate
gather
gauge
gaze
general
genius
genre
gentle
genuine
gesture
ghost
giant
gift
giggle
ginger
giraffe
girl
give
glad
glance
glare
glass
glide
glimpse
globe
gloom
glory
glove
glow
glue
goat
goddess
gold
good
goose
gorilla
gospel
gossip
govern
gown
grab
grace
grain
grant
grape
grass
gravity
great
green
grid
grief
grit
grocery
group
grow
grunt
guard
guess
guide
guilt
guitar
gun
gym
habit
hair
half
hammer
hamster
hand
happy
harbor
hard
harsh
harvest
hat
have
hawk
hazard
head
health
heart
heavy
hedgehog
height
hello
helmet
help
hen
hero
hidden
high
hill
hint
hip
hire
history
hobby
hockey
hold
hole
holiday
hollow
home
honey
hood
hope
horn
horror
horse
hospital
host
hotel
hour
hover
hub
huge
human
humble
humor
hundred
hungry
hunt
hurdle
hurry
hurt
husband
hybrid
ice
icon
idea
identify
idle
ignore
ill
illegal
illness
image
imitate
immense
immune
impact
impose
improve
impulse
inch
include
income
increase
index
indicate
indoor
industry
infant
inflict
inform
inhale
inherit
initial
inject
injury
inmate
inner
innocent
input
inquiry
insane
insect
inside
inspire
install
intact
interest
into
invest
invite
involve
iron
island
isolate
issue
item
ivory
jacket
jaguar
jar
jazz
jealous
jeans
jelly
jewel
job
join
joke
journey
joy
judge
juice
jump
jungle
junior
junk
just
kangaroo
keen
keep
ketchup
key
kick
kid
kidney
kind
kingdom
kiss
kit
kitchen
kite
kitten
kiwi
knee
knife
knock
know
lab
label
labor
ladder
lady
lake
lamp
language
laptop
large
later
latin
laugh
laundry
lava
law
lawn
lawsuit
layer
lazy
leader
leaf
learn
leave
lecture
left
leg
legal
legend
leisure
lemon
lend
length
lens
leopard
lesson
letter
level
liar
liberty
library
license
life
lift
light
like
limb
limit
link
lion
liquid
list
little
live
lizard
load
loan
lobster
local
lock
logic
lonely
long
loop
lottery
loud
lounge
love
loyal
lucky
luggage
lumber
lunar
lunch
luxury
lyrics
machine
mad
magic
magnet
maid
mail
main
major
make
mammal
man
manage
mandate
mango
mansion
manual
maple
marble
march
margin
marine
market
marriage
mask
mass
master
match
material
math
matrix
matter
maximum
maze
meadow
mean
measure
meat
mechanic
medal
media
melody
melt
member
memory
mention
menu
mercy
merge
merit
merry
mesh
message
metal
method
middle
midnight
milk
million
mimic
mind
minimum
minor
minute
miracle
mirror
misery
miss
mistake
mix
mixed
mixture
mobile
model
modify
mom
moment
monitor
monkey
monster
month
moon
moral
more
morning
mosquito
mother
motion
motor
mountain
mouse
move
movie
much
muffin
mule
multiply
muscle
museum
mushroom
music
must
mutual
myself
mystery
myth
naive
name
napkin
narrow
nasty
nation
nature
near
neck
need
negative
neglect
neither
nephew
nerve
nest
net
network
neutral
never
news
next
nice
night
noble
noise
nominee
noodle
normal
north
nose
notable
note
nothing
notice
novel
now
nuclear
number
nurse
nut
oak
obey
object
oblige
obscure
observe
obtain
obvious
occur
ocean
october
odor
off
offer
office
often
oil
okay
old
olive
olympic
omit
once
one
onion
online
only
open
opera
opinion
oppose
option
orange
orbit
orchard
order
ordinary
organ
orient
original
orphan
ostrich
other
outdoor
outer
output
outside
oval
oven
over
own
owner
oxygen
oyster
ozone
pact
paddle
page
pair
palace
palm
panda
panel
panic
panther
paper
parade
parent
park
parrot
party
pass
patch
path
patient
patrol
pattern
pause
pave
payment
peace
peanut
pear
peasant
pelican
pen
penalty
pencil
people
pepper
perfect
permit
person
pet
phone
photo
phrase
physical
piano
picnic
picture
piece
pig
pigeon
pill
pilot
pink
pioneer
pipe
pistol
pitch
pizza
place
planet
plastic
plate
play
please
pledge
pluck
plug
plunge
poem
poet
point
polar
pole
police
pond
pony
pool
popular
portion
position
possible
post
potato
pottery
poverty
powder
power
practice
praise
predict
prefer
prepare
present
pretty
prevent
price
pride
primary
print
priority
prison
private
prize
problem
process
produce
profit
program
project
promote
proof
property
prosper
protect
proud
provide
public
pudding
pull
pulp
pulse
pumpkin
punch
pupil
puppy
purchase
purity
purpose
purse
push
put
puzzle
pyramid
quality
quantum
quarter
question
quick
quit
quiz
quote
rabbit
raccoon
race
rack
radar
radio
rail
rain
raise
rally
ramp
ranch
random
range
rapid
rare
rate
rather
raven
raw
razor
ready
real
reason
rebel
rebuild
recall
receive
recipe
record
recycle
reduce
reflect
reform
refuse
region
regret
regular
reject
relax
release
relief
rely
remain
remember
remind
remove
render
renew
rent
reopen
repair
repeat
replace
report
require
rescue
resemble
resist
resource
response
result
retire
retreat
return
reunion
reveal
review
reward
rhythm
rib
ribbon
rice
rich
ride
ridge
rifle
right
rigid
ring
riot
ripple
risk
ritual
rival
river
road
roast
robot
robust
rocket
romance
roof
rookie
room
rose
rotate
rough
round
route
royal
rubber
rude
rug
rule
run
runway
rural
sad
saddle
sadness
safe
sail
salad
salmon
salon
salt
salute
same
sample
sand
satisfy
satoshi
sauce
sausage
save
say
scale
scan
scare
scatter
scene
scheme
school
science
scissors
scorpion
scout
scrap
screen
script
scrub
sea
search
season
seat
second
secret
section
security
seed
seek
segment
select
sell
seminar
senior
sense
sentence
series
service
session
settle
setup
seven
shadow
shaft
shallow
share
shed
shell
sheriff
shield
shift
shine
ship
shiver
shock
shoe
shoot
shop
short
shoulder
shove
shrimp
shrug
shuffle
shy
sibling
sick
side
siege
sight
sign
silent
silk
silly
silver
similar
simple
since
sing
siren
sister
situate
six
size
skate
sketch
ski
skill
skin
skirt
skull
slab
slam
sleep
slender
slice
slide
slight
slim
slogan
slot
slow
slush
small
smart
smile
smoke
smooth
snack
snake
snap
sniff
snow
soap
soccer
social
sock
soda
soft
solar
soldier
solid
solution
solve
someone
song
soon
sorry
sort
soul
sound
soup
source
south
space
spare
spatial
spawn
speak
special
speed
spell
spend
sphere
spice
spider
spike
spin
spirit
split
spoil
sponsor
spoon
sport
spot
spray
spread
spring
spy
square
squeeze
squirrel
stable
stadium
staff
stage
stairs
stamp
stand
start
state
stay
steak
steel
stem
step
stereo
stick
still
sting
stock
stomach
stone
stool
story
stove
strategy
street
strike
strong
struggle
student
stuff
stumble
style
subject
submit
subway
success
such
sudden
suffer
sugar
suggest
suit
summer
sun
sunny
sunset
super
supply
supreme
sure
surface
surge
surprise
surround
survey
suspect
sustain
swallow
swamp
swap
swarm
swear
sweet
swift
swim
swing
switch
sword
symbol
symptom
syrup
system
table
tackle
tag
tail
talent
talk
tank
tape
target
task
taste
tattoo
taxi
teach
team
tell
ten
tenant
tennis
tent
term
test
text
thank
that
theme
then
theory
there
they
thing
this
thought
three
thrive
throw
thumb
thunder
ticket
tide
tiger
tilt
timber
time
tiny
tip
tired
tissue
title
toast
tobacco
today
toddler
toe
together
toilet
token
tomato
tomorrow
tone
tongue
tonight
tool
tooth
top
topic
topple
torch
tornado
tortoise
toss
total
tourist
toward
tower
town
toy
track
trade
traffic
tragic
train
transfer
trap
trash
travel
tray
treat
tree
trend
trial
tribe
trick
trigger
trim
trip
trophy
trouble
truck
true
truly
trumpet
trust
truth
try
tube
tuition
tumble
tuna
tunnel
turkey
turn
turtle
twelve
twenty
twice
twin
twist
two
type
typical
ugly
umbrella
unable
unaware
uncle
uncover
under
undo
unfair
unfold
unhappy
uniform
unique
unit
universe
unknown
unlock
until
unusual
unveil
update
upgrade
uphold
upon
upper
upset
urban
urge
usage
use
used
useful
useless
usual
utility
vacant
vacuum
vague
valid
valley
valve
van
vanish
vapor
various
vast
vault
vehicle
velvet
vendor
venture
venue
verb
verify
version
very
vessel
veteran
viable
vibrant
vicious
victory
video
view
village
vintage
violin
virtual
virus
visa
visit
visual
vital
vivid
vocal
voice
void
volcano
volume
vote
voyage
wage
wagon
wait
walk
wall
walnut
want
warfare
warm
warrior
wash
wasp
waste
water
wave
way
wealth
weapon
wear
weasel
weather
web
wedding
weekend
weird
welcome
west
wet
whale
what
wheat
wheel
when
where
whip
whisper
wide
width
wife
wild
will
win
window
wine
wing
wink
winner
winter
wire
wisdom
wise
wish
witness
wolf
woman
wonder
wood
wool
word
work
world
worry
worth
wrap
wreck
wrestle
wrist
write
wrong
yard
year
yellow
you
young
youth
zebra
zero
zone
zoo`.split('\n');

},{}],19:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AppConfig = void 0;
const constants_1 = require("./constants");
const common_1 = require("@stacks/common");
class AppConfig {
    constructor(scopes = constants_1.DEFAULT_SCOPE.slice(), appDomain = (0, common_1.getGlobalObject)('location', { returnEmptyObject: true })
        ?.origin, redirectPath = '', manifestPath = '/manifest.json', coreNode = undefined, authenticatorURL = constants_1.DEFAULT_BLOCKSTACK_HOST) {
        this.appDomain = appDomain;
        this.scopes = scopes;
        this.redirectPath = redirectPath;
        this.manifestPath = manifestPath;
        this.coreNode = coreNode;
        this.authenticatorURL = authenticatorURL;
    }
    redirectURI() {
        return `${this.appDomain}${this.redirectPath}`;
    }
    manifestURI() {
        return `${this.appDomain}${this.manifestPath}`;
    }
}
exports.AppConfig = AppConfig;

},{"./constants":20,"@stacks/common":36}],20:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LOCALSTORAGE_SESSION_KEY = exports.NAME_LOOKUP_PATH = exports.DEFAULT_CORE_NODE = exports.BLOCKSTACK_APP_PRIVATE_KEY_LABEL = exports.DEFAULT_SCOPE = exports.DEFAULT_PROFILE = exports.DEFAULT_BLOCKSTACK_HOST = exports.BLOCKSTACK_STORAGE_LABEL = exports.BLOCKSTACK_HANDLER = void 0;
exports.BLOCKSTACK_HANDLER = 'blockstack';
exports.BLOCKSTACK_STORAGE_LABEL = 'blockstack';
exports.DEFAULT_BLOCKSTACK_HOST = 'https://browser.blockstack.org/auth';
exports.DEFAULT_PROFILE = {
    '@type': 'Person',
    '@context': 'http://schema.org',
};
exports.DEFAULT_SCOPE = ["store_write"];
exports.BLOCKSTACK_APP_PRIVATE_KEY_LABEL = 'blockstack-transit-private-key';
exports.DEFAULT_CORE_NODE = 'https://stacks-node-api.stacks.co';
exports.NAME_LOOKUP_PATH = '/v1/names';
exports.LOCALSTORAGE_SESSION_KEY = 'blockstack-session';

},{}],21:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAddressFromDID = exports.getDIDType = exports.makeDIDFromPublicKey = exports.makeDIDFromAddress = void 0;
const common_1 = require("@stacks/common");
function makeDIDFromAddress(address) {
    return `did:btc-addr:${address}`;
}
exports.makeDIDFromAddress = makeDIDFromAddress;
function makeDIDFromPublicKey(publicKey) {
    return `did:ecdsa-pub:${publicKey}`;
}
exports.makeDIDFromPublicKey = makeDIDFromPublicKey;
function getDIDType(decentralizedID) {
    const didParts = decentralizedID.split(':');
    if (didParts.length !== 3) {
        throw new common_1.InvalidDIDError('Decentralized IDs must have 3 parts');
    }
    if (didParts[0].toLowerCase() !== 'did') {
        throw new common_1.InvalidDIDError('Decentralized IDs must start with "did"');
    }
    return didParts[1].toLowerCase();
}
exports.getDIDType = getDIDType;
function getAddressFromDID(decentralizedID) {
    if (decentralizedID) {
        const didType = getDIDType(decentralizedID);
        if (didType === 'btc-addr') {
            return decentralizedID.split(':')[2];
        }
        else {
            return undefined;
        }
    }
    return undefined;
}
exports.getAddressFromDID = getAddressFromDID;

},{"@stacks/common":36}],22:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UserSession = exports.verifyAuthRequestAndLoadManifest = exports.isRedirectUriValid = exports.isManifestUriValid = exports.doSignaturesMatchPublicKeys = exports.doPublicKeysMatchIssuer = exports.isIssuanceDateValid = exports.isExpirationDateValid = exports.verifyAuthResponse = exports.verifyAuthRequest = exports.fetchAppManifest = exports.getAuthRequestFromURL = exports.decryptPrivateKey = exports.makeAuthResponse = exports.makeAuthRequestToken = exports.makeAuthRequest = exports.AppConfig = void 0;
var appConfig_1 = require("./appConfig");
Object.defineProperty(exports, "AppConfig", { enumerable: true, get: function () { return appConfig_1.AppConfig; } });
var messages_1 = require("./messages");
Object.defineProperty(exports, "makeAuthRequest", { enumerable: true, get: function () { return messages_1.makeAuthRequest; } });
Object.defineProperty(exports, "makeAuthRequestToken", { enumerable: true, get: function () { return messages_1.makeAuthRequestToken; } });
Object.defineProperty(exports, "makeAuthResponse", { enumerable: true, get: function () { return messages_1.makeAuthResponse; } });
Object.defineProperty(exports, "decryptPrivateKey", { enumerable: true, get: function () { return messages_1.decryptPrivateKey; } });
var provider_1 = require("./provider");
Object.defineProperty(exports, "getAuthRequestFromURL", { enumerable: true, get: function () { return provider_1.getAuthRequestFromURL; } });
Object.defineProperty(exports, "fetchAppManifest", { enumerable: true, get: function () { return provider_1.fetchAppManifest; } });
var verification_1 = require("./verification");
Object.defineProperty(exports, "verifyAuthRequest", { enumerable: true, get: function () { return verification_1.verifyAuthRequest; } });
Object.defineProperty(exports, "verifyAuthResponse", { enumerable: true, get: function () { return verification_1.verifyAuthResponse; } });
Object.defineProperty(exports, "isExpirationDateValid", { enumerable: true, get: function () { return verification_1.isExpirationDateValid; } });
Object.defineProperty(exports, "isIssuanceDateValid", { enumerable: true, get: function () { return verification_1.isIssuanceDateValid; } });
Object.defineProperty(exports, "doPublicKeysMatchIssuer", { enumerable: true, get: function () { return verification_1.doPublicKeysMatchIssuer; } });
Object.defineProperty(exports, "doSignaturesMatchPublicKeys", { enumerable: true, get: function () { return verification_1.doSignaturesMatchPublicKeys; } });
Object.defineProperty(exports, "isManifestUriValid", { enumerable: true, get: function () { return verification_1.isManifestUriValid; } });
Object.defineProperty(exports, "isRedirectUriValid", { enumerable: true, get: function () { return verification_1.isRedirectUriValid; } });
Object.defineProperty(exports, "verifyAuthRequestAndLoadManifest", { enumerable: true, get: function () { return verification_1.verifyAuthRequestAndLoadManifest; } });
__exportStar(require("./dids"), exports);
var userSession_1 = require("./userSession");
Object.defineProperty(exports, "UserSession", { enumerable: true, get: function () { return userSession_1.UserSession; } });
__exportStar(require("./constants"), exports);
__exportStar(require("./profile"), exports);
__exportStar(require("./userData"), exports);

},{"./appConfig":19,"./constants":20,"./dids":21,"./messages":23,"./profile":24,"./provider":26,"./userData":29,"./userSession":30,"./verification":31}],23:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeAuthResponse = exports.decryptPrivateKey = exports.encryptPrivateKey = exports.makeAuthRequestToken = exports.makeAuthRequest = exports.generateTransitKey = void 0;
const common_1 = require("@stacks/common");
const encryption_1 = require("@stacks/encryption");
const jsontokens_1 = require("jsontokens");
const constants_1 = require("./constants");
const dids_1 = require("./dids");
const VERSION = '1.4.0';
function generateTransitKey() {
    const transitKey = (0, encryption_1.makeECPrivateKey)();
    return transitKey;
}
exports.generateTransitKey = generateTransitKey;
exports.makeAuthRequest = makeAuthRequestToken;
function makeAuthRequestToken(transitPrivateKey, redirectURI, manifestURI, scopes = constants_1.DEFAULT_SCOPE.slice(), appDomain, expiresAt = (0, common_1.nextMonth)().getTime(), extraParams = {}) {
    const getWindowOrigin = (paramName) => {
        const location = (0, common_1.getGlobalObject)('location', {
            throwIfUnavailable: true,
            usageDesc: `makeAuthRequest([${paramName}=undefined])`,
        });
        return location?.origin;
    };
    if (!redirectURI) {
        redirectURI = `${getWindowOrigin('redirectURI')}/`;
    }
    if (!manifestURI) {
        manifestURI = `${getWindowOrigin('manifestURI')}/manifest.json`;
    }
    if (!appDomain) {
        appDomain = getWindowOrigin('appDomain');
    }
    const payload = Object.assign({}, extraParams, {
        jti: (0, common_1.makeUUID4)(),
        iat: Math.floor(new Date().getTime() / 1000),
        exp: Math.floor(expiresAt / 1000),
        iss: null,
        public_keys: [],
        domain_name: appDomain,
        manifest_uri: manifestURI,
        redirect_uri: redirectURI,
        version: VERSION,
        do_not_include_profile: true,
        supports_hub_url: true,
        scopes,
    });
    const publicKey = jsontokens_1.SECP256K1Client.derivePublicKey(transitPrivateKey);
    payload.public_keys = [publicKey];
    const address = (0, encryption_1.publicKeyToBtcAddress)(publicKey);
    payload.iss = (0, dids_1.makeDIDFromAddress)(address);
    const tokenSigner = new jsontokens_1.TokenSigner('ES256k', transitPrivateKey);
    const token = tokenSigner.sign(payload);
    return token;
}
exports.makeAuthRequestToken = makeAuthRequestToken;
async function encryptPrivateKey(publicKey, privateKey) {
    const encryptedObj = await (0, encryption_1.encryptECIES)(publicKey, (0, common_1.utf8ToBytes)(privateKey), true);
    const encryptedJSON = JSON.stringify(encryptedObj);
    return (0, common_1.bytesToHex)((0, common_1.utf8ToBytes)(encryptedJSON));
}
exports.encryptPrivateKey = encryptPrivateKey;
async function decryptPrivateKey(privateKey, hexedEncrypted) {
    const unhexedString = (0, common_1.bytesToUtf8)((0, common_1.hexToBytes)(hexedEncrypted));
    const encryptedObj = JSON.parse(unhexedString);
    const decrypted = await (0, encryption_1.decryptECIES)(privateKey, encryptedObj);
    if (typeof decrypted !== 'string') {
        throw new Error('Unable to correctly decrypt private key');
    }
    else {
        return decrypted;
    }
}
exports.decryptPrivateKey = decryptPrivateKey;
async function makeAuthResponse(privateKey, profile = {}, metadata, coreToken = null, appPrivateKey = null, expiresAt = (0, common_1.nextMonth)().getTime(), transitPublicKey = null, hubUrl = null, blockstackAPIUrl = null, associationToken = null, appPrivateKeyFromWalletSalt = null) {
    const publicKey = jsontokens_1.SECP256K1Client.derivePublicKey(privateKey);
    const address = (0, encryption_1.publicKeyToBtcAddress)(publicKey);
    let privateKeyPayload = appPrivateKey;
    let coreTokenPayload = coreToken;
    let additionalProperties = {};
    if (appPrivateKey !== undefined && appPrivateKey !== null) {
        if (transitPublicKey !== undefined && transitPublicKey !== null) {
            privateKeyPayload = await encryptPrivateKey(transitPublicKey, appPrivateKey);
            if (coreToken !== undefined && coreToken !== null) {
                coreTokenPayload = await encryptPrivateKey(transitPublicKey, coreToken);
            }
        }
        additionalProperties = {
            email: metadata?.email ? metadata.email : null,
            profile_url: metadata?.profileUrl ? metadata.profileUrl : null,
            hubUrl,
            blockstackAPIUrl,
            associationToken,
            version: VERSION,
        };
    }
    else {
    }
    const payload = Object.assign({}, {
        jti: (0, common_1.makeUUID4)(),
        iat: Math.floor(new Date().getTime() / 1000),
        exp: Math.floor(expiresAt / 1000),
        iss: (0, dids_1.makeDIDFromAddress)(address),
        private_key: privateKeyPayload,
        public_keys: [publicKey],
        appPrivateKeyFromWalletSalt,
        profile,
        core_token: coreTokenPayload,
    }, additionalProperties);
    const tokenSigner = new jsontokens_1.TokenSigner('ES256k', privateKey);
    return tokenSigner.sign(payload);
}
exports.makeAuthResponse = makeAuthResponse;

},{"./constants":20,"./dids":21,"@stacks/common":36,"@stacks/encryption":54,"jsontokens":121}],24:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.lookupProfile = void 0;
const profile_1 = require("@stacks/profile");
const network_1 = require("@stacks/network");
function lookupProfile(lookupOptions) {
    if (!lookupOptions.username) {
        return Promise.reject(new Error('No username provided'));
    }
    const defaultOptions = {
        network: new network_1.StacksMainnet(),
    };
    const options = Object.assign(defaultOptions, lookupOptions);
    const network = network_1.StacksNetwork.fromNameOrNetwork(options.network);
    let lookupPromise;
    if (options.zoneFileLookupURL) {
        const url = `${options.zoneFileLookupURL.replace(/\/$/, '')}/${options.username}`;
        lookupPromise = network.fetchFn(url).then(response => response.json());
    }
    else {
        lookupPromise = network.getNameInfo(options.username);
    }
    return lookupPromise.then((responseJSON) => {
        if (responseJSON.hasOwnProperty('zonefile') && responseJSON.hasOwnProperty('address')) {
            return (0, profile_1.resolveZoneFileToProfile)(responseJSON.zonefile, responseJSON.address, network.fetchFn);
        }
        else {
            throw new Error('Invalid zonefile lookup response: did not contain `address`' + ' or `zonefile` field');
        }
    });
}
exports.lookupProfile = lookupProfile;

},{"@stacks/network":63,"@stacks/profile":65}],25:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.protocolEchoReplyDetection = void 0;
const GLOBAL_DETECTION_CACHE_KEY = '_blockstackDidCheckEchoReply';
const ECHO_REPLY_PARAM = 'echoReply';
const AUTH_CONTINUATION_PARAM = 'authContinuation';
function getQueryStringParams(query) {
    if (!query) {
        return {};
    }
    const trimmed = /^[?#]/.test(query) ? query.slice(1) : query;
    return trimmed.split('&').reduce((params, param) => {
        const [key, value] = param.split('=');
        params[key] = value ? decodeURIComponent(value.replace(/\+/g, ' ')) : '';
        return params;
    }, {});
}
function protocolEchoReplyDetection() {
    let globalScope;
    if (typeof self !== 'undefined') {
        globalScope = self;
    }
    else if (typeof window !== 'undefined') {
        globalScope = window;
    }
    else {
        return false;
    }
    if (!globalScope.location || !globalScope.localStorage) {
        return false;
    }
    const existingDetection = globalScope[GLOBAL_DETECTION_CACHE_KEY];
    if (typeof existingDetection === 'boolean') {
        return existingDetection;
    }
    const searchParams = getQueryStringParams(globalScope.location.search);
    const echoReplyParam = searchParams[ECHO_REPLY_PARAM];
    if (echoReplyParam) {
        globalScope[GLOBAL_DETECTION_CACHE_KEY] = true;
        const echoReplyKey = `echo-reply-${echoReplyParam}`;
        globalScope.localStorage.setItem(echoReplyKey, 'success');
        globalScope.setTimeout(() => {
            const authContinuationParam = searchParams[AUTH_CONTINUATION_PARAM];
            globalScope.location.href = authContinuationParam;
        }, 10);
        return true;
    }
    return false;
}
exports.protocolEchoReplyDetection = protocolEchoReplyDetection;

},{}],26:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchAppManifest = exports.getAuthRequestFromURL = void 0;
const jsontokens_1 = require("jsontokens");
const common_1 = require("@stacks/common");
const network_1 = require("@stacks/network");
function getAuthRequestFromURL() {
    const location = (0, common_1.getGlobalObject)('location', {
        throwIfUnavailable: true,
        usageDesc: 'getAuthRequestFromURL',
    });
    const params = new URLSearchParams(location?.search);
    return params.get('authRequest')?.replaceAll(`${common_1.BLOCKSTACK_HANDLER}:`, '') ?? null;
}
exports.getAuthRequestFromURL = getAuthRequestFromURL;
async function fetchAppManifest(authRequest, fetchFn = (0, network_1.createFetchFn)()) {
    if (!authRequest) {
        throw new Error('Invalid auth request');
    }
    const payload = (0, jsontokens_1.decodeToken)(authRequest).payload;
    if (typeof payload === 'string') {
        throw new Error('Unexpected token payload type of string');
    }
    const manifestURI = payload.manifest_uri;
    try {
        const response = await fetchFn(manifestURI);
        const responseText = await response.text();
        const responseJSON = JSON.parse(responseText);
        return { ...responseJSON, manifestURI };
    }
    catch (error) {
        console.log(error);
        throw new Error('Could not fetch manifest.json');
    }
}
exports.fetchAppManifest = fetchAppManifest;

},{"@stacks/common":36,"@stacks/network":63,"jsontokens":121}],27:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SessionData = void 0;
const common_1 = require("@stacks/common");
const SESSION_VERSION = '1.0.0';
class SessionData {
    constructor(options) {
        this.version = SESSION_VERSION;
        this.userData = options.userData;
        this.transitKey = options.transitKey;
        this.etags = options.etags ? options.etags : {};
    }
    static fromJSON(json) {
        if (json.version !== SESSION_VERSION) {
            throw new common_1.InvalidStateError(`JSON data version ${json.version} not supported by SessionData`);
        }
        const options = {
            coreNode: json.coreNode,
            userData: json.userData,
            transitKey: json.transitKey,
            etags: json.etags,
        };
        return new SessionData(options);
    }
    toString() {
        return JSON.stringify(this);
    }
}
exports.SessionData = SessionData;

},{"@stacks/common":36}],28:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalStorageStore = exports.InstanceDataStore = exports.SessionDataStore = void 0;
const sessionData_1 = require("./sessionData");
const constants_1 = require("./constants");
const common_1 = require("@stacks/common");
class SessionDataStore {
    constructor(sessionOptions) {
        if (sessionOptions) {
            const newSessionData = new sessionData_1.SessionData(sessionOptions);
            this.setSessionData(newSessionData);
        }
    }
    getSessionData() {
        throw new Error('Abstract class');
    }
    setSessionData(_session) {
        throw new Error('Abstract class');
    }
    deleteSessionData() {
        throw new Error('Abstract class');
    }
}
exports.SessionDataStore = SessionDataStore;
class InstanceDataStore extends SessionDataStore {
    constructor(sessionOptions) {
        super(sessionOptions);
        if (!this.sessionData) {
            this.setSessionData(new sessionData_1.SessionData({}));
        }
    }
    getSessionData() {
        if (!this.sessionData) {
            throw new common_1.NoSessionDataError('No session data was found.');
        }
        return this.sessionData;
    }
    setSessionData(session) {
        this.sessionData = session;
        return true;
    }
    deleteSessionData() {
        this.setSessionData(new sessionData_1.SessionData({}));
        return true;
    }
}
exports.InstanceDataStore = InstanceDataStore;
class LocalStorageStore extends SessionDataStore {
    constructor(sessionOptions) {
        super(sessionOptions);
        if (sessionOptions &&
            sessionOptions.storeOptions &&
            sessionOptions.storeOptions.localStorageKey &&
            typeof sessionOptions.storeOptions.localStorageKey === 'string') {
            this.key = sessionOptions.storeOptions.localStorageKey;
        }
        else {
            this.key = constants_1.LOCALSTORAGE_SESSION_KEY;
        }
        const data = localStorage.getItem(this.key);
        if (!data) {
            const sessionData = new sessionData_1.SessionData({});
            this.setSessionData(sessionData);
        }
    }
    getSessionData() {
        const data = localStorage.getItem(this.key);
        if (!data) {
            throw new common_1.NoSessionDataError('No session data was found in localStorage');
        }
        const dataJSON = JSON.parse(data);
        return sessionData_1.SessionData.fromJSON(dataJSON);
    }
    setSessionData(session) {
        localStorage.setItem(this.key, session.toString());
        return true;
    }
    deleteSessionData() {
        localStorage.removeItem(this.key);
        this.setSessionData(new sessionData_1.SessionData({}));
        return true;
    }
}
exports.LocalStorageStore = LocalStorageStore;

},{"./constants":20,"./sessionData":27,"@stacks/common":36}],29:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

},{}],30:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UserSession = void 0;
const appConfig_1 = require("./appConfig");
const sessionStore_1 = require("./sessionStore");
const jsontokens_1 = require("jsontokens");
const verification_1 = require("./verification");
const authMessages = __importStar(require("./messages"));
const encryption_1 = require("@stacks/encryption");
const dids_1 = require("./dids");
const common_1 = require("@stacks/common");
const profile_1 = require("@stacks/profile");
const constants_1 = require("./constants");
const network_1 = require("@stacks/network");
const protocolEchoDetection_1 = require("./protocolEchoDetection");
class UserSession {
    constructor(options) {
        let runningInBrowser = true;
        if (typeof window === 'undefined' && typeof self === 'undefined') {
            runningInBrowser = false;
        }
        if (options && options.appConfig) {
            this.appConfig = options.appConfig;
        }
        else if (runningInBrowser) {
            this.appConfig = new appConfig_1.AppConfig();
        }
        else {
            throw new common_1.MissingParameterError('You need to specify options.appConfig');
        }
        if (options && options.sessionStore) {
            this.store = options.sessionStore;
        }
        else if (runningInBrowser) {
            if (options) {
                this.store = new sessionStore_1.LocalStorageStore(options.sessionOptions);
            }
            else {
                this.store = new sessionStore_1.LocalStorageStore();
            }
        }
        else if (options) {
            this.store = new sessionStore_1.InstanceDataStore(options.sessionOptions);
        }
        else {
            this.store = new sessionStore_1.InstanceDataStore();
        }
    }
    makeAuthRequestToken(transitKey, redirectURI, manifestURI, scopes, appDomain, expiresAt = (0, common_1.nextHour)().getTime(), extraParams = {}) {
        const appConfig = this.appConfig;
        if (!appConfig) {
            throw new common_1.InvalidStateError('Missing AppConfig');
        }
        transitKey = transitKey || this.generateAndStoreTransitKey();
        redirectURI = redirectURI || appConfig.redirectURI();
        manifestURI = manifestURI || appConfig.manifestURI();
        scopes = scopes || appConfig.scopes;
        appDomain = appDomain || appConfig.appDomain;
        return authMessages.makeAuthRequestToken(transitKey, redirectURI, manifestURI, scopes, appDomain, expiresAt, extraParams);
    }
    generateAndStoreTransitKey() {
        const sessionData = this.store.getSessionData();
        const transitKey = authMessages.generateTransitKey();
        sessionData.transitKey = transitKey;
        this.store.setSessionData(sessionData);
        return transitKey;
    }
    getAuthResponseToken() {
        const search = (0, common_1.getGlobalObject)('location', {
            throwIfUnavailable: true,
            usageDesc: 'getAuthResponseToken',
        })?.search;
        const params = new URLSearchParams(search);
        return params.get('authResponse') ?? '';
    }
    isSignInPending() {
        try {
            const isProtocolEcho = (0, protocolEchoDetection_1.protocolEchoReplyDetection)();
            if (isProtocolEcho) {
                common_1.Logger.info('protocolEchoReply detected from isSignInPending call, the page is about to redirect.');
                return true;
            }
        }
        catch (error) {
            common_1.Logger.error(`Error checking for protocol echo reply isSignInPending: ${error}`);
        }
        return !!this.getAuthResponseToken();
    }
    isUserSignedIn() {
        return !!this.store.getSessionData().userData;
    }
    async handlePendingSignIn(authResponseToken = this.getAuthResponseToken(), fetchFn = (0, network_1.createFetchFn)()) {
        const sessionData = this.store.getSessionData();
        if (sessionData.userData) {
            throw new common_1.LoginFailedError('Existing user session found.');
        }
        const transitKey = this.store.getSessionData().transitKey;
        let coreNode = this.appConfig && this.appConfig.coreNode;
        if (!coreNode) {
            const network = new network_1.StacksMainnet();
            coreNode = network.bnsLookupUrl;
        }
        const tokenPayload = (0, jsontokens_1.decodeToken)(authResponseToken).payload;
        if (typeof tokenPayload === 'string') {
            throw new Error('Unexpected token payload type of string');
        }
        const isValid = await (0, verification_1.verifyAuthResponse)(authResponseToken);
        if (!isValid) {
            throw new common_1.LoginFailedError('Invalid authentication response.');
        }
        let appPrivateKey = tokenPayload.private_key;
        let coreSessionToken = tokenPayload.core_token;
        if ((0, common_1.isLaterVersion)(tokenPayload.version, '1.1.0')) {
            if (transitKey !== undefined && transitKey != null) {
                if (tokenPayload.private_key !== undefined && tokenPayload.private_key !== null) {
                    try {
                        appPrivateKey = (await authMessages.decryptPrivateKey(transitKey, tokenPayload.private_key));
                    }
                    catch (e) {
                        common_1.Logger.warn('Failed decryption of appPrivateKey, will try to use as given');
                        if (!(0, encryption_1.isValidPrivateKey)(tokenPayload.private_key)) {
                            throw new common_1.LoginFailedError('Failed decrypting appPrivateKey. Usually means' +
                                ' that the transit key has changed during login.');
                        }
                    }
                }
                if (coreSessionToken !== undefined && coreSessionToken !== null) {
                    try {
                        coreSessionToken = (await authMessages.decryptPrivateKey(transitKey, coreSessionToken));
                    }
                    catch (e) {
                        common_1.Logger.info('Failed decryption of coreSessionToken, will try to use as given');
                    }
                }
            }
            else {
                throw new common_1.LoginFailedError('Authenticating with protocol > 1.1.0 requires transit' + ' key, and none found.');
            }
        }
        let hubUrl = common_1.BLOCKSTACK_DEFAULT_GAIA_HUB_URL;
        let gaiaAssociationToken;
        if ((0, common_1.isLaterVersion)(tokenPayload.version, '1.2.0') &&
            tokenPayload.hubUrl !== null &&
            tokenPayload.hubUrl !== undefined) {
            hubUrl = tokenPayload.hubUrl;
        }
        if ((0, common_1.isLaterVersion)(tokenPayload.version, '1.3.0') &&
            tokenPayload.associationToken !== null &&
            tokenPayload.associationToken !== undefined) {
            gaiaAssociationToken = tokenPayload.associationToken;
        }
        const userData = {
            profile: tokenPayload.profile,
            email: tokenPayload.email,
            decentralizedID: tokenPayload.iss,
            identityAddress: (0, dids_1.getAddressFromDID)(tokenPayload.iss),
            appPrivateKey,
            coreSessionToken,
            authResponseToken,
            hubUrl,
            appPrivateKeyFromWalletSalt: tokenPayload.appPrivateKeyFromWalletSalt,
            coreNode: tokenPayload.blockstackAPIUrl,
            gaiaAssociationToken,
        };
        const profileURL = tokenPayload.profile_url;
        if (!userData.profile && profileURL) {
            const response = await fetchFn(profileURL);
            if (!response.ok) {
                userData.profile = Object.assign({}, constants_1.DEFAULT_PROFILE);
            }
            else {
                const responseText = await response.text();
                const wrappedProfile = JSON.parse(responseText);
                userData.profile = (0, profile_1.extractProfile)(wrappedProfile[0].token);
            }
        }
        else {
            userData.profile = tokenPayload.profile;
        }
        sessionData.userData = userData;
        this.store.setSessionData(sessionData);
        return userData;
    }
    loadUserData() {
        const userData = this.store.getSessionData().userData;
        if (!userData) {
            throw new common_1.InvalidStateError('No user data found. Did the user sign in?');
        }
        return userData;
    }
    encryptContent(content, options) {
        const opts = Object.assign({}, options);
        if (!opts.privateKey) {
            opts.privateKey = this.loadUserData().appPrivateKey;
        }
        return (0, encryption_1.encryptContent)(content, opts);
    }
    decryptContent(content, options) {
        const opts = Object.assign({}, options);
        if (!opts.privateKey) {
            opts.privateKey = this.loadUserData().appPrivateKey;
        }
        return (0, encryption_1.decryptContent)(content, opts);
    }
    signUserOut(redirectURL) {
        this.store.deleteSessionData();
        if (redirectURL) {
            if (typeof location !== 'undefined' && location.href) {
                location.href = redirectURL;
            }
        }
    }
}
exports.UserSession = UserSession;
UserSession.prototype.makeAuthRequest = UserSession.prototype.makeAuthRequestToken;

},{"./appConfig":19,"./constants":20,"./dids":21,"./messages":23,"./protocolEchoDetection":25,"./sessionStore":28,"./verification":31,"@stacks/common":36,"@stacks/encryption":54,"@stacks/network":63,"@stacks/profile":65,"jsontokens":121}],31:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyAuthResponse = exports.verifyAuthRequestAndLoadManifest = exports.verifyAuthRequest = exports.isRedirectUriValid = exports.isManifestUriValid = exports.isExpirationDateValid = exports.isIssuanceDateValid = exports.doPublicKeysMatchIssuer = exports.doSignaturesMatchPublicKeys = void 0;
const common_1 = require("@stacks/common");
const encryption_1 = require("@stacks/encryption");
const jsontokens_1 = require("jsontokens");
const dids_1 = require("./dids");
const provider_1 = require("./provider");
function doSignaturesMatchPublicKeys(token) {
    const payload = (0, jsontokens_1.decodeToken)(token).payload;
    if (typeof payload === 'string') {
        throw new Error('Unexpected token payload type of string');
    }
    const publicKeys = payload.public_keys;
    if (publicKeys.length === 1) {
        const publicKey = publicKeys[0];
        try {
            const tokenVerifier = new jsontokens_1.TokenVerifier('ES256k', publicKey);
            return tokenVerifier.verify(token);
        }
        catch (e) {
            return false;
        }
    }
    else {
        throw new Error('Multiple public keys are not supported');
    }
}
exports.doSignaturesMatchPublicKeys = doSignaturesMatchPublicKeys;
function doPublicKeysMatchIssuer(token) {
    const payload = (0, jsontokens_1.decodeToken)(token).payload;
    if (typeof payload === 'string') {
        throw new Error('Unexpected token payload type of string');
    }
    const publicKeys = payload.public_keys;
    const addressFromIssuer = (0, dids_1.getAddressFromDID)(payload.iss);
    if (publicKeys.length === 1) {
        const addressFromPublicKeys = (0, encryption_1.publicKeyToBtcAddress)(publicKeys[0]);
        if (addressFromPublicKeys === addressFromIssuer) {
            return true;
        }
    }
    else {
        throw new Error('Multiple public keys are not supported');
    }
    return false;
}
exports.doPublicKeysMatchIssuer = doPublicKeysMatchIssuer;
function isIssuanceDateValid(token) {
    const payload = (0, jsontokens_1.decodeToken)(token).payload;
    if (typeof payload === 'string') {
        throw new Error('Unexpected token payload type of string');
    }
    if (payload.iat) {
        if (typeof payload.iat !== 'number') {
            return false;
        }
        const issuedAt = new Date(payload.iat * 1000);
        if (new Date().getTime() < issuedAt.getTime()) {
            return false;
        }
        else {
            return true;
        }
    }
    else {
        return true;
    }
}
exports.isIssuanceDateValid = isIssuanceDateValid;
function isExpirationDateValid(token) {
    const payload = (0, jsontokens_1.decodeToken)(token).payload;
    if (typeof payload === 'string') {
        throw new Error('Unexpected token payload type of string');
    }
    if (payload.exp) {
        if (typeof payload.exp !== 'number') {
            return false;
        }
        const expiresAt = new Date(payload.exp * 1000);
        if (new Date().getTime() > expiresAt.getTime()) {
            return false;
        }
        else {
            return true;
        }
    }
    else {
        return true;
    }
}
exports.isExpirationDateValid = isExpirationDateValid;
function isManifestUriValid(token) {
    const payload = (0, jsontokens_1.decodeToken)(token).payload;
    if (typeof payload === 'string') {
        throw new Error('Unexpected token payload type of string');
    }
    return (0, common_1.isSameOriginAbsoluteUrl)(payload.domain_name, payload.manifest_uri);
}
exports.isManifestUriValid = isManifestUriValid;
function isRedirectUriValid(token) {
    const payload = (0, jsontokens_1.decodeToken)(token).payload;
    if (typeof payload === 'string') {
        throw new Error('Unexpected token payload type of string');
    }
    return (0, common_1.isSameOriginAbsoluteUrl)(payload.domain_name, payload.redirect_uri);
}
exports.isRedirectUriValid = isRedirectUriValid;
async function verifyAuthRequest(token) {
    if ((0, jsontokens_1.decodeToken)(token).header.alg === 'none') {
        throw new Error('Token must be signed in order to be verified');
    }
    const values = await Promise.all([
        isExpirationDateValid(token),
        isIssuanceDateValid(token),
        doSignaturesMatchPublicKeys(token),
        doPublicKeysMatchIssuer(token),
        isManifestUriValid(token),
        isRedirectUriValid(token),
    ]);
    return values.every(val => val);
}
exports.verifyAuthRequest = verifyAuthRequest;
async function verifyAuthRequestAndLoadManifest(token) {
    const valid = await verifyAuthRequest(token);
    if (!valid) {
        throw new Error('Token is an invalid auth request');
    }
    return (0, provider_1.fetchAppManifest)(token);
}
exports.verifyAuthRequestAndLoadManifest = verifyAuthRequestAndLoadManifest;
async function verifyAuthResponse(token) {
    const conditions = await Promise.all([
        isExpirationDateValid(token),
        isIssuanceDateValid(token),
        doSignaturesMatchPublicKeys(token),
        doPublicKeysMatchIssuer(token),
    ]);
    return conditions.every(val => val);
}
exports.verifyAuthResponse = verifyAuthResponse;

},{"./dids":21,"./provider":26,"@stacks/common":36,"@stacks/encryption":54,"jsontokens":121}],32:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeUInt32LE = exports.readUInt32LE = exports.writeUInt32BE = exports.readUInt32BE = exports.writeUInt16LE = exports.readUInt16LE = exports.writeUInt8 = exports.readUInt8 = exports.writeUInt16BE = exports.readUInt16BE = exports.alloc = exports.equals = void 0;
function equals(a, b) {
    if (a.byteLength !== b.byteLength)
        return false;
    for (let i = 0; i < a.byteLength; i++) {
        if (a[i] !== b[i])
            return false;
    }
    return true;
}
exports.equals = equals;
function alloc(length, value) {
    const a = new Uint8Array(length);
    for (let i = 0; i < length; i++) {
        a[i] = value;
    }
    return a;
}
exports.alloc = alloc;
function readUInt16BE(source, offset) {
    return ((source[offset + 0] << 8) | source[offset + 1]) >>> 0;
}
exports.readUInt16BE = readUInt16BE;
function writeUInt16BE(source, value, offset) {
    source[offset + 0] = value >>> 8;
    source[offset + 1] = value >>> 0;
}
exports.writeUInt16BE = writeUInt16BE;
function readUInt8(source, offset) {
    return source[offset];
}
exports.readUInt8 = readUInt8;
function writeUInt8(destination, value, offset) {
    destination[offset] = value;
}
exports.writeUInt8 = writeUInt8;
function readUInt16LE(source, offset) {
    return ((source[offset + 0] << 0) >>> 0) | ((source[offset + 1] << 8) >>> 0);
}
exports.readUInt16LE = readUInt16LE;
function writeUInt16LE(destination, value, offset) {
    destination[offset + 0] = value & 255;
    value >>>= 8;
    destination[offset + 1] = value & 255;
}
exports.writeUInt16LE = writeUInt16LE;
function readUInt32BE(source, offset) {
    return (source[offset] * 2 ** 24 +
        source[offset + 1] * 2 ** 16 +
        source[offset + 2] * 2 ** 8 +
        source[offset + 3]);
}
exports.readUInt32BE = readUInt32BE;
function writeUInt32BE(destination, value, offset) {
    destination[offset + 3] = value;
    value >>>= 8;
    destination[offset + 2] = value;
    value >>>= 8;
    destination[offset + 1] = value;
    value >>>= 8;
    destination[offset] = value;
}
exports.writeUInt32BE = writeUInt32BE;
function readUInt32LE(source, offset) {
    return (((source[offset + 0] << 0) >>> 0) |
        ((source[offset + 1] << 8) >>> 0) |
        ((source[offset + 2] << 16) >>> 0) |
        ((source[offset + 3] << 24) >>> 0));
}
exports.readUInt32LE = readUInt32LE;
function writeUInt32LE(destination, value, offset) {
    destination[offset + 0] = value & 255;
    value >>>= 8;
    destination[offset + 1] = value & 255;
    value >>>= 8;
    destination[offset + 2] = value & 255;
    value >>>= 8;
    destination[offset + 3] = value & 255;
}
exports.writeUInt32LE = writeUInt32LE;

},{}],33:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.config = void 0;
const config = {
    network: {
        layer1: 'placeholder',
    },
    logLevel: 'debug',
};
exports.config = config;

},{}],34:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BLOCKSTACK_DEFAULT_GAIA_HUB_URL = exports.PRIVATE_KEY_UNCOMPRESSED_LENGTH = exports.PRIVATE_KEY_COMPRESSED_LENGTH = exports.TransactionVersion = exports.ChainID = void 0;
var ChainID;
(function (ChainID) {
    ChainID[ChainID["Testnet"] = 2147483648] = "Testnet";
    ChainID[ChainID["Mainnet"] = 1] = "Mainnet";
})(ChainID = exports.ChainID || (exports.ChainID = {}));
var TransactionVersion;
(function (TransactionVersion) {
    TransactionVersion[TransactionVersion["Mainnet"] = 0] = "Mainnet";
    TransactionVersion[TransactionVersion["Testnet"] = 128] = "Testnet";
})(TransactionVersion = exports.TransactionVersion || (exports.TransactionVersion = {}));
exports.PRIVATE_KEY_COMPRESSED_LENGTH = 33;
exports.PRIVATE_KEY_UNCOMPRESSED_LENGTH = 32;
exports.BLOCKSTACK_DEFAULT_GAIA_HUB_URL = 'https://hub.blockstack.org';

},{}],35:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PreconditionFailedError = exports.PayloadTooLargeError = exports.ValidationError = exports.BadPathError = exports.NotEnoughProofError = exports.ConflictError = exports.DoesNotExist = exports.GaiaHubError = exports.NoSessionDataError = exports.InvalidStateError = exports.FailedDecryptionError = exports.SignatureVerificationError = exports.LoginFailedError = exports.InvalidAmountError = exports.NotEnoughFundsError = exports.InvalidDIDError = exports.RemoteServiceError = exports.MissingParameterError = exports.InvalidParameterError = exports.BlockstackError = exports.ERROR_CODES = void 0;
exports.ERROR_CODES = {
    MISSING_PARAMETER: 'missing_parameter',
    REMOTE_SERVICE_ERROR: 'remote_service_error',
    INVALID_STATE: 'invalid_state',
    NO_SESSION_DATA: 'no_session_data',
    DOES_NOT_EXIST: 'does_not_exist',
    FAILED_DECRYPTION_ERROR: 'failed_decryption_error',
    INVALID_DID_ERROR: 'invalid_did_error',
    NOT_ENOUGH_FUNDS_ERROR: 'not_enough_error',
    INVALID_AMOUNT_ERROR: 'invalid_amount_error',
    LOGIN_FAILED_ERROR: 'login_failed',
    SIGNATURE_VERIFICATION_ERROR: 'signature_verification_failure',
    CONFLICT_ERROR: 'conflict_error',
    NOT_ENOUGH_PROOF_ERROR: 'not_enough_proof_error',
    BAD_PATH_ERROR: 'bad_path_error',
    VALIDATION_ERROR: 'validation_error',
    PAYLOAD_TOO_LARGE_ERROR: 'payload_too_large_error',
    PRECONDITION_FAILED_ERROR: 'precondition_failed_error',
    UNKNOWN: 'unknown',
};
Object.freeze(exports.ERROR_CODES);
class BlockstackError extends Error {
    constructor(error) {
        super();
        let message = error.message;
        let bugDetails = `Error Code: ${error.code}`;
        let stack = this.stack;
        if (!stack) {
            try {
                throw new Error();
            }
            catch (e) {
                stack = e.stack;
            }
        }
        else {
            bugDetails += `Stack Trace:\n${stack}`;
        }
        message += `\nIf you believe this exception is caused by a bug in stacks.js,
      please file a bug report: https://github.com/blockstack/stacks.js/issues\n\n${bugDetails}`;
        this.message = message;
        this.code = error.code;
        this.parameter = error.parameter ? error.parameter : undefined;
    }
    toString() {
        return `${super.toString()}
    code: ${this.code} param: ${this.parameter ? this.parameter : 'n/a'}`;
    }
}
exports.BlockstackError = BlockstackError;
class InvalidParameterError extends BlockstackError {
    constructor(parameter, message = '') {
        super({ code: exports.ERROR_CODES.MISSING_PARAMETER, message, parameter });
        this.name = 'MissingParametersError';
    }
}
exports.InvalidParameterError = InvalidParameterError;
class MissingParameterError extends BlockstackError {
    constructor(parameter, message = '') {
        super({ code: exports.ERROR_CODES.MISSING_PARAMETER, message, parameter });
        this.name = 'MissingParametersError';
    }
}
exports.MissingParameterError = MissingParameterError;
class RemoteServiceError extends BlockstackError {
    constructor(response, message = '') {
        super({ code: exports.ERROR_CODES.REMOTE_SERVICE_ERROR, message });
        this.response = response;
    }
}
exports.RemoteServiceError = RemoteServiceError;
class InvalidDIDError extends BlockstackError {
    constructor(message = '') {
        super({ code: exports.ERROR_CODES.INVALID_DID_ERROR, message });
        this.name = 'InvalidDIDError';
    }
}
exports.InvalidDIDError = InvalidDIDError;
class NotEnoughFundsError extends BlockstackError {
    constructor(leftToFund) {
        const message = `Not enough UTXOs to fund. Left to fund: ${leftToFund}`;
        super({ code: exports.ERROR_CODES.NOT_ENOUGH_FUNDS_ERROR, message });
        this.leftToFund = leftToFund;
        this.name = 'NotEnoughFundsError';
        this.message = message;
    }
}
exports.NotEnoughFundsError = NotEnoughFundsError;
class InvalidAmountError extends BlockstackError {
    constructor(fees, specifiedAmount) {
        const message = `Not enough coin to fund fees transaction fees. Fees would be ${fees},` +
            ` specified spend is  ${specifiedAmount}`;
        super({ code: exports.ERROR_CODES.INVALID_AMOUNT_ERROR, message });
        this.specifiedAmount = specifiedAmount;
        this.fees = fees;
        this.name = 'InvalidAmountError';
        this.message = message;
    }
}
exports.InvalidAmountError = InvalidAmountError;
class LoginFailedError extends BlockstackError {
    constructor(reason) {
        const message = `Failed to login: ${reason}`;
        super({ code: exports.ERROR_CODES.LOGIN_FAILED_ERROR, message });
        this.message = message;
        this.name = 'LoginFailedError';
    }
}
exports.LoginFailedError = LoginFailedError;
class SignatureVerificationError extends BlockstackError {
    constructor(reason) {
        const message = `Failed to verify signature: ${reason}`;
        super({ code: exports.ERROR_CODES.SIGNATURE_VERIFICATION_ERROR, message });
        this.message = message;
        this.name = 'SignatureVerificationError';
    }
}
exports.SignatureVerificationError = SignatureVerificationError;
class FailedDecryptionError extends BlockstackError {
    constructor(message = 'Unable to decrypt cipher object.') {
        super({ code: exports.ERROR_CODES.FAILED_DECRYPTION_ERROR, message });
        this.message = message;
        this.name = 'FailedDecryptionError';
    }
}
exports.FailedDecryptionError = FailedDecryptionError;
class InvalidStateError extends BlockstackError {
    constructor(message) {
        super({ code: exports.ERROR_CODES.INVALID_STATE, message });
        this.message = message;
        this.name = 'InvalidStateError';
    }
}
exports.InvalidStateError = InvalidStateError;
class NoSessionDataError extends BlockstackError {
    constructor(message) {
        super({ code: exports.ERROR_CODES.INVALID_STATE, message });
        this.message = message;
        this.name = 'NoSessionDataError';
    }
}
exports.NoSessionDataError = NoSessionDataError;
class GaiaHubError extends BlockstackError {
    constructor(error, response) {
        super(error);
        if (response) {
            this.hubError = {
                statusCode: response.status,
                statusText: response.statusText,
            };
            if (typeof response.body === 'string') {
                this.hubError.message = response.body;
            }
            else if (typeof response.body === 'object') {
                Object.assign(this.hubError, response.body);
            }
        }
    }
}
exports.GaiaHubError = GaiaHubError;
class DoesNotExist extends GaiaHubError {
    constructor(message, response) {
        super({ message, code: exports.ERROR_CODES.DOES_NOT_EXIST }, response);
        this.name = 'DoesNotExist';
    }
}
exports.DoesNotExist = DoesNotExist;
class ConflictError extends GaiaHubError {
    constructor(message, response) {
        super({ message, code: exports.ERROR_CODES.CONFLICT_ERROR }, response);
        this.name = 'ConflictError';
    }
}
exports.ConflictError = ConflictError;
class NotEnoughProofError extends GaiaHubError {
    constructor(message, response) {
        super({ message, code: exports.ERROR_CODES.NOT_ENOUGH_PROOF_ERROR }, response);
        this.name = 'NotEnoughProofError';
    }
}
exports.NotEnoughProofError = NotEnoughProofError;
class BadPathError extends GaiaHubError {
    constructor(message, response) {
        super({ message, code: exports.ERROR_CODES.BAD_PATH_ERROR }, response);
        this.name = 'BadPathError';
    }
}
exports.BadPathError = BadPathError;
class ValidationError extends GaiaHubError {
    constructor(message, response) {
        super({ message, code: exports.ERROR_CODES.VALIDATION_ERROR }, response);
        this.name = 'ValidationError';
    }
}
exports.ValidationError = ValidationError;
class PayloadTooLargeError extends GaiaHubError {
    constructor(message, response, maxUploadByteSize) {
        super({ message, code: exports.ERROR_CODES.PAYLOAD_TOO_LARGE_ERROR }, response);
        this.name = 'PayloadTooLargeError';
        this.maxUploadByteSize = maxUploadByteSize;
    }
}
exports.PayloadTooLargeError = PayloadTooLargeError;
class PreconditionFailedError extends GaiaHubError {
    constructor(message, response) {
        super({ message, code: exports.ERROR_CODES.PRECONDITION_FAILED_ERROR }, response);
        this.name = 'PreconditionFailedError';
    }
}
exports.PreconditionFailedError = PreconditionFailedError;

},{}],36:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./config"), exports);
__exportStar(require("./errors"), exports);
__exportStar(require("./logger"), exports);
__exportStar(require("./utils"), exports);
__exportStar(require("./constants"), exports);
__exportStar(require("./signatures"), exports);
__exportStar(require("./keys"), exports);
__exportStar(require("./buffer"), exports);

},{"./buffer":32,"./config":33,"./constants":34,"./errors":35,"./keys":37,"./logger":38,"./signatures":39,"./utils":40}],37:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.privateKeyToBytes = void 0;
const utils_1 = require("./utils");
function privateKeyToBytes(privateKey) {
    const privateKeyBuffer = typeof privateKey === 'string' ? (0, utils_1.hexToBytes)(privateKey) : privateKey;
    if (privateKeyBuffer.length != 32 && privateKeyBuffer.length != 33) {
        throw new Error(`Improperly formatted private-key. Private-key byte length should be 32 or 33. Length provided: ${privateKeyBuffer.length}`);
    }
    if (privateKeyBuffer.length == 33 && privateKeyBuffer[32] !== 1) {
        throw new Error('Improperly formatted private-key. 33 bytes indicate compressed key, but the last byte must be == 01');
    }
    return privateKeyBuffer;
}
exports.privateKeyToBytes = privateKeyToBytes;

},{"./utils":40}],38:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Logger = void 0;
const config_1 = require("./config");
const levels = ['debug', 'info', 'warn', 'error', 'none'];
const levelToInt = {};
const intToLevel = {};
for (let index = 0; index < levels.length; index++) {
    const level = levels[index];
    levelToInt[level] = index;
    intToLevel[index] = level;
}
class Logger {
    static error(message) {
        if (!this.shouldLog('error'))
            return;
        console.error(this.logMessage('error', message));
    }
    static warn(message) {
        if (!this.shouldLog('warn'))
            return;
        console.warn(this.logMessage('warn', message));
    }
    static info(message) {
        if (!this.shouldLog('info'))
            return;
        console.log(this.logMessage('info', message));
    }
    static debug(message) {
        if (!this.shouldLog('debug'))
            return;
        console.log(this.logMessage('debug', message));
    }
    static logMessage(level, message) {
        return `[${level.toUpperCase()}] ${message}`;
    }
    static shouldLog(level) {
        const currentLevel = levelToInt[config_1.config.logLevel];
        return currentLevel <= levelToInt[level];
    }
}
exports.Logger = Logger;

},{"./config":33}],39:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.signatureRsvToVrs = exports.signatureVrsToRsv = exports.parseRecoverableSignatureVrs = void 0;
const utils_1 = require("./utils");
const COORDINATE_BYTES = 32;
function parseRecoverableSignatureVrs(signature) {
    if (signature.length < COORDINATE_BYTES * 2 * 2 + 1) {
        throw new Error('Invalid signature');
    }
    const recoveryIdHex = signature.slice(0, 2);
    const r = signature.slice(2, 2 + COORDINATE_BYTES * 2);
    const s = signature.slice(2 + COORDINATE_BYTES * 2);
    return {
        recoveryId: (0, utils_1.hexToInt)(recoveryIdHex),
        r,
        s,
    };
}
exports.parseRecoverableSignatureVrs = parseRecoverableSignatureVrs;
function signatureVrsToRsv(signature) {
    return signature.slice(2) + signature.slice(0, 2);
}
exports.signatureVrsToRsv = signatureVrsToRsv;
function signatureRsvToVrs(signature) {
    return signature.slice(-2) + signature.slice(0, -2);
}
exports.signatureRsvToVrs = signatureRsvToVrs;

},{"./utils":40}],40:[function(require,module,exports){
(function (global){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isInstance = exports.concatArray = exports.concatBytes = exports.toBytes = exports.octetsToBytes = exports.bytesToAscii = exports.asciiToBytes = exports.bytesToUtf8 = exports.utf8ToBytes = exports.hexToBytes = exports.bytesToHex = exports.fromTwos = exports.toTwos = exports.bigIntToBytes = exports.hexToInt = exports.intToHex = exports.hexToBigInt = exports.with0x = exports.intToBigInt = exports.intToBytes = exports.getGlobalObjects = exports.getGlobalObject = exports.getGlobalScope = exports.isSameOriginAbsoluteUrl = exports.makeUUID4 = exports.isLaterVersion = exports.updateQueryStringParameter = exports.getBase64OutputLength = exports.getAesCbcOutputLength = exports.megabytesToBytes = exports.nextHour = exports.nextMonth = exports.nextYear = exports.BLOCKSTACK_HANDLER = void 0;
const logger_1 = require("./logger");
exports.BLOCKSTACK_HANDLER = 'blockstack';
function nextYear() {
    return new Date(new Date().setFullYear(new Date().getFullYear() + 1));
}
exports.nextYear = nextYear;
function nextMonth() {
    return new Date(new Date().setMonth(new Date().getMonth() + 1));
}
exports.nextMonth = nextMonth;
function nextHour() {
    return new Date(new Date().setHours(new Date().getHours() + 1));
}
exports.nextHour = nextHour;
function megabytesToBytes(megabytes) {
    if (!Number.isFinite(megabytes)) {
        return 0;
    }
    return Math.floor(megabytes * 1024 * 1024);
}
exports.megabytesToBytes = megabytesToBytes;
function getAesCbcOutputLength(inputByteLength) {
    const cipherTextLength = (Math.floor(inputByteLength / 16) + 1) * 16;
    return cipherTextLength;
}
exports.getAesCbcOutputLength = getAesCbcOutputLength;
function getBase64OutputLength(inputByteLength) {
    const encodedLength = Math.ceil(inputByteLength / 3) * 4;
    return encodedLength;
}
exports.getBase64OutputLength = getBase64OutputLength;
function updateQueryStringParameter(uri, key, value) {
    const re = new RegExp(`([?&])${key}=.*?(&|$)`, 'i');
    const separator = uri.indexOf('?') !== -1 ? '&' : '?';
    if (uri.match(re)) {
        return uri.replace(re, `$1${key}=${value}$2`);
    }
    else {
        return `${uri}${separator}${key}=${value}`;
    }
}
exports.updateQueryStringParameter = updateQueryStringParameter;
function isLaterVersion(v1, v2) {
    if (v1 === undefined || v1 === '') {
        v1 = '0.0.0';
    }
    if (v2 === undefined || v1 === '') {
        v2 = '0.0.0';
    }
    const v1tuple = v1.split('.').map(x => parseInt(x, 10));
    const v2tuple = v2.split('.').map(x => parseInt(x, 10));
    for (let index = 0; index < v2.length; index++) {
        if (index >= v1.length) {
            v2tuple.push(0);
        }
        if (v1tuple[index] < v2tuple[index]) {
            return false;
        }
    }
    return true;
}
exports.isLaterVersion = isLaterVersion;
function makeUUID4() {
    let d = new Date().getTime();
    if (typeof performance !== 'undefined' && typeof performance.now === 'function') {
        d += performance.now();
    }
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
        const r = (d + Math.random() * 16) % 16 | 0;
        d = Math.floor(d / 16);
        return (c === 'x' ? r : (r & 0x3) | 0x8).toString(16);
    });
}
exports.makeUUID4 = makeUUID4;
function isSameOriginAbsoluteUrl(uri1, uri2) {
    try {
        const parsedUri1 = new URL(uri1);
        const parsedUri2 = new URL(uri2);
        const port1 = parseInt(parsedUri1.port || '0', 10) | 0 || (parsedUri1.protocol === 'https:' ? 443 : 80);
        const port2 = parseInt(parsedUri2.port || '0', 10) | 0 || (parsedUri2.protocol === 'https:' ? 443 : 80);
        const match = {
            scheme: parsedUri1.protocol === parsedUri2.protocol,
            hostname: parsedUri1.hostname === parsedUri2.hostname,
            port: port1 === port2,
            absolute: (uri1.includes('http://') || uri1.includes('https://')) &&
                (uri2.includes('http://') || uri2.includes('https://')),
        };
        return match.scheme && match.hostname && match.port && match.absolute;
    }
    catch (error) {
        console.log(error);
        console.log('Parsing error in same URL origin check');
        return false;
    }
}
exports.isSameOriginAbsoluteUrl = isSameOriginAbsoluteUrl;
function getGlobalScope() {
    if (typeof self !== 'undefined') {
        return self;
    }
    if (typeof window !== 'undefined') {
        return window;
    }
    if (typeof global !== 'undefined') {
        return global;
    }
    throw new Error('Unexpected runtime environment - no supported global scope (`window`, `self`, `global`) available');
}
exports.getGlobalScope = getGlobalScope;
function getAPIUsageErrorMessage(scopeObject, apiName, usageDesc) {
    if (usageDesc) {
        return `Use of '${usageDesc}' requires \`${apiName}\` which is unavailable on the '${scopeObject}' object within the currently executing environment.`;
    }
    else {
        return `\`${apiName}\` is unavailable on the '${scopeObject}' object within the currently executing environment.`;
    }
}
function getGlobalObject(name, { throwIfUnavailable, usageDesc, returnEmptyObject } = {}) {
    let globalScope = undefined;
    try {
        globalScope = getGlobalScope();
        if (globalScope) {
            const obj = globalScope[name];
            if (obj) {
                return obj;
            }
        }
    }
    catch (error) {
        logger_1.Logger.error(`Error getting object '${name}' from global scope '${globalScope}': ${error}`);
    }
    if (throwIfUnavailable) {
        const errMsg = getAPIUsageErrorMessage(globalScope, name.toString(), usageDesc);
        logger_1.Logger.error(errMsg);
        throw new Error(errMsg);
    }
    if (returnEmptyObject) {
        return {};
    }
    return undefined;
}
exports.getGlobalObject = getGlobalObject;
function getGlobalObjects(names, { throwIfUnavailable, usageDesc, returnEmptyObject } = {}) {
    let globalScope;
    try {
        globalScope = getGlobalScope();
    }
    catch (error) {
        logger_1.Logger.error(`Error getting global scope: ${error}`);
        if (throwIfUnavailable) {
            const errMsg = getAPIUsageErrorMessage(globalScope, names[0].toString(), usageDesc);
            logger_1.Logger.error(errMsg);
            throw errMsg;
        }
        else if (returnEmptyObject) {
            globalScope = {};
        }
    }
    const result = {};
    for (let i = 0; i < names.length; i++) {
        const name = names[i];
        try {
            if (globalScope) {
                const obj = globalScope[name];
                if (obj) {
                    result[name] = obj;
                }
                else if (throwIfUnavailable) {
                    const errMsg = getAPIUsageErrorMessage(globalScope, name.toString(), usageDesc);
                    logger_1.Logger.error(errMsg);
                    throw new Error(errMsg);
                }
                else if (returnEmptyObject) {
                    result[name] = {};
                }
            }
        }
        catch (error) {
            if (throwIfUnavailable) {
                const errMsg = getAPIUsageErrorMessage(globalScope, name.toString(), usageDesc);
                logger_1.Logger.error(errMsg);
                throw new Error(errMsg);
            }
        }
    }
    return result;
}
exports.getGlobalObjects = getGlobalObjects;
function intToBytes(value, signed, byteLength) {
    return bigIntToBytes(intToBigInt(value, signed), byteLength);
}
exports.intToBytes = intToBytes;
function intToBigInt(value, signed) {
    let parsedValue = value;
    if (typeof parsedValue === 'number') {
        if (!Number.isInteger(parsedValue)) {
            throw new RangeError(`Invalid value. Values of type 'number' must be an integer.`);
        }
        return BigInt(parsedValue);
    }
    if (typeof parsedValue === 'string') {
        if (parsedValue.toLowerCase().startsWith('0x')) {
            let hex = parsedValue.slice(2);
            hex = hex.padStart(hex.length + (hex.length % 2), '0');
            parsedValue = hexToBytes(hex);
        }
        else {
            try {
                return BigInt(parsedValue);
            }
            catch (error) {
                if (error instanceof SyntaxError) {
                    throw new RangeError(`Invalid value. String integer '${parsedValue}' is not finite.`);
                }
            }
        }
    }
    if (typeof parsedValue === 'bigint') {
        return parsedValue;
    }
    if (parsedValue instanceof Uint8Array) {
        if (signed) {
            const bn = fromTwos(BigInt(`0x${bytesToHex(parsedValue)}`), BigInt(parsedValue.byteLength * 8));
            return BigInt(bn.toString());
        }
        else {
            return BigInt(`0x${bytesToHex(parsedValue)}`);
        }
    }
    if (parsedValue != null &&
        typeof parsedValue === 'object' &&
        parsedValue.constructor.name === 'BN') {
        return BigInt(parsedValue.toString());
    }
    throw new TypeError(`Invalid value type. Must be a number, bigint, integer-string, hex-string, or Uint8Array.`);
}
exports.intToBigInt = intToBigInt;
function with0x(value) {
    return value.startsWith('0x') ? value : `0x${value}`;
}
exports.with0x = with0x;
function hexToBigInt(hex) {
    if (typeof hex !== 'string')
        throw new TypeError(`hexToBigInt: expected string, got ${typeof hex}`);
    return BigInt(`0x${hex}`);
}
exports.hexToBigInt = hexToBigInt;
function intToHex(integer, lengthBytes = 8) {
    const value = typeof integer === 'bigint' ? integer : intToBigInt(integer, false);
    return value.toString(16).padStart(lengthBytes * 2, '0');
}
exports.intToHex = intToHex;
function hexToInt(hex) {
    return parseInt(hex, 16);
}
exports.hexToInt = hexToInt;
function bigIntToBytes(value, length = 16) {
    const hex = intToHex(value, length);
    return hexToBytes(hex);
}
exports.bigIntToBytes = bigIntToBytes;
function toTwos(value, width) {
    if (value < -(BigInt(1) << (width - BigInt(1))) ||
        (BigInt(1) << (width - BigInt(1))) - BigInt(1) < value) {
        throw `Unable to represent integer in width: ${width}`;
    }
    if (value >= BigInt(0)) {
        return BigInt(value);
    }
    return value + (BigInt(1) << width);
}
exports.toTwos = toTwos;
function nthBit(value, n) {
    return value & (BigInt(1) << n);
}
function fromTwos(value, width) {
    if (nthBit(value, width - BigInt(1))) {
        return value - (BigInt(1) << width);
    }
    return value;
}
exports.fromTwos = fromTwos;
const hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));
function bytesToHex(uint8a) {
    if (!(uint8a instanceof Uint8Array))
        throw new Error('Uint8Array expected');
    let hex = '';
    for (const u of uint8a) {
        hex += hexes[u];
    }
    return hex;
}
exports.bytesToHex = bytesToHex;
function hexToBytes(hex) {
    if (typeof hex !== 'string') {
        throw new TypeError(`hexToBytes: expected string, got ${typeof hex}`);
    }
    const paddedHex = hex.length % 2 ? `0${hex}` : hex;
    const array = new Uint8Array(paddedHex.length / 2);
    for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        const hexByte = paddedHex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
            throw new Error('Invalid byte sequence');
        array[i] = byte;
    }
    return array;
}
exports.hexToBytes = hexToBytes;
function utf8ToBytes(str) {
    return new TextEncoder().encode(str);
}
exports.utf8ToBytes = utf8ToBytes;
function bytesToUtf8(arr) {
    return new TextDecoder().decode(arr);
}
exports.bytesToUtf8 = bytesToUtf8;
function asciiToBytes(str) {
    const byteArray = [];
    for (let i = 0; i < str.length; i++) {
        byteArray.push(str.charCodeAt(i) & 0xff);
    }
    return new Uint8Array(byteArray);
}
exports.asciiToBytes = asciiToBytes;
function bytesToAscii(arr) {
    return String.fromCharCode.apply(null, arr);
}
exports.bytesToAscii = bytesToAscii;
function isNotOctet(octet) {
    return !Number.isInteger(octet) || octet < 0 || octet > 255;
}
function octetsToBytes(numbers) {
    if (numbers.some(isNotOctet))
        throw new Error('Some values are invalid bytes.');
    return new Uint8Array(numbers);
}
exports.octetsToBytes = octetsToBytes;
function toBytes(data) {
    if (typeof data === 'string')
        return utf8ToBytes(data);
    if (data instanceof Uint8Array)
        return data;
    throw new TypeError(`Expected input type is (Uint8Array | string) but got (${typeof data})`);
}
exports.toBytes = toBytes;
function concatBytes(...arrays) {
    if (!arrays.every(a => a instanceof Uint8Array))
        throw new Error('Uint8Array list expected');
    if (arrays.length === 1)
        return arrays[0];
    const length = arrays.reduce((a, arr) => a + arr.length, 0);
    const result = new Uint8Array(length);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
        const arr = arrays[i];
        result.set(arr, pad);
        pad += arr.length;
    }
    return result;
}
exports.concatBytes = concatBytes;
function concatArray(elements) {
    return concatBytes(...elements.map(e => {
        if (typeof e === 'number')
            return octetsToBytes([e]);
        if (e instanceof Array)
            return octetsToBytes(e);
        return e;
    }));
}
exports.concatArray = concatArray;
function isInstance(object, type) {
    return (object instanceof type ||
        (object?.constructor?.name != null && object.constructor.name === type.name));
}
exports.isInstance = isInstance;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./logger":38}],41:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-45b28387.js');

const closeIconSvg = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0ibTcgNyAxMCAxME0xNyA3IDcgMTciIHN0cm9rZT0iIzI0MjYyOSIgc3Ryb2tlLXdpZHRoPSIxLjUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPjwvc3ZnPg==';

const hiroWalletLogoSvg = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDQiIGhlaWdodD0iMzEiIHZpZXdCb3g9IjAgMCA0NCAzMSIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xMC44NDA2IDMxTDAgMTUuNUwxMC44NDA2IDBIMzMuMTU5NEw0NCAxNS41TDMzLjE1OTQgMzFIMTAuODQwNlpNMjkuOTcxIDEyLjY2OTRIMjUuMjA1OEwyOC41NTIyIDcuNzVIMjYuMDIyM0wyMS45OTMzIDEzLjY4NDVMMTcuOTc3NyA3Ljc1SDE1LjQ0NzhMMTguNzk0MiAxMi42Njk0SDE0LjAyOVYxNC41Njk1SDI5Ljk3MVYxMi42Njk0Wk0yNS4xMTIxIDE4LjI2NTVMMjguNDk4NiAyMy4yNUgyNS45Njg4TDIxLjk5MzMgMTcuMzkzNkwxOC4wMTc4IDIzLjI1SDE1LjUwMTRMMTguODg3OSAxOC4yNzg1SDE0LjAyOVYxNi4zOTE1SDI5Ljk3MVYxOC4yNjU1SDI1LjExMjFaIiBmaWxsPSJibGFjayIvPgo8L3N2Zz4K';

const xverseWalletLogoSvg = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIHZpZXdCb3g9IjAgMCA0MCA0MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjQwIiBoZWlnaHQ9IjQwIiByeD0iMTAuMjkyNCIgZmlsbD0iIzEyMTUxRSIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTExLjk0OTQgMTEuMTAxQzE2LjUxMjIgNi45NjYzMiAyMy40ODgxIDYuOTY2MzUgMjguMDUwOSAxMS4xMDFMMjYuOTg3MiAxMi4xNjQ3QzIzLjAxMzQgOC42MTQ2NiAxNi45ODcgOC42MTQ2MyAxMy4wMTMxIDEyLjE2NDZMMTEuOTQ5NCAxMS4xMDFaTTI4Ljg5OTQgMTEuOTQ5NkwyNy44MzU4IDEzLjAxMzNDMzEuMzg1NSAxNi45ODcxIDMxLjM4NTUgMjMuMDEzMyAyNy44MzU2IDI2Ljk4NzFMMjguODk5MiAyOC4wNTA4QzMzLjAzMzggMjMuNDg4MSAzMy4wMzM4IDE2LjUxMjQgMjguODk5NCAxMS45NDk2Wk0xMy4wMTMzIDI3LjgzNTdDMTYuOTg3MSAzMS4zODU1IDIzLjAxMzIgMzEuMzg1NSAyNi45ODcgMjcuODM1NkwyOC4wNTA3IDI4Ljg5OTNDMjMuNDg3OSAzMy4wMzM4IDE2LjUxMjQgMzMuMDMzOCAxMS45NDk2IDI4Ljg5OTRMMTMuMDEzMyAyNy44MzU3Wk0xMi4xNjQ3IDI2Ljk4NzJMMTEuMTAxIDI4LjA1MDlDNi45NjYzOCAyMy40ODgxIDYuOTY2MzIgMTYuNTEyNCAxMS4xMDA4IDExLjk0OTVMMTIuMTY0NSAxMy4wMTMyQzguNjE0NjMgMTYuOTg3MSA4LjYxNDY5IDIzLjAxMzQgMTIuMTY0NyAyNi45ODcyWk0yNy40Nzg2IDE0Ljk4OTZDMjcuMTU3OSAxNC41MTIxIDI2Ljc4NjQgMTQuMDU4NSAyNi4zNjQzIDEzLjYzNjRDMjMuNTY4MiAxMC44NDAyIDE5LjM4OTkgMTAuMjY4NSAxNi4wMjg2IDExLjkyMTRMMTYuNzgxOSAxMy4yMjYxQzE5LjU2NjQgMTEuOTAzMiAyMi45OTc3IDEyLjM5NDEgMjUuMzAyMiAxNC42OTg1QzI1LjYyOTMgMTUuMDI1NiAyNS45MTk4IDE1LjM3NTQgMjYuMTczOCAxNS43NDI5TDI3LjQ3ODYgMTQuOTg5NlpNMjYuNzc0NSAxNi43ODE3TDI4LjA3OTMgMTYuMDI4NEMyOS43MzIyIDE5LjM4OTggMjkuMTYwNiAyMy41NjgyIDI2LjM2NDMgMjYuMzY0NEMyNS45NDIyIDI2Ljc4NjYgMjUuNDg4NSAyNy4xNTggMjUuMDEwOCAyNy40Nzg4TDI0LjI1NzYgMjYuMTc0MUMyNC42MjUxIDI1LjkyIDI0Ljk3NSAyNS42Mjk0IDI1LjMwMjIgMjUuMzAyMkMyNy42MDY3IDIyLjk5NzcgMjguMDk3NSAxOS41NjYyIDI2Ljc3NDUgMTYuNzgxN1pNMjMuMjE4NyAyNi43NzQ3QzIwLjQzNDIgMjguMDk3NSAxNy4wMDI5IDI3LjYwNjYgMTQuNjk4NSAyNS4zMDIyQzE0LjM3MTIgMjQuOTc0OSAxNC4wODA1IDI0LjYyNDkgMTMuODI2NCAyNC4yNTczTDEyLjUyMTcgMjUuMDEwNkMxMi44NDI1IDI1LjQ4ODMgMTMuMjE0IDI1Ljk0MjEgMTMuNjM2MyAyNi4zNjQ0QzE2LjQzMjUgMjkuMTYwNSAyMC42MTA3IDI5LjczMjIgMjMuOTcyIDI4LjA3OTRMMjMuMjE4NyAyNi43NzQ3Wk0xMS45MjExIDIzLjk3MTdMMTMuMjI1OCAyMy4yMTg0QzExLjkwMzMgMjAuNDM0IDEyLjM5NDIgMTcuMDAyOSAxNC42OTg1IDE0LjY5ODVDMTUuMDI1NyAxNC4zNzE0IDE1LjM3NTUgMTQuMDgwOCAxNS43NDMgMTMuODI2N0wxNC45ODk3IDEyLjUyMkMxNC41MTIxIDEyLjg0MjggMTQuMDU4NSAxMy4yMTQyIDEzLjYzNjMgMTMuNjM2NEMxMC44NDAzIDE2LjQzMjQgMTAuMjY4NSAyMC42MTA0IDExLjkyMTEgMjMuOTcxN1pNMjQuMjQyOCAxNS43NTc0QzI1LjEyODcgMTYuNjQzMyAyNS42Nzk3IDE3LjczNzMgMjUuODk1NyAxOC44ODIxTDI0LjM4OTIgMTkuMDEzOUMyNC4yMDkzIDE4LjIwOTcgMjMuODA2NCAxNy40NDU0IDIzLjE4MDYgMTYuODE5NUMyMi4zNTU2IDE1Ljk5NDUgMjEuMjg5NyAxNS41NTY5IDIwLjIwOTIgMTUuNTA3TDIwLjA3NzQgMTQuMDAwNUMyMS41ODcxIDE0LjAxOTggMjMuMDkwOSAxNC42MDU0IDI0LjI0MjggMTUuNzU3NFpNMTguODgyIDE0LjEwNDVDMTcuNzM3MyAxNC4zMjA2IDE2LjY0MzMgMTQuODcxNSAxNS43NTc1IDE1Ljc1NzRDMTQuNjA1NiAxNi45MDkyIDE0LjAyIDE4LjQxMjkgMTQuMDAwNiAxOS45MjI1TDE1LjUwNzEgMTkuNzkwN0MxNS41NTcxIDE4LjcxMDMgMTUuOTk0NiAxNy42NDQ2IDE2LjgxOTYgMTYuODE5NUMxNy40NDU0IDE2LjE5MzggMTguMjA5NyAxNS43OTA5IDE5LjAxMzggMTUuNjExTDE4Ljg4MiAxNC4xMDQ1Wk0xNC4xMDQ2IDIxLjExOEMxNC4zMjA2IDIyLjI2MjggMTQuODcxNSAyMy4zNTY4IDE1Ljc1NzUgMjQuMjQyN0MxNi45MDkzIDI1LjM5NDYgMTguNDEzIDI1Ljk4MDIgMTkuOTIyNiAyNS45OTk2TDE5Ljc5MDcgMjQuNDkzMUMxOC43MTA0IDI0LjQ0MyAxNy42NDQ2IDI0LjAwNTUgMTYuODE5NiAyMy4xODA1QzE2LjE5MzggMjIuNTU0NyAxNS43OTEgMjEuNzkwNCAxNS42MTExIDIwLjk4NjJMMTQuMTA0NiAyMS4xMThaTTI0LjI0MjggMjQuMjQyN0MyMy4zNTY5IDI1LjEyODYgMjIuMjYyOCAyNS42Nzk2IDIxLjExOCAyNS44OTU2TDIwLjk4NjIgMjQuMzg5MUMyMS43OTA0IDI0LjIwOTIgMjIuNTU0OCAyMy44MDY0IDIzLjE4MDYgMjMuMTgwNUMyNC4wMDU2IDIyLjM1NTUgMjQuNDQzMiAyMS4yODk3IDI0LjQ5MzIgMjAuMjA5NEwyNS45OTk3IDIwLjA3NzZDMjUuOTgwMyAyMS41ODcyIDI1LjM5NDcgMjMuMDkwOCAyNC4yNDI4IDI0LjI0MjdaIiBmaWxsPSJ1cmwoI3BhaW50MF9saW5lYXJfNTA1Nl8yNDIzNjgpIi8+CjxkZWZzPgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50MF9saW5lYXJfNTA1Nl8yNDIzNjgiIHgxPSIxMS41NjgxIiB5MT0iMjguNTY5MSIgeDI9IjMyLjc2NjkiIHkyPSI3LjM3MDMzIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CjxzdG9wIHN0b3AtY29sb3I9IiM1NTY1RjciLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjOUVBN0ZBIi8+CjwvbGluZWFyR3JhZGllbnQ+CjwvZGVmcz4KPC9zdmc+Cg==';

const isChrome = () => {
  const isChromium = !!window['chrome'];
  const winNav = window.navigator;
  const vendorName = winNav.vendor;
  const isOpera = typeof window.opr !== 'undefined';
  const isIEedge = winNav.userAgent.includes('Edge');
  const isIOSChrome = /CriOS/.exec(winNav.userAgent);
  const isMobile = winNav.userAgent.includes('Mobile');
  if (isIOSChrome) {
    return false;
  }
  else if (isChromium !== null &&
    typeof isChromium !== 'undefined' &&
    vendorName === 'Google Inc.' &&
    isOpera === false &&
    isIEedge === false &&
    isMobile === false) {
    return true;
  }
  else {
    return false;
  }
};
const getBrowser = () => {
  if (isChrome()) {
    return 'Chrome';
  }
  else if (window.navigator.userAgent.includes('Firefox')) {
    return 'Firefox';
  }
  return null;
};
const getPlatform = () => {
  if (!window.navigator.userAgent.includes('Mobile'))
    return null;
  if (window.navigator.userAgent.includes('iPhone')) {
    return 'IOS';
  }
  else
    return 'Android';
};

const modalCss = ":host{all:initial}.modal-container{display:flex;flex-direction:column;background-color:rgba(0, 0, 0, 0.48);width:100%;height:100%;position:fixed;top:0px;left:0px;justify-content:center;font-family:\"Inter\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Helvetica, Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\";z-index:8999;overflow-y:scroll}.modal-body{width:486px;max-width:100%;max-height:calc(100% - 48px);background:white;margin-left:auto;margin-right:auto;border-radius:12px;padding:20px 24px 20px;box-sizing:border-box}@media (max-width: 640px){.modal-body{max-height:100%}}.modal-header{display:flex;flex-direction:column}@media (max-width: 640px){.modal-header{flex-direction:row-reverse;align-items:flex-start}}.close-modal{display:flex;align-items:flex-end;justify-content:flex-end}.close-icon{cursor:pointer}.modal-content{display:flex;flex-direction:column}.download-hiro-wallet{background-image:url(data:image/png;base64,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);height:269px;width:310px}.modal-title{color:#242629;font-family:\"Open Sauce One\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Helvetica, Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\";font-weight:500;font-size:32px;line-height:32px;margin-bottom:18px;padding-right:48px;margin-top:18px}@media (max-width: 640px){.modal-title{font-size:24px;line-height:24px;margin-bottom:8px;margin-top:0px;padding-right:0px}}.modal-subtitle{font-size:16px;font-weight:400;line-height:24px;color:#74777d}@media (max-width: 640px){.modal-subtitle{font-size:13px}}.download-app-container{display:flex;flex-direction:column;margin-top:20px}.button{width:100%;max-width:139px;box-sizing:border-box;border-radius:8px;font-size:14px;font-weight:500;line-height:20px;background-color:#5546ff;color:#ffffff;min-height:48px;min-width:126px;-webkit-appearance:none;-moz-appearance:none;appearance:none;-webkit-transition:all 250ms;transition:all 250ms;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;white-space:nowrap;outline:none;border:none;cursor:pointer}.link{color:#5546ff;font-size:14px;line-height:20px;cursor:pointer;margin-top:4px}.modal-subheading{font-size:16px;font-weight:600;line-height:19px;color:#000000}.modal-wallet-card{display:flex;align-items:flex-start;background:white;border:2px solid #f4f4f6;border-radius:16px;margin-top:12px;padding:24px 10px 24px 20px}.wallet-container{display:flex;flex-direction:column}@media (max-width: 640px){.wallet-container{flex-direction:column-reverse}}.modal-wallet-text{font-size:14px;font-weight:400;line-height:20px;margin-top:4px;color:#74777d}.modal-wallet-text a{color:#5546ff;text-decoration:none}@media (max-width: 640px){.modal-wallet-text{font-size:13px}}.modal-wallet-card-content{display:flex;flex-direction:column;padding-left:14px}";

const CHROME_BROWSER_URL = 'https://www.google.com/chrome/';
const BRAVE_BROWSER_URL = 'https://brave.com/';
const FIREFOX_BROWSER_URL = 'https://www.mozilla.org/en-US/';
const CHROME_STORE_URL = 'https://chrome.google.com/webstore/detail/hiro-wallet/ldinpeekobnhjjdofggfgjlcehhmanlj/';
const FIREFOX_STORE_URL = 'https://addons.mozilla.org/en-US/firefox/addon/hiro-wallet/';
const XVERSE_APP_STORE_URL = 'https://apps.apple.com/app/id1552272513';
const XVERSE_PLAY_STORE_URL = 'https://play.google.com/store/apps/details?id=com.secretkeylabs.xverse';
const Modal = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
  }
  handleCloseModal() {
    var _a, _b;
    this.modalEl.remove();
    (_b = (_a = this.authOptions).onCancel) === null || _b === void 0 ? void 0 : _b.call(_a);
  }
  handleDownloadPath(browser) {
    if (browser === 'Chrome') {
      window.open(CHROME_STORE_URL, '_blank');
    }
    else if (browser === 'Firefox') {
      window.open(FIREFOX_STORE_URL, '_blank');
    }
    else if (browser === 'IOS') {
      window.open(XVERSE_APP_STORE_URL, '_blank');
    }
    else if (browser === 'Android') {
      window.open(XVERSE_PLAY_STORE_URL, '_blank');
    }
    else {
      window.open('https://www.hiro.so/wallet/install-web', '_blank');
    }
    this.hasOpenedInstall = true;
  }
  render() {
    const browser = getBrowser();
    const isMobile = getPlatform();
    const xverseWalletDescription = browser
      ? `Xverse is your gateway to Stacks on mobile. `
      : isMobile
        ? `Xverse is your gateway to Stacks apps like ${this.authOptions.appDetails.name}. Install it on your device to continue.`
        : `Mobile application for iOS and Android.`;
    return (index.h("div", { class: "modal-container" }, index.h("div", { class: "modal-body" }, index.h("div", { class: "modal-header" }, index.h("div", { class: "close-modal" }, index.h("img", { class: "close-icon", src: closeIconSvg, onClick: () => this.handleCloseModal() })), isMobile || browser ? (index.h("span", { class: "modal-title" }, "Get wallet to use ", this.authOptions.appDetails.name)) : (index.h("span", { class: "modal-title" }, "Your browser isn't supported"))), index.h("div", { class: "modal-subtitle" }, "To sign in to ", this.authOptions.appDetails.name, ", you will need a Stacks-compatible wallet."), index.h("div", { class: "modal-content" }, index.h("div", { class: "wallet-container" }, index.h("div", { class: "modal-wallet-card" }, index.h("img", { src: hiroWalletLogoSvg }), index.h("div", { class: "modal-wallet-card-content" }, index.h("span", { class: "modal-subheading" }, "Hiro Wallet"), browser && !isMobile ? (index.h("div", { class: "modal-wallet-text" }, "Hiro Wallet is your gateway to Stacks apps like", ' ', this.authOptions.appDetails.name, ". Add it to ", browser, " to continue", ' ')) : (index.h("div", { class: "modal-wallet-text" }, "Browser extension for ", ` `, index.h("a", { href: CHROME_BROWSER_URL, target: "_blank" }, "Chrome"), `, `, index.h("a", { href: BRAVE_BROWSER_URL, target: "_blank" }, "Brave"), `, or `, index.h("a", { href: FIREFOX_BROWSER_URL, target: "_blank" }, "Firefox"), ` on desktop.`)), index.h("span", { class: "link", onClick: () => window.open('https://www.hiro.so/wallet', '_blank') }, "About Hiro Wallet \u2192"), browser && !isMobile && (index.h("div", { class: "download-app-container" }, this.hasOpenedInstall ? (index.h("div", { class: "modal-wallet-text" }, "After installing Hiro Wallet, reload this page and sign in.")) : (index.h("button", { class: "button", onClick: () => {
        this.handleDownloadPath(browser);
      } }, "Download")))))), index.h("div", { class: "modal-wallet-card" }, index.h("img", { src: xverseWalletLogoSvg }), index.h("div", { class: "modal-wallet-card-content" }, index.h("span", { class: "modal-subheading" }, "Xverse Wallet"), index.h("div", { class: "modal-wallet-text" }, xverseWalletDescription), index.h("span", { class: "link", onClick: () => window.open('https://www.xverse.app/', '_blank') }, "About Xverse Wallet \u2192"), isMobile && (index.h("div", { class: "download-app-container" }, this.hasOpenedInstall ? (index.h("span", { class: "link", onClick: () => window.open(`stacks://browser?url=${window.location.href}`, '_blank') }, "Open this page in Xverse Wallet \u2192")) : (index.h("button", { class: "button", onClick: () => {
        this.handleDownloadPath(isMobile);
      } }, "Download")))))))))));
  }
  static get assetsDirs() { return ["assets"]; }
  get modalEl() { return index.getElement(this); }
};
Modal.style = modalCss;

exports.connect_modal = Modal;

},{"./index-45b28387.js":42}],42:[function(require,module,exports){
'use strict';

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () {
            return e[k];
          }
        });
      }
    });
  }
  n['default'] = e;
  return Object.freeze(n);
}

const NAMESPACE = 'connect-ui';

let scopeId;
let hostTagName;
let isSvgMode = false;
let queuePending = false;
const win = typeof window !== 'undefined' ? window : {};
const doc = win.document || { head: {} };
const plt = {
    $flags$: 0,
    $resourcesUrl$: '',
    jmp: (h) => h(),
    raf: (h) => requestAnimationFrame(h),
    ael: (el, eventName, listener, opts) => el.addEventListener(eventName, listener, opts),
    rel: (el, eventName, listener, opts) => el.removeEventListener(eventName, listener, opts),
    ce: (eventName, opts) => new CustomEvent(eventName, opts),
};
const promiseResolve = (v) => Promise.resolve(v);
const supportsConstructableStylesheets = /*@__PURE__*/ (() => {
        try {
            new CSSStyleSheet();
            return typeof new CSSStyleSheet().replaceSync === 'function';
        }
        catch (e) { }
        return false;
    })()
    ;
const HYDRATED_CSS = '{visibility:hidden}.hydrated{visibility:inherit}';
const createTime = (fnName, tagName = '') => {
    {
        return () => {
            return;
        };
    }
};
const uniqueTime = (key, measureText) => {
    {
        return () => {
            return;
        };
    }
};
const rootAppliedStyles = new WeakMap();
const registerStyle = (scopeId, cssText, allowCS) => {
    let style = styles.get(scopeId);
    if (supportsConstructableStylesheets && allowCS) {
        style = (style || new CSSStyleSheet());
        if (typeof style === 'string') {
            style = cssText;
        }
        else {
            style.replaceSync(cssText);
        }
    }
    else {
        style = cssText;
    }
    styles.set(scopeId, style);
};
const addStyle = (styleContainerNode, cmpMeta, mode, hostElm) => {
    let scopeId = getScopeId(cmpMeta);
    const style = styles.get(scopeId);
    // if an element is NOT connected then getRootNode() will return the wrong root node
    // so the fallback is to always use the document for the root node in those cases
    styleContainerNode = styleContainerNode.nodeType === 11 /* DocumentFragment */ ? styleContainerNode : doc;
    if (style) {
        if (typeof style === 'string') {
            styleContainerNode = styleContainerNode.head || styleContainerNode;
            let appliedStyles = rootAppliedStyles.get(styleContainerNode);
            let styleElm;
            if (!appliedStyles) {
                rootAppliedStyles.set(styleContainerNode, (appliedStyles = new Set()));
            }
            if (!appliedStyles.has(scopeId)) {
                {
                    {
                        styleElm = doc.createElement('style');
                        styleElm.innerHTML = style;
                    }
                    styleContainerNode.insertBefore(styleElm, styleContainerNode.querySelector('link'));
                }
                if (appliedStyles) {
                    appliedStyles.add(scopeId);
                }
            }
        }
        else if (!styleContainerNode.adoptedStyleSheets.includes(style)) {
            styleContainerNode.adoptedStyleSheets = [...styleContainerNode.adoptedStyleSheets, style];
        }
    }
    return scopeId;
};
const attachStyles = (hostRef) => {
    const cmpMeta = hostRef.$cmpMeta$;
    const elm = hostRef.$hostElement$;
    const flags = cmpMeta.$flags$;
    const endAttachStyles = createTime('attachStyles', cmpMeta.$tagName$);
    const scopeId = addStyle(elm.shadowRoot ? elm.shadowRoot : elm.getRootNode(), cmpMeta);
    if (flags & 10 /* needsScopedEncapsulation */) {
        // only required when we're NOT using native shadow dom (slot)
        // or this browser doesn't support native shadow dom
        // and this host element was NOT created with SSR
        // let's pick out the inner content for slot projection
        // create a node to represent where the original
        // content was first placed, which is useful later on
        // DOM WRITE!!
        elm['s-sc'] = scopeId;
        elm.classList.add(scopeId + '-h');
    }
    endAttachStyles();
};
const getScopeId = (cmp, mode) => 'sc-' + (cmp.$tagName$);
/**
 * Default style mode id
 */
/**
 * Reusable empty obj/array
 * Don't add values to these!!
 */
const EMPTY_OBJ = {};
const isDef = (v) => v != null;
const isComplexType = (o) => {
    // https://jsperf.com/typeof-fn-object/5
    o = typeof o;
    return o === 'object' || o === 'function';
};
/**
 * Production h() function based on Preact by
 * Jason Miller (@developit)
 * Licensed under the MIT License
 * https://github.com/developit/preact/blob/master/LICENSE
 *
 * Modified for Stencil's compiler and vdom
 */
// const stack: any[] = [];
// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, child?: d.ChildType): d.VNode;
// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, ...children: d.ChildType[]): d.VNode;
const h = (nodeName, vnodeData, ...children) => {
    let child = null;
    let simple = false;
    let lastSimple = false;
    const vNodeChildren = [];
    const walk = (c) => {
        for (let i = 0; i < c.length; i++) {
            child = c[i];
            if (Array.isArray(child)) {
                walk(child);
            }
            else if (child != null && typeof child !== 'boolean') {
                if ((simple = typeof nodeName !== 'function' && !isComplexType(child))) {
                    child = String(child);
                }
                if (simple && lastSimple) {
                    // If the previous child was simple (string), we merge both
                    vNodeChildren[vNodeChildren.length - 1].$text$ += child;
                }
                else {
                    // Append a new vNode, if it's text, we create a text vNode
                    vNodeChildren.push(simple ? newVNode(null, child) : child);
                }
                lastSimple = simple;
            }
        }
    };
    walk(children);
    if (vnodeData) {
        {
            const classData = vnodeData.className || vnodeData.class;
            if (classData) {
                vnodeData.class =
                    typeof classData !== 'object'
                        ? classData
                        : Object.keys(classData)
                            .filter((k) => classData[k])
                            .join(' ');
            }
        }
    }
    const vnode = newVNode(nodeName, null);
    vnode.$attrs$ = vnodeData;
    if (vNodeChildren.length > 0) {
        vnode.$children$ = vNodeChildren;
    }
    return vnode;
};
const newVNode = (tag, text) => {
    const vnode = {
        $flags$: 0,
        $tag$: tag,
        $text$: text,
        $elm$: null,
        $children$: null,
    };
    {
        vnode.$attrs$ = null;
    }
    return vnode;
};
const Host = {};
const isHost = (node) => node && node.$tag$ === Host;
/**
 * Production setAccessor() function based on Preact by
 * Jason Miller (@developit)
 * Licensed under the MIT License
 * https://github.com/developit/preact/blob/master/LICENSE
 *
 * Modified for Stencil's compiler and vdom
 */
const setAccessor = (elm, memberName, oldValue, newValue, isSvg, flags) => {
    if (oldValue !== newValue) {
        let isProp = isMemberInElement(elm, memberName);
        let ln = memberName.toLowerCase();
        if (memberName === 'class') {
            const classList = elm.classList;
            const oldClasses = parseClassList(oldValue);
            const newClasses = parseClassList(newValue);
            classList.remove(...oldClasses.filter((c) => c && !newClasses.includes(c)));
            classList.add(...newClasses.filter((c) => c && !oldClasses.includes(c)));
        }
        else if ((!isProp ) &&
            memberName[0] === 'o' &&
            memberName[1] === 'n') {
            // Event Handlers
            // so if the member name starts with "on" and the 3rd characters is
            // a capital letter, and it's not already a member on the element,
            // then we're assuming it's an event listener
            if (memberName[2] === '-') {
                // on- prefixed events
                // allows to be explicit about the dom event to listen without any magic
                // under the hood:
                // <my-cmp on-click> // listens for "click"
                // <my-cmp on-Click> // listens for "Click"
                // <my-cmp on-ionChange> // listens for "ionChange"
                // <my-cmp on-EVENTS> // listens for "EVENTS"
                memberName = memberName.slice(3);
            }
            else if (isMemberInElement(win, ln)) {
                // standard event
                // the JSX attribute could have been "onMouseOver" and the
                // member name "onmouseover" is on the window's prototype
                // so let's add the listener "mouseover", which is all lowercased
                memberName = ln.slice(2);
            }
            else {
                // custom event
                // the JSX attribute could have been "onMyCustomEvent"
                // so let's trim off the "on" prefix and lowercase the first character
                // and add the listener "myCustomEvent"
                // except for the first character, we keep the event name case
                memberName = ln[2] + memberName.slice(3);
            }
            if (oldValue) {
                plt.rel(elm, memberName, oldValue, false);
            }
            if (newValue) {
                plt.ael(elm, memberName, newValue, false);
            }
        }
        else {
            // Set property if it exists and it's not a SVG
            const isComplex = isComplexType(newValue);
            if ((isProp || (isComplex && newValue !== null)) && !isSvg) {
                try {
                    if (!elm.tagName.includes('-')) {
                        const n = newValue == null ? '' : newValue;
                        // Workaround for Safari, moving the <input> caret when re-assigning the same valued
                        if (memberName === 'list') {
                            isProp = false;
                        }
                        else if (oldValue == null || elm[memberName] != n) {
                            elm[memberName] = n;
                        }
                    }
                    else {
                        elm[memberName] = newValue;
                    }
                }
                catch (e) { }
            }
            if (newValue == null || newValue === false) {
                if (newValue !== false || elm.getAttribute(memberName) === '') {
                    {
                        elm.removeAttribute(memberName);
                    }
                }
            }
            else if ((!isProp || flags & 4 /* isHost */ || isSvg) && !isComplex) {
                newValue = newValue === true ? '' : newValue;
                {
                    elm.setAttribute(memberName, newValue);
                }
            }
        }
    }
};
const parseClassListRegex = /\s/;
const parseClassList = (value) => (!value ? [] : value.split(parseClassListRegex));
const updateElement = (oldVnode, newVnode, isSvgMode, memberName) => {
    // if the element passed in is a shadow root, which is a document fragment
    // then we want to be adding attrs/props to the shadow root's "host" element
    // if it's not a shadow root, then we add attrs/props to the same element
    const elm = newVnode.$elm$.nodeType === 11 /* DocumentFragment */ && newVnode.$elm$.host
        ? newVnode.$elm$.host
        : newVnode.$elm$;
    const oldVnodeAttrs = (oldVnode && oldVnode.$attrs$) || EMPTY_OBJ;
    const newVnodeAttrs = newVnode.$attrs$ || EMPTY_OBJ;
    {
        // remove attributes no longer present on the vnode by setting them to undefined
        for (memberName in oldVnodeAttrs) {
            if (!(memberName in newVnodeAttrs)) {
                setAccessor(elm, memberName, oldVnodeAttrs[memberName], undefined, isSvgMode, newVnode.$flags$);
            }
        }
    }
    // add new & update changed attributes
    for (memberName in newVnodeAttrs) {
        setAccessor(elm, memberName, oldVnodeAttrs[memberName], newVnodeAttrs[memberName], isSvgMode, newVnode.$flags$);
    }
};
const createElm = (oldParentVNode, newParentVNode, childIndex, parentElm) => {
    // tslint:disable-next-line: prefer-const
    const newVNode = newParentVNode.$children$[childIndex];
    let i = 0;
    let elm;
    let childNode;
    if (newVNode.$text$ !== null) {
        // create text node
        elm = newVNode.$elm$ = doc.createTextNode(newVNode.$text$);
    }
    else {
        // create element
        elm = newVNode.$elm$ = (doc.createElement(newVNode.$tag$));
        // add css classes, attrs, props, listeners, etc.
        {
            updateElement(null, newVNode, isSvgMode);
        }
        if (isDef(scopeId) && elm['s-si'] !== scopeId) {
            // if there is a scopeId and this is the initial render
            // then let's add the scopeId as a css class
            elm.classList.add((elm['s-si'] = scopeId));
        }
        if (newVNode.$children$) {
            for (i = 0; i < newVNode.$children$.length; ++i) {
                // create the node
                childNode = createElm(oldParentVNode, newVNode, i);
                // return node could have been null
                if (childNode) {
                    // append our new node
                    elm.appendChild(childNode);
                }
            }
        }
    }
    return elm;
};
const addVnodes = (parentElm, before, parentVNode, vnodes, startIdx, endIdx) => {
    let containerElm = (parentElm);
    let childNode;
    if (containerElm.shadowRoot && containerElm.tagName === hostTagName) {
        containerElm = containerElm.shadowRoot;
    }
    for (; startIdx <= endIdx; ++startIdx) {
        if (vnodes[startIdx]) {
            childNode = createElm(null, parentVNode, startIdx);
            if (childNode) {
                vnodes[startIdx].$elm$ = childNode;
                containerElm.insertBefore(childNode, before);
            }
        }
    }
};
const removeVnodes = (vnodes, startIdx, endIdx, vnode, elm) => {
    for (; startIdx <= endIdx; ++startIdx) {
        if ((vnode = vnodes[startIdx])) {
            elm = vnode.$elm$;
            // remove the vnode's element from the dom
            elm.remove();
        }
    }
};
const updateChildren = (parentElm, oldCh, newVNode, newCh) => {
    let oldStartIdx = 0;
    let newStartIdx = 0;
    let oldEndIdx = oldCh.length - 1;
    let oldStartVnode = oldCh[0];
    let oldEndVnode = oldCh[oldEndIdx];
    let newEndIdx = newCh.length - 1;
    let newStartVnode = newCh[0];
    let newEndVnode = newCh[newEndIdx];
    let node;
    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
        if (oldStartVnode == null) {
            // Vnode might have been moved left
            oldStartVnode = oldCh[++oldStartIdx];
        }
        else if (oldEndVnode == null) {
            oldEndVnode = oldCh[--oldEndIdx];
        }
        else if (newStartVnode == null) {
            newStartVnode = newCh[++newStartIdx];
        }
        else if (newEndVnode == null) {
            newEndVnode = newCh[--newEndIdx];
        }
        else if (isSameVnode(oldStartVnode, newStartVnode)) {
            patch(oldStartVnode, newStartVnode);
            oldStartVnode = oldCh[++oldStartIdx];
            newStartVnode = newCh[++newStartIdx];
        }
        else if (isSameVnode(oldEndVnode, newEndVnode)) {
            patch(oldEndVnode, newEndVnode);
            oldEndVnode = oldCh[--oldEndIdx];
            newEndVnode = newCh[--newEndIdx];
        }
        else if (isSameVnode(oldStartVnode, newEndVnode)) {
            patch(oldStartVnode, newEndVnode);
            parentElm.insertBefore(oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);
            oldStartVnode = oldCh[++oldStartIdx];
            newEndVnode = newCh[--newEndIdx];
        }
        else if (isSameVnode(oldEndVnode, newStartVnode)) {
            patch(oldEndVnode, newStartVnode);
            parentElm.insertBefore(oldEndVnode.$elm$, oldStartVnode.$elm$);
            oldEndVnode = oldCh[--oldEndIdx];
            newStartVnode = newCh[++newStartIdx];
        }
        else {
            {
                // new element
                node = createElm(oldCh && oldCh[newStartIdx], newVNode, newStartIdx);
                newStartVnode = newCh[++newStartIdx];
            }
            if (node) {
                {
                    oldStartVnode.$elm$.parentNode.insertBefore(node, oldStartVnode.$elm$);
                }
            }
        }
    }
    if (oldStartIdx > oldEndIdx) {
        addVnodes(parentElm, newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$, newVNode, newCh, newStartIdx, newEndIdx);
    }
    else if (newStartIdx > newEndIdx) {
        removeVnodes(oldCh, oldStartIdx, oldEndIdx);
    }
};
const isSameVnode = (vnode1, vnode2) => {
    // compare if two vnode to see if they're "technically" the same
    // need to have the same element tag, and same key to be the same
    if (vnode1.$tag$ === vnode2.$tag$) {
        return true;
    }
    return false;
};
const patch = (oldVNode, newVNode) => {
    const elm = (newVNode.$elm$ = oldVNode.$elm$);
    const oldChildren = oldVNode.$children$;
    const newChildren = newVNode.$children$;
    const text = newVNode.$text$;
    if (text === null) {
        // element node
        {
            {
                // either this is the first render of an element OR it's an update
                // AND we already know it's possible it could have changed
                // this updates the element's css classes, attrs, props, listeners, etc.
                updateElement(oldVNode, newVNode, isSvgMode);
            }
        }
        if (oldChildren !== null && newChildren !== null) {
            // looks like there's child vnodes for both the old and new vnodes
            updateChildren(elm, oldChildren, newVNode, newChildren);
        }
        else if (newChildren !== null) {
            // no old child vnodes, but there are new child vnodes to add
            if (oldVNode.$text$ !== null) {
                // the old vnode was text, so be sure to clear it out
                elm.textContent = '';
            }
            // add the new vnode children
            addVnodes(elm, null, newVNode, newChildren, 0, newChildren.length - 1);
        }
        else if (oldChildren !== null) {
            // no new child vnodes, but there are old child vnodes to remove
            removeVnodes(oldChildren, 0, oldChildren.length - 1);
        }
    }
    else if (oldVNode.$text$ !== text) {
        // update the text content for the text only vnode
        // and also only if the text is different than before
        elm.data = text;
    }
};
const renderVdom = (hostRef, renderFnResults) => {
    const hostElm = hostRef.$hostElement$;
    const oldVNode = hostRef.$vnode$ || newVNode(null, null);
    const rootVnode = isHost(renderFnResults) ? renderFnResults : h(null, null, renderFnResults);
    hostTagName = hostElm.tagName;
    rootVnode.$tag$ = null;
    rootVnode.$flags$ |= 4 /* isHost */;
    hostRef.$vnode$ = rootVnode;
    rootVnode.$elm$ = oldVNode.$elm$ = (hostElm.shadowRoot || hostElm );
    {
        scopeId = hostElm['s-sc'];
    }
    // synchronous patch
    patch(oldVNode, rootVnode);
};
const getElement = (ref) => (getHostRef(ref).$hostElement$ );
/**
 * Helper function to create & dispatch a custom Event on a provided target
 * @param elm the target of the Event
 * @param name the name to give the custom Event
 * @param opts options for configuring a custom Event
 * @returns the custom Event
 */
const emitEvent = (elm, name, opts) => {
    const ev = plt.ce(name, opts);
    elm.dispatchEvent(ev);
    return ev;
};
const attachToAncestor = (hostRef, ancestorComponent) => {
    if (ancestorComponent && !hostRef.$onRenderResolve$ && ancestorComponent['s-p']) {
        ancestorComponent['s-p'].push(new Promise((r) => (hostRef.$onRenderResolve$ = r)));
    }
};
const scheduleUpdate = (hostRef, isInitialLoad) => {
    {
        hostRef.$flags$ |= 16 /* isQueuedForUpdate */;
    }
    if (hostRef.$flags$ & 4 /* isWaitingForChildren */) {
        hostRef.$flags$ |= 512 /* needsRerender */;
        return;
    }
    attachToAncestor(hostRef, hostRef.$ancestorComponent$);
    // there is no ancestor component or the ancestor component
    // has already fired off its lifecycle update then
    // fire off the initial update
    const dispatch = () => dispatchHooks(hostRef, isInitialLoad);
    return writeTask(dispatch) ;
};
const dispatchHooks = (hostRef, isInitialLoad) => {
    const endSchedule = createTime('scheduleUpdate', hostRef.$cmpMeta$.$tagName$);
    const instance = hostRef.$lazyInstance$ ;
    let promise;
    endSchedule();
    return then(promise, () => updateComponent(hostRef, instance, isInitialLoad));
};
const updateComponent = async (hostRef, instance, isInitialLoad) => {
    // updateComponent
    const elm = hostRef.$hostElement$;
    const endUpdate = createTime('update', hostRef.$cmpMeta$.$tagName$);
    const rc = elm['s-rc'];
    if (isInitialLoad) {
        // DOM WRITE!
        attachStyles(hostRef);
    }
    const endRender = createTime('render', hostRef.$cmpMeta$.$tagName$);
    {
        callRender(hostRef, instance);
    }
    if (rc) {
        // ok, so turns out there are some child host elements
        // waiting on this parent element to load
        // let's fire off all update callbacks waiting
        rc.map((cb) => cb());
        elm['s-rc'] = undefined;
    }
    endRender();
    endUpdate();
    {
        const childrenPromises = elm['s-p'];
        const postUpdate = () => postUpdateComponent(hostRef);
        if (childrenPromises.length === 0) {
            postUpdate();
        }
        else {
            Promise.all(childrenPromises).then(postUpdate);
            hostRef.$flags$ |= 4 /* isWaitingForChildren */;
            childrenPromises.length = 0;
        }
    }
};
const callRender = (hostRef, instance, elm) => {
    try {
        instance = instance.render() ;
        {
            hostRef.$flags$ &= ~16 /* isQueuedForUpdate */;
        }
        {
            hostRef.$flags$ |= 2 /* hasRendered */;
        }
        {
            {
                // looks like we've got child nodes to render into this host element
                // or we need to update the css class/attrs on the host element
                // DOM WRITE!
                {
                    renderVdom(hostRef, instance);
                }
            }
        }
    }
    catch (e) {
        consoleError(e, hostRef.$hostElement$);
    }
    return null;
};
const postUpdateComponent = (hostRef) => {
    const tagName = hostRef.$cmpMeta$.$tagName$;
    const elm = hostRef.$hostElement$;
    const endPostUpdate = createTime('postUpdate', tagName);
    const ancestorComponent = hostRef.$ancestorComponent$;
    if (!(hostRef.$flags$ & 64 /* hasLoadedComponent */)) {
        hostRef.$flags$ |= 64 /* hasLoadedComponent */;
        {
            // DOM WRITE!
            addHydratedFlag(elm);
        }
        endPostUpdate();
        {
            hostRef.$onReadyResolve$(elm);
            if (!ancestorComponent) {
                appDidLoad();
            }
        }
    }
    else {
        endPostUpdate();
    }
    // load events fire from bottom to top
    // the deepest elements load first then bubbles up
    {
        if (hostRef.$onRenderResolve$) {
            hostRef.$onRenderResolve$();
            hostRef.$onRenderResolve$ = undefined;
        }
        if (hostRef.$flags$ & 512 /* needsRerender */) {
            nextTick(() => scheduleUpdate(hostRef, false));
        }
        hostRef.$flags$ &= ~(4 /* isWaitingForChildren */ | 512 /* needsRerender */);
    }
    // ( •_•)
    // ( •_•)>⌐■-■
    // (⌐■_■)
};
const appDidLoad = (who) => {
    // on appload
    // we have finish the first big initial render
    {
        addHydratedFlag(doc.documentElement);
    }
    nextTick(() => emitEvent(win, 'appload', { detail: { namespace: NAMESPACE } }));
};
const then = (promise, thenFn) => {
    return promise && promise.then ? promise.then(thenFn) : thenFn();
};
const addHydratedFlag = (elm) => elm.classList.add('hydrated')
    ;
/**
 * Parse a new property value for a given property type.
 *
 * While the prop value can reasonably be expected to be of `any` type as far as TypeScript's type checker is concerned,
 * it is not safe to assume that the string returned by evaluating `typeof propValue` matches:
 *   1. `any`, the type given to `propValue` in the function signature
 *   2. the type stored from `propType`.
 *
 * This function provides the capability to parse/coerce a property's value to potentially any other JavaScript type.
 *
 * Property values represented in TSX preserve their type information. In the example below, the number 0 is passed to
 * a component. This `propValue` will preserve its type information (`typeof propValue === 'number'`). Note that is
 * based on the type of the value being passed in, not the type declared of the class member decorated with `@Prop`.
 * ```tsx
 * <my-cmp prop-val={0}></my-cmp>
 * ```
 *
 * HTML prop values on the other hand, will always a string
 *
 * @param propValue the new value to coerce to some type
 * @param propType the type of the prop, expressed as a binary number
 * @returns the parsed/coerced value
 */
const parsePropertyValue = (propValue, propType) => {
    // ensure this value is of the correct prop type
    if (propValue != null && !isComplexType(propValue)) {
        // redundant return here for better minification
        return propValue;
    }
    // not sure exactly what type we want
    // so no need to change to a different type
    return propValue;
};
const getValue = (ref, propName) => getHostRef(ref).$instanceValues$.get(propName);
const setValue = (ref, propName, newVal, cmpMeta) => {
    // check our new property value against our internal value
    const hostRef = getHostRef(ref);
    const oldVal = hostRef.$instanceValues$.get(propName);
    const flags = hostRef.$flags$;
    const instance = hostRef.$lazyInstance$ ;
    newVal = parsePropertyValue(newVal);
    // explicitly check for NaN on both sides, as `NaN === NaN` is always false
    const areBothNaN = Number.isNaN(oldVal) && Number.isNaN(newVal);
    const didValueChange = newVal !== oldVal && !areBothNaN;
    if ((!(flags & 8 /* isConstructingInstance */) || oldVal === undefined) && didValueChange) {
        // gadzooks! the property's value has changed!!
        // set our new value!
        hostRef.$instanceValues$.set(propName, newVal);
        if (instance) {
            if ((flags & (2 /* hasRendered */ | 16 /* isQueuedForUpdate */)) === 2 /* hasRendered */) {
                // looks like this value actually changed, so we've got work to do!
                // but only if we've already rendered, otherwise just chill out
                // queue that we need to do an update, but don't worry about queuing
                // up millions cuz this function ensures it only runs once
                scheduleUpdate(hostRef, false);
            }
        }
    }
};
const proxyComponent = (Cstr, cmpMeta, flags) => {
    if (cmpMeta.$members$) {
        // It's better to have a const than two Object.entries()
        const members = Object.entries(cmpMeta.$members$);
        const prototype = Cstr.prototype;
        members.map(([memberName, [memberFlags]]) => {
            if ((memberFlags & 31 /* Prop */ ||
                    ((flags & 2 /* proxyState */) && memberFlags & 32 /* State */))) {
                // proxyComponent - prop
                Object.defineProperty(prototype, memberName, {
                    get() {
                        // proxyComponent, get value
                        return getValue(this, memberName);
                    },
                    set(newValue) {
                        // proxyComponent, set value
                        setValue(this, memberName, newValue);
                    },
                    configurable: true,
                    enumerable: true,
                });
            }
        });
    }
    return Cstr;
};
const initializeComponent = async (elm, hostRef, cmpMeta, hmrVersionId, Cstr) => {
    // initializeComponent
    if ((hostRef.$flags$ & 32 /* hasInitializedComponent */) === 0) {
        {
            // we haven't initialized this element yet
            hostRef.$flags$ |= 32 /* hasInitializedComponent */;
            // lazy loaded components
            // request the component's implementation to be
            // wired up with the host element
            Cstr = loadModule(cmpMeta);
            if (Cstr.then) {
                // Await creates a micro-task avoid if possible
                const endLoad = uniqueTime();
                Cstr = await Cstr;
                endLoad();
            }
            if (!Cstr.isProxied) {
                proxyComponent(Cstr, cmpMeta, 2 /* proxyState */);
                Cstr.isProxied = true;
            }
            const endNewInstance = createTime('createInstance', cmpMeta.$tagName$);
            // ok, time to construct the instance
            // but let's keep track of when we start and stop
            // so that the getters/setters don't incorrectly step on data
            {
                hostRef.$flags$ |= 8 /* isConstructingInstance */;
            }
            // construct the lazy-loaded component implementation
            // passing the hostRef is very important during
            // construction in order to directly wire together the
            // host element and the lazy-loaded instance
            try {
                new Cstr(hostRef);
            }
            catch (e) {
                consoleError(e);
            }
            {
                hostRef.$flags$ &= ~8 /* isConstructingInstance */;
            }
            endNewInstance();
        }
        if (Cstr.style) {
            // this component has styles but we haven't registered them yet
            let style = Cstr.style;
            const scopeId = getScopeId(cmpMeta);
            if (!styles.has(scopeId)) {
                const endRegisterStyles = createTime('registerStyles', cmpMeta.$tagName$);
                registerStyle(scopeId, style, !!(cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */));
                endRegisterStyles();
            }
        }
    }
    // we've successfully created a lazy instance
    const ancestorComponent = hostRef.$ancestorComponent$;
    const schedule = () => scheduleUpdate(hostRef, true);
    if (ancestorComponent && ancestorComponent['s-rc']) {
        // this is the initial load and this component it has an ancestor component
        // but the ancestor component has NOT fired its will update lifecycle yet
        // so let's just cool our jets and wait for the ancestor to continue first
        // this will get fired off when the ancestor component
        // finally gets around to rendering its lazy self
        // fire off the initial update
        ancestorComponent['s-rc'].push(schedule);
    }
    else {
        schedule();
    }
};
const connectedCallback = (elm) => {
    if ((plt.$flags$ & 1 /* isTmpDisconnected */) === 0) {
        const hostRef = getHostRef(elm);
        const cmpMeta = hostRef.$cmpMeta$;
        const endConnected = createTime('connectedCallback', cmpMeta.$tagName$);
        if (!(hostRef.$flags$ & 1 /* hasConnected */)) {
            // first time this component has connected
            hostRef.$flags$ |= 1 /* hasConnected */;
            {
                // find the first ancestor component (if there is one) and register
                // this component as one of the actively loading child components for its ancestor
                let ancestorComponent = elm;
                while ((ancestorComponent = ancestorComponent.parentNode || ancestorComponent.host)) {
                    // climb up the ancestors looking for the first
                    // component that hasn't finished its lifecycle update yet
                    if (ancestorComponent['s-p']) {
                        // we found this components first ancestor component
                        // keep a reference to this component's ancestor component
                        attachToAncestor(hostRef, (hostRef.$ancestorComponent$ = ancestorComponent));
                        break;
                    }
                }
            }
            // Lazy properties
            // https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties
            if (cmpMeta.$members$) {
                Object.entries(cmpMeta.$members$).map(([memberName, [memberFlags]]) => {
                    if (memberFlags & 31 /* Prop */ && elm.hasOwnProperty(memberName)) {
                        const value = elm[memberName];
                        delete elm[memberName];
                        elm[memberName] = value;
                    }
                });
            }
            {
                initializeComponent(elm, hostRef, cmpMeta);
            }
        }
        endConnected();
    }
};
const disconnectedCallback = (elm) => {
    if ((plt.$flags$ & 1 /* isTmpDisconnected */) === 0) {
        getHostRef(elm);
    }
};
const bootstrapLazy = (lazyBundles, options = {}) => {
    const endBootstrap = createTime();
    const cmpTags = [];
    const exclude = options.exclude || [];
    const customElements = win.customElements;
    const head = doc.head;
    const metaCharset = /*@__PURE__*/ head.querySelector('meta[charset]');
    const visibilityStyle = /*@__PURE__*/ doc.createElement('style');
    const deferredConnectedCallbacks = [];
    let appLoadFallback;
    let isBootstrapping = true;
    Object.assign(plt, options);
    plt.$resourcesUrl$ = new URL(options.resourcesUrl || './', doc.baseURI).href;
    lazyBundles.map((lazyBundle) => {
        lazyBundle[1].map((compactMeta) => {
            const cmpMeta = {
                $flags$: compactMeta[0],
                $tagName$: compactMeta[1],
                $members$: compactMeta[2],
                $listeners$: compactMeta[3],
            };
            {
                cmpMeta.$members$ = compactMeta[2];
            }
            const tagName = cmpMeta.$tagName$;
            const HostElement = class extends HTMLElement {
                // StencilLazyHost
                constructor(self) {
                    // @ts-ignore
                    super(self);
                    self = this;
                    registerHost(self, cmpMeta);
                    if (cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) {
                        // this component is using shadow dom
                        // and this browser supports shadow dom
                        // add the read-only property "shadowRoot" to the host element
                        // adding the shadow root build conditionals to minimize runtime
                        {
                            {
                                self.attachShadow({ mode: 'open' });
                            }
                        }
                    }
                }
                connectedCallback() {
                    if (appLoadFallback) {
                        clearTimeout(appLoadFallback);
                        appLoadFallback = null;
                    }
                    if (isBootstrapping) {
                        // connectedCallback will be processed once all components have been registered
                        deferredConnectedCallbacks.push(this);
                    }
                    else {
                        plt.jmp(() => connectedCallback(this));
                    }
                }
                disconnectedCallback() {
                    plt.jmp(() => disconnectedCallback(this));
                }
                componentOnReady() {
                    return getHostRef(this).$onReadyPromise$;
                }
            };
            cmpMeta.$lazyBundleId$ = lazyBundle[0];
            if (!exclude.includes(tagName) && !customElements.get(tagName)) {
                cmpTags.push(tagName);
                customElements.define(tagName, proxyComponent(HostElement, cmpMeta, 1 /* isElementConstructor */));
            }
        });
    });
    {
        visibilityStyle.innerHTML = cmpTags + HYDRATED_CSS;
        visibilityStyle.setAttribute('data-styles', '');
        head.insertBefore(visibilityStyle, metaCharset ? metaCharset.nextSibling : head.firstChild);
    }
    // Process deferred connectedCallbacks now all components have been registered
    isBootstrapping = false;
    if (deferredConnectedCallbacks.length) {
        deferredConnectedCallbacks.map((host) => host.connectedCallback());
    }
    else {
        {
            plt.jmp(() => (appLoadFallback = setTimeout(appDidLoad, 30)));
        }
    }
    // Fallback appLoad event
    endBootstrap();
};
const hostRefs = new WeakMap();
const getHostRef = (ref) => hostRefs.get(ref);
const registerInstance = (lazyInstance, hostRef) => hostRefs.set((hostRef.$lazyInstance$ = lazyInstance), hostRef);
const registerHost = (elm, cmpMeta) => {
    const hostRef = {
        $flags$: 0,
        $hostElement$: elm,
        $cmpMeta$: cmpMeta,
        $instanceValues$: new Map(),
    };
    {
        hostRef.$onReadyPromise$ = new Promise((r) => (hostRef.$onReadyResolve$ = r));
        elm['s-p'] = [];
        elm['s-rc'] = [];
    }
    return hostRefs.set(elm, hostRef);
};
const isMemberInElement = (elm, memberName) => memberName in elm;
const consoleError = (e, el) => (0, console.error)(e, el);
const cmpModules = /*@__PURE__*/ new Map();
const loadModule = (cmpMeta, hostRef, hmrVersionId) => {
    // loadModuleImport
    const exportName = cmpMeta.$tagName$.replace(/-/g, '_');
    const bundleId = cmpMeta.$lazyBundleId$;
    const module = cmpModules.get(bundleId) ;
    if (module) {
        return module[exportName];
    }
    
    if (!hmrVersionId || !BUILD.hotModuleReplacement) {
      const processMod = importedModule => {
        cmpModules.set(bundleId, importedModule);
        return importedModule[exportName];
      }
      switch(bundleId) {
        
        case 'connect-modal.cjs':
          return Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require(
            /* webpackMode: "lazy" */
            './connect-modal.cjs.entry.js')); }).then(processMod, consoleError);
      }
    }
    return Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require(
    /* @vite-ignore */
    /* webpackInclude: /\.entry\.js$/ */
    /* webpackExclude: /\.system\.entry\.js$/ */
    /* webpackMode: "lazy" */
    `./${bundleId}.entry.js${''}`)); }).then((importedModule) => {
        {
            cmpModules.set(bundleId, importedModule);
        }
        return importedModule[exportName];
    }, consoleError);
};
const styles = new Map();
const queueDomReads = [];
const queueDomWrites = [];
const queueTask = (queue, write) => (cb) => {
    queue.push(cb);
    if (!queuePending) {
        queuePending = true;
        if (write && plt.$flags$ & 4 /* queueSync */) {
            nextTick(flush);
        }
        else {
            plt.raf(flush);
        }
    }
};
const consume = (queue) => {
    for (let i = 0; i < queue.length; i++) {
        try {
            queue[i](performance.now());
        }
        catch (e) {
            consoleError(e);
        }
    }
    queue.length = 0;
};
const flush = () => {
    // always force a bunch of medium callbacks to run, but still have
    // a throttle on how many can run in a certain time
    // DOM READS!!!
    consume(queueDomReads);
    // DOM WRITES!!!
    {
        consume(queueDomWrites);
        if ((queuePending = queueDomReads.length > 0)) {
            // still more to do yet, but we've run out of time
            // let's let this thing cool off and try again in the next tick
            plt.raf(flush);
        }
    }
};
const nextTick = /*@__PURE__*/ (cb) => promiseResolve().then(cb);
const writeTask = /*@__PURE__*/ queueTask(queueDomWrites, true);

exports.bootstrapLazy = bootstrapLazy;
exports.getElement = getElement;
exports.h = h;
exports.promiseResolve = promiseResolve;
exports.registerInstance = registerInstance;

},{"./connect-modal.cjs.entry.js":41}],43:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-45b28387.js');

/*
 Stencil Client Patch Esm v2.17.1 | MIT Licensed | https://stenciljs.com
 */
const patchEsm = () => {
    return index.promiseResolve();
};

const defineCustomElements = (win, options) => {
  if (typeof window === 'undefined') return Promise.resolve();
  return patchEsm().then(() => {
  return index.bootstrapLazy([["connect-modal.cjs",[[1,"connect-modal",{"authOptions":[16],"hasOpenedInstall":[32]}]]]], options);
  });
};

exports.defineCustomElements = defineCustomElements;

},{"./index-45b28387.js":42}],44:[function(require,module,exports){

module.exports = require('../dist/cjs/loader.cjs.js');
module.exports.applyPolyfills = function() { return Promise.resolve() };

},{"../dist/cjs/loader.cjs.js":43}],45:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var auth = require('@stacks/auth');
var jsontokens = require('jsontokens');
var network = require('@stacks/network');
var common = require('@stacks/common');
var transactions = require('@stacks/transactions');
var loader = require('@stacks/connect-ui/loader');

function _regeneratorRuntime() {
  _regeneratorRuntime = function () {
    return exports;
  };
  var exports = {},
    Op = Object.prototype,
    hasOwn = Op.hasOwnProperty,
    defineProperty = Object.defineProperty || function (obj, key, desc) {
      obj[key] = desc.value;
    },
    $Symbol = "function" == typeof Symbol ? Symbol : {},
    iteratorSymbol = $Symbol.iterator || "@@iterator",
    asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
    toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  function define(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value: value,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), obj[key];
  }
  try {
    define({}, "");
  } catch (err) {
    define = function (obj, key, value) {
      return obj[key] = value;
    };
  }
  function wrap(innerFn, outerFn, self, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
      generator = Object.create(protoGenerator.prototype),
      context = new Context(tryLocsList || []);
    return defineProperty(generator, "_invoke", {
      value: makeInvokeMethod(innerFn, self, context)
    }), generator;
  }
  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }
  exports.wrap = wrap;
  var ContinueSentinel = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });
  var getProto = Object.getPrototypeOf,
    NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      define(prototype, method, function (arg) {
        return this._invoke(method, arg);
      });
    });
  }
  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if ("throw" !== record.type) {
        var result = record.arg,
          value = result.value;
        return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
          invoke("next", value, resolve, reject);
        }, function (err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function (unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function (error) {
          return invoke("throw", error, resolve, reject);
        });
      }
      reject(record.arg);
    }
    var previousPromise;
    defineProperty(this, "_invoke", {
      value: function (method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function (resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(innerFn, self, context) {
    var state = "suspendedStart";
    return function (method, arg) {
      if ("executing" === state) throw new Error("Generator is already running");
      if ("completed" === state) {
        if ("throw" === method) throw arg;
        return doneResult();
      }
      for (context.method = method, context.arg = arg;;) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }
        if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
          if ("suspendedStart" === state) throw state = "completed", context.arg;
          context.dispatchException(context.arg);
        } else "return" === context.method && context.abrupt("return", context.arg);
        state = "executing";
        var record = tryCatch(innerFn, self, context);
        if ("normal" === record.type) {
          if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
          return {
            value: record.arg,
            done: context.done
          };
        }
        "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
      }
    };
  }
  function maybeInvokeDelegate(delegate, context) {
    var methodName = context.method,
      method = delegate.iterator[methodName];
    if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }
  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }
  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }
  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next) return iterable;
      if (!isNaN(iterable.length)) {
        var i = -1,
          next = function next() {
            for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
            return next.value = undefined, next.done = !0, next;
          };
        return next.next = next;
      }
    }
    return {
      next: doneResult
    };
  }
  function doneResult() {
    return {
      value: undefined,
      done: !0
    };
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), defineProperty(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function (genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function (arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
    return this;
  }), define(Gp, "toString", function () {
    return "[object Generator]";
  }), exports.keys = function (val) {
    var object = Object(val),
      keys = [];
    for (var key in object) keys.push(key);
    return keys.reverse(), function next() {
      for (; keys.length;) {
        var key = keys.pop();
        if (key in object) return next.value = key, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function (skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
    },
    stop: function () {
      this.done = !0;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type) throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function (exception) {
      if (this.done) throw exception;
      var context = this;
      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
      }
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i],
          record = entry.completion;
        if ("root" === entry.tryLoc) return handle("end");
        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"),
            hasFinally = hasOwn.call(entry, "finallyLoc");
          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
          } else {
            if (!hasFinally) throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function (type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }
      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function (record, afterLoc) {
      if ("throw" === record.type) throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function (finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function (tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function (iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
    }
  }, exports;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}

function getStacksProvider() {
  return window.StacksProvider || window.BlockstackProvider;
}
function isStacksWalletInstalled() {
  return !!getStacksProvider();
}

var defaultAuthURL = "https://app.blockstack.org";
var version = "5.0.6-alpha.9d9606f.0";
if (typeof window !== "undefined") {
  window.__CONNECT_VERSION__ = version;
}
var isMobile = function isMobile() {
  var ua = navigator.userAgent;
  if (/android/i.test(ua)) {
    return true;
  }
  if (/iPad|iPhone|iPod/.test(ua)) {
    return true;
  }
  return /windows phone/i.test(ua);
};
var shouldUsePopup = function shouldUsePopup() {
  return !isMobile();
};
var getOrCreateUserSession = function getOrCreateUserSession(userSession) {
  if (!userSession) {
    var appConfig = new auth.AppConfig(["store_write"], document.location.href);
    userSession = new auth.UserSession({
      appConfig: appConfig
    });
  }
  return userSession;
};
var authenticate = /*#__PURE__*/function () {
  var _ref = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(authOptions) {
    var provider, _authOptions$redirect, redirectTo, manifestPath, onFinish, onCancel, _authOptions$sendToSi, sendToSignIn, _userSession, appDetails, userSession, transitKey, authRequest, authResponse, token, payload, authResponsePayload;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          provider = getStacksProvider();
          if (provider) {
            _context.next = 3;
            break;
          }
          throw new Error("Unable to authenticate without Hiro Wallet extension");
        case 3:
          _authOptions$redirect = authOptions.redirectTo, redirectTo = _authOptions$redirect === void 0 ? "/" : _authOptions$redirect, manifestPath = authOptions.manifestPath, onFinish = authOptions.onFinish, onCancel = authOptions.onCancel, _authOptions$sendToSi = authOptions.sendToSignIn, sendToSignIn = _authOptions$sendToSi === void 0 ? false : _authOptions$sendToSi, _userSession = authOptions.userSession, appDetails = authOptions.appDetails;
          userSession = getOrCreateUserSession(_userSession);
          if (userSession.isUserSignedIn()) {
            userSession.signUserOut();
          }
          transitKey = userSession.generateAndStoreTransitKey();
          authRequest = userSession.makeAuthRequest(transitKey, "" + document.location.origin + redirectTo, "" + document.location.origin + manifestPath, userSession.appConfig.scopes, void 0, void 0, {
            sendToSignIn: sendToSignIn,
            appDetails: appDetails,
            connectVersion: version
          });
          _context.prev = 8;
          _context.next = 11;
          return provider.authenticationRequest(authRequest);
        case 11:
          authResponse = _context.sent;
          _context.next = 14;
          return userSession.handlePendingSignIn(authResponse);
        case 14:
          token = jsontokens.decodeToken(authResponse);
          payload = token == null ? void 0 : token.payload;
          authResponsePayload = payload;
          onFinish == null ? void 0 : onFinish({
            authResponse: authResponse,
            authResponsePayload: authResponsePayload,
            userSession: userSession
          });
          _context.next = 24;
          break;
        case 20:
          _context.prev = 20;
          _context.t0 = _context["catch"](8);
          console.error("[Connect] Error during auth request", _context.t0);
          onCancel == null ? void 0 : onCancel();
        case 24:
        case "end":
          return _context.stop();
      }
    }, _callee, null, [[8, 20]]);
  }));
  return function authenticate(_x) {
    return _ref.apply(this, arguments);
  };
}();
var getUserData = /*#__PURE__*/function () {
  var _ref2 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(userSession) {
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          userSession = getOrCreateUserSession(userSession);
          if (!userSession.isUserSignedIn()) {
            _context2.next = 3;
            break;
          }
          return _context2.abrupt("return", userSession.loadUserData());
        case 3:
          if (!userSession.isSignInPending()) {
            _context2.next = 5;
            break;
          }
          return _context2.abrupt("return", userSession.handlePendingSignIn());
        case 5:
          return _context2.abrupt("return", null);
        case 6:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return function getUserData(_x2) {
    return _ref2.apply(this, arguments);
  };
}();

(function (TransactionTypes2) {
  TransactionTypes2["ContractCall"] = "contract_call";
  TransactionTypes2["ContractDeploy"] = "smart_contract";
  TransactionTypes2["STXTransfer"] = "token_transfer";
})(exports.TransactionTypes || (exports.TransactionTypes = {}));
(function (ContractCallArgumentType2) {
  ContractCallArgumentType2["BUFFER"] = "buffer";
  ContractCallArgumentType2["UINT"] = "uint";
  ContractCallArgumentType2["INT"] = "int";
  ContractCallArgumentType2["PRINCIPAL"] = "principal";
  ContractCallArgumentType2["BOOL"] = "bool";
})(exports.ContractCallArgumentType || (exports.ContractCallArgumentType = {}));

var _excluded = ["functionArgs", "appDetails", "userSession"],
  _excluded2 = ["appDetails", "userSession"],
  _excluded3 = ["amount", "appDetails", "userSession"];
var getUserSession = function getUserSession(_userSession) {
  var userSession = _userSession;
  if (!userSession) {
    var appConfig = new auth.AppConfig(["store_write"], document.location.href);
    userSession = new auth.UserSession({
      appConfig: appConfig
    });
  }
  return userSession;
};
function hasAppPrivateKey(userSession) {
  try {
    var session = getUserSession(userSession).loadUserData();
    return session.appPrivateKey;
  } catch (e) {
    return false;
  }
}
var getKeys = function getKeys(_userSession) {
  var userSession = getUserSession(_userSession);
  var privateKey = userSession.loadUserData().appPrivateKey;
  var publicKey = jsontokens.SECP256K1Client.derivePublicKey(privateKey);
  return {
    privateKey: privateKey,
    publicKey: publicKey
  };
};
function getStxAddress(options) {
  var _userSession$loadUser, _chainIdToKey;
  var stxAddress = options.stxAddress,
    userSession = options.userSession,
    network = options.network;
  if (stxAddress) return stxAddress;
  if (!userSession || !network) return void 0;
  var stxAddresses = userSession == null ? void 0 : (_userSession$loadUser = userSession.loadUserData().profile) == null ? void 0 : _userSession$loadUser.stxAddress;
  var chainIdToKey = (_chainIdToKey = {}, _chainIdToKey[transactions.ChainID.Mainnet] = "mainnet", _chainIdToKey[transactions.ChainID.Testnet] = "testnet", _chainIdToKey);
  var address = stxAddresses == null ? void 0 : stxAddresses[chainIdToKey[network.chainId]];
  return address;
}
function getDefaults(options) {
  var network$1 = options.network || new network.StacksTestnet();
  var userSession = getUserSession(options.userSession);
  var defaults = _extends({}, options, {
    network: network$1,
    userSession: userSession
  });
  return _extends({
    stxAddress: getStxAddress(defaults)
  }, defaults);
}
function encodePostConditions(postConditions) {
  return postConditions.map(function (pc) {
    return common.bytesToHex(transactions.serializePostCondition(pc));
  });
}
function signPayload(_x, _x2) {
  return _signPayload.apply(this, arguments);
}
function _signPayload() {
  _signPayload = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(payload, privateKey) {
    var postConditions, tokenSigner;
    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) switch (_context5.prev = _context5.next) {
        case 0:
          postConditions = payload.postConditions;
          if (postConditions && typeof postConditions[0] !== "string") {
            postConditions = encodePostConditions(postConditions);
          }
          tokenSigner = new jsontokens.TokenSigner("ES256k", privateKey);
          return _context5.abrupt("return", tokenSigner.signAsync(_extends({}, payload, {
            postConditions: postConditions
          })));
        case 4:
        case "end":
          return _context5.stop();
      }
    }, _callee5);
  }));
  return _signPayload.apply(this, arguments);
}
function createUnsignedTransactionPayload(payload) {
  var postConditions = payload.postConditions;
  if (postConditions && typeof postConditions[0] !== "string") {
    postConditions = encodePostConditions(postConditions);
  }
  return jsontokens.createUnsecuredToken(_extends({}, payload, {
    postConditions: postConditions
  }));
}
var openTransactionPopup = /*#__PURE__*/function () {
  var _ref2 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {
    var token, options, provider, txResponse, txRaw, txBytes, stacksTransaction;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          token = _ref.token, options = _ref.options;
          provider = getStacksProvider();
          if (provider) {
            _context.next = 4;
            break;
          }
          throw new Error("Hiro Wallet not installed");
        case 4:
          _context.prev = 4;
          _context.next = 7;
          return provider.transactionRequest(token);
        case 7:
          txResponse = _context.sent;
          txRaw = txResponse.txRaw;
          txBytes = common.hexToBytes(txRaw.replace(/^0x/, ""));
          stacksTransaction = transactions.deserializeTransaction(txBytes);
          if (!("sponsored" in options && options.sponsored)) {
            _context.next = 14;
            break;
          }
          options.onFinish == null ? void 0 : options.onFinish(_extends({}, txResponse, {
            stacksTransaction: stacksTransaction
          }));
          return _context.abrupt("return");
        case 14:
          options.onFinish == null ? void 0 : options.onFinish(_extends({}, txResponse, {
            stacksTransaction: stacksTransaction
          }));
          _context.next = 21;
          break;
        case 17:
          _context.prev = 17;
          _context.t0 = _context["catch"](4);
          console.error("[Connect] Error during transaction request", _context.t0);
          options.onCancel == null ? void 0 : options.onCancel();
        case 21:
        case "end":
          return _context.stop();
      }
    }, _callee, null, [[4, 17]]);
  }));
  return function openTransactionPopup(_x3) {
    return _ref2.apply(this, arguments);
  };
}();
var makeContractCallToken = /*#__PURE__*/function () {
  var _ref3 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(options) {
    var functionArgs, appDetails, userSession, _options, args, _getKeys, privateKey, publicKey, payload2, payload;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          functionArgs = options.functionArgs, appDetails = options.appDetails, userSession = options.userSession, _options = _objectWithoutPropertiesLoose(options, _excluded);
          args = functionArgs.map(function (arg) {
            if (typeof arg === "string") {
              return arg;
            }
            return common.bytesToHex(transactions.serializeCV(arg));
          });
          if (!hasAppPrivateKey(userSession)) {
            _context2.next = 7;
            break;
          }
          _getKeys = getKeys(userSession), privateKey = _getKeys.privateKey, publicKey = _getKeys.publicKey;
          payload2 = _extends({}, _options, {
            functionArgs: args,
            txType: exports.TransactionTypes.ContractCall,
            publicKey: publicKey
          });
          if (appDetails) payload2.appDetails = appDetails;
          return _context2.abrupt("return", signPayload(payload2, privateKey));
        case 7:
          payload = _extends({}, _options, {
            functionArgs: args,
            txType: exports.TransactionTypes.ContractCall
          });
          if (appDetails) payload.appDetails = appDetails;
          return _context2.abrupt("return", createUnsignedTransactionPayload(payload));
        case 10:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return function makeContractCallToken(_x4) {
    return _ref3.apply(this, arguments);
  };
}();
var makeContractDeployToken = /*#__PURE__*/function () {
  var _ref4 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(options) {
    var appDetails, userSession, _options, _getKeys2, privateKey, publicKey, payload2, payload;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          appDetails = options.appDetails, userSession = options.userSession, _options = _objectWithoutPropertiesLoose(options, _excluded2);
          if (!hasAppPrivateKey(userSession)) {
            _context3.next = 6;
            break;
          }
          _getKeys2 = getKeys(userSession), privateKey = _getKeys2.privateKey, publicKey = _getKeys2.publicKey;
          payload2 = _extends({}, _options, {
            publicKey: publicKey,
            txType: exports.TransactionTypes.ContractDeploy
          });
          if (appDetails) payload2.appDetails = appDetails;
          return _context3.abrupt("return", signPayload(payload2, privateKey));
        case 6:
          payload = _extends({}, _options, {
            txType: exports.TransactionTypes.ContractDeploy
          });
          if (appDetails) payload.appDetails = appDetails;
          return _context3.abrupt("return", createUnsignedTransactionPayload(payload));
        case 9:
        case "end":
          return _context3.stop();
      }
    }, _callee3);
  }));
  return function makeContractDeployToken(_x5) {
    return _ref4.apply(this, arguments);
  };
}();
var makeSTXTransferToken = /*#__PURE__*/function () {
  var _ref5 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(options) {
    var amount, appDetails, userSession, _options, _getKeys3, privateKey, publicKey, payload2, payload;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) switch (_context4.prev = _context4.next) {
        case 0:
          amount = options.amount, appDetails = options.appDetails, userSession = options.userSession, _options = _objectWithoutPropertiesLoose(options, _excluded3);
          if (!hasAppPrivateKey(userSession)) {
            _context4.next = 6;
            break;
          }
          _getKeys3 = getKeys(userSession), privateKey = _getKeys3.privateKey, publicKey = _getKeys3.publicKey;
          payload2 = _extends({}, _options, {
            amount: amount.toString(10),
            publicKey: publicKey,
            txType: exports.TransactionTypes.STXTransfer
          });
          if (appDetails) payload2.appDetails = appDetails;
          return _context4.abrupt("return", signPayload(payload2, privateKey));
        case 6:
          payload = _extends({}, _options, {
            amount: amount.toString(10),
            txType: exports.TransactionTypes.STXTransfer
          });
          if (appDetails) payload.appDetails = appDetails;
          return _context4.abrupt("return", createUnsignedTransactionPayload(payload));
        case 9:
        case "end":
          return _context4.stop();
      }
    }, _callee4);
  }));
  return function makeSTXTransferToken(_x6) {
    return _ref5.apply(this, arguments);
  };
}();
function generateTokenAndOpenPopup(_x7, _x8) {
  return _generateTokenAndOpenPopup.apply(this, arguments);
}
function _generateTokenAndOpenPopup() {
  _generateTokenAndOpenPopup = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(options, makeTokenFn) {
    var token;
    return _regeneratorRuntime().wrap(function _callee6$(_context6) {
      while (1) switch (_context6.prev = _context6.next) {
        case 0:
          _context6.next = 2;
          return makeTokenFn(_extends({}, getDefaults(options), options));
        case 2:
          token = _context6.sent;
          return _context6.abrupt("return", openTransactionPopup({
            token: token,
            options: options
          }));
        case 4:
        case "end":
          return _context6.stop();
      }
    }, _callee6);
  }));
  return _generateTokenAndOpenPopup.apply(this, arguments);
}
function openContractCall(options) {
  return generateTokenAndOpenPopup(options, makeContractCallToken);
}
function openContractDeploy(options) {
  return generateTokenAndOpenPopup(options, makeContractDeployToken);
}
function openSTXTransfer(options) {
  return generateTokenAndOpenPopup(options, makeSTXTransferToken);
}

var _excluded$1 = ["allowedSighash", "hex", "signAtIndex", "userSession"];
function signPayload$1(_x, _x2) {
  return _signPayload$1.apply(this, arguments);
}
function _signPayload$1() {
  _signPayload$1 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(payload, privateKey) {
    var tokenSigner;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          tokenSigner = new jsontokens.TokenSigner("ES256k", privateKey);
          return _context2.abrupt("return", tokenSigner.signAsync(_extends({}, payload)));
        case 2:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return _signPayload$1.apply(this, arguments);
}
function getDefaultPsbtRequestOptions(options) {
  var network$1 = options.network || new network.StacksTestnet();
  var userSession = getUserSession(options.userSession);
  var defaults = _extends({}, options, {
    network: network$1,
    userSession: userSession
  });
  return _extends({}, defaults);
}
function openPsbtPopup(_x3) {
  return _openPsbtPopup.apply(this, arguments);
}
function _openPsbtPopup() {
  _openPsbtPopup = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(_ref) {
    var token, options, provider, psbtResponse;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          token = _ref.token, options = _ref.options;
          provider = getStacksProvider();
          if (provider) {
            _context3.next = 4;
            break;
          }
          throw new Error("Hiro Wallet not installed");
        case 4:
          _context3.prev = 4;
          _context3.next = 7;
          return provider.psbtRequest(token);
        case 7:
          psbtResponse = _context3.sent;
          options.onFinish == null ? void 0 : options.onFinish(psbtResponse);
          _context3.next = 15;
          break;
        case 11:
          _context3.prev = 11;
          _context3.t0 = _context3["catch"](4);
          console.error("[Connect] Error during psbt request", _context3.t0);
          options.onCancel == null ? void 0 : options.onCancel();
        case 15:
        case "end":
          return _context3.stop();
      }
    }, _callee3, null, [[4, 11]]);
  }));
  return _openPsbtPopup.apply(this, arguments);
}
var makePsbtToken = /*#__PURE__*/function () {
  var _ref2 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(options) {
    var allowedSighash, hex, signAtIndex, userSession, _options, _getKeys, privateKey, publicKey, payload2, payload;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          allowedSighash = options.allowedSighash, hex = options.hex, signAtIndex = options.signAtIndex, userSession = options.userSession, _options = _objectWithoutPropertiesLoose(options, _excluded$1);
          if (!hasAppPrivateKey(userSession)) {
            _context.next = 5;
            break;
          }
          _getKeys = getKeys(userSession), privateKey = _getKeys.privateKey, publicKey = _getKeys.publicKey;
          payload2 = _extends({}, _options, {
            allowedSighash: allowedSighash,
            hex: hex,
            signAtIndex: signAtIndex,
            publicKey: publicKey
          });
          return _context.abrupt("return", signPayload$1(payload2, privateKey));
        case 5:
          payload = _extends({}, _options);
          return _context.abrupt("return", jsontokens.createUnsecuredToken(payload));
        case 7:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function makePsbtToken(_x4) {
    return _ref2.apply(this, arguments);
  };
}();
function generateTokenAndOpenPopup$1(_x5, _x6) {
  return _generateTokenAndOpenPopup$1.apply(this, arguments);
}
function _generateTokenAndOpenPopup$1() {
  _generateTokenAndOpenPopup$1 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(options, makeTokenFn) {
    var token;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) switch (_context4.prev = _context4.next) {
        case 0:
          _context4.next = 2;
          return makeTokenFn(_extends({}, getDefaultPsbtRequestOptions(options), options));
        case 2:
          token = _context4.sent;
          return _context4.abrupt("return", openPsbtPopup({
            token: token,
            options: options
          }));
        case 4:
        case "end":
          return _context4.stop();
      }
    }, _callee4);
  }));
  return _generateTokenAndOpenPopup$1.apply(this, arguments);
}
function openPsbtRequestPopup(options) {
  return generateTokenAndOpenPopup$1(options, makePsbtToken);
}

var _excluded$2 = ["userSession"];
function getStxAddress$1(options) {
  var _userSession$loadUser, _chainIdToKey;
  var userSession = options.userSession,
    network = options.network;
  if (!userSession || !network) return void 0;
  var stxAddresses = userSession == null ? void 0 : (_userSession$loadUser = userSession.loadUserData().profile) == null ? void 0 : _userSession$loadUser.stxAddress;
  var chainIdToKey = (_chainIdToKey = {}, _chainIdToKey[transactions.ChainID.Mainnet] = "mainnet", _chainIdToKey[transactions.ChainID.Testnet] = "testnet", _chainIdToKey);
  var address = stxAddresses == null ? void 0 : stxAddresses[chainIdToKey[network.chainId]];
  return address;
}
function signPayload$2(_x, _x2) {
  return _signPayload$2.apply(this, arguments);
}
function _signPayload$2() {
  _signPayload$2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(payload, privateKey) {
    var tokenSigner;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          tokenSigner = new jsontokens.TokenSigner("ES256k", privateKey);
          return _context2.abrupt("return", tokenSigner.signAsync(_extends({}, payload)));
        case 2:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return _signPayload$2.apply(this, arguments);
}
function getDefaultSignatureRequestOptions(options) {
  var network$1 = options.network || new network.StacksTestnet();
  var userSession = getUserSession(options.userSession);
  var defaults = _extends({}, options, {
    network: network$1,
    userSession: userSession
  });
  return _extends({
    stxAddress: getStxAddress$1(defaults)
  }, defaults);
}
function openSignaturePopup(_x3) {
  return _openSignaturePopup.apply(this, arguments);
}
function _openSignaturePopup() {
  _openSignaturePopup = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(_ref) {
    var token, options, provider, signatureResponse;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          token = _ref.token, options = _ref.options;
          provider = getStacksProvider();
          if (provider) {
            _context3.next = 4;
            break;
          }
          throw new Error("Hiro Wallet not installed.");
        case 4:
          _context3.prev = 4;
          _context3.next = 7;
          return provider.signatureRequest(token);
        case 7:
          signatureResponse = _context3.sent;
          options.onFinish == null ? void 0 : options.onFinish(signatureResponse);
          _context3.next = 15;
          break;
        case 11:
          _context3.prev = 11;
          _context3.t0 = _context3["catch"](4);
          console.error("[Connect] Error during signature request", _context3.t0);
          options.onCancel == null ? void 0 : options.onCancel();
        case 15:
        case "end":
          return _context3.stop();
      }
    }, _callee3, null, [[4, 11]]);
  }));
  return _openSignaturePopup.apply(this, arguments);
}
var signMessage = /*#__PURE__*/function () {
  var _ref2 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(options) {
    var userSession, _options, _getKeys, privateKey, publicKey, payload2, payload;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          userSession = options.userSession, _options = _objectWithoutPropertiesLoose(options, _excluded$2);
          if (!hasAppPrivateKey(userSession)) {
            _context.next = 5;
            break;
          }
          _getKeys = getKeys(userSession), privateKey = _getKeys.privateKey, publicKey = _getKeys.publicKey;
          payload2 = _extends({}, _options, {
            publicKey: publicKey
          });
          return _context.abrupt("return", signPayload$2(payload2, privateKey));
        case 5:
          payload = _extends({}, _options);
          return _context.abrupt("return", jsontokens.createUnsecuredToken(payload));
        case 7:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function signMessage(_x4) {
    return _ref2.apply(this, arguments);
  };
}();
function generateTokenAndOpenPopup$2(_x5, _x6) {
  return _generateTokenAndOpenPopup$2.apply(this, arguments);
}
function _generateTokenAndOpenPopup$2() {
  _generateTokenAndOpenPopup$2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(options, makeTokenFn) {
    var token;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) switch (_context4.prev = _context4.next) {
        case 0:
          _context4.next = 2;
          return makeTokenFn(_extends({}, getDefaultSignatureRequestOptions(options), options));
        case 2:
          token = _context4.sent;
          return _context4.abrupt("return", openSignaturePopup({
            token: token,
            options: options
          }));
        case 4:
        case "end":
          return _context4.stop();
      }
    }, _callee4);
  }));
  return _generateTokenAndOpenPopup$2.apply(this, arguments);
}
function openSignatureRequestPopup(options) {
  return generateTokenAndOpenPopup$2(options, signMessage);
}

var _excluded$3 = ["userSession"];
function generateTokenAndOpenPopup$3(_x, _x2) {
  return _generateTokenAndOpenPopup$3.apply(this, arguments);
}
function _generateTokenAndOpenPopup$3() {
  _generateTokenAndOpenPopup$3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(options, makeTokenFn) {
    var token;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return makeTokenFn(_extends({}, getDefaultSignatureRequestOptions(options), options));
        case 2:
          token = _context.sent;
          return _context.abrupt("return", openStructuredDataSignaturePopup({
            token: token,
            options: options
          }));
        case 4:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _generateTokenAndOpenPopup$3.apply(this, arguments);
}
function parseUnserializableBigIntValues(payload) {
  return _extends({}, payload, {
    message: common.bytesToHex(transactions.serializeCV(payload.message)),
    domain: common.bytesToHex(transactions.serializeCV(payload.domain))
  });
}
function signPayload$3(_x3, _x4) {
  return _signPayload$3.apply(this, arguments);
}
function _signPayload$3() {
  _signPayload$3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(payload, privateKey) {
    var tokenSigner;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          tokenSigner = new jsontokens.TokenSigner("ES256k", privateKey);
          return _context2.abrupt("return", tokenSigner.signAsync(parseUnserializableBigIntValues(payload)));
        case 2:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return _signPayload$3.apply(this, arguments);
}
function signStructuredMessage(_x5) {
  return _signStructuredMessage.apply(this, arguments);
}
function _signStructuredMessage() {
  _signStructuredMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(options) {
    var userSession, _options, _getKeys, privateKey, publicKey, payload;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          userSession = options.userSession, _options = _objectWithoutPropertiesLoose(options, _excluded$3);
          if (!hasAppPrivateKey(userSession)) {
            _context3.next = 5;
            break;
          }
          _getKeys = getKeys(userSession), privateKey = _getKeys.privateKey, publicKey = _getKeys.publicKey;
          payload = _extends({}, _options, {
            publicKey: publicKey
          });
          return _context3.abrupt("return", signPayload$3(payload, privateKey));
        case 5:
          return _context3.abrupt("return", jsontokens.createUnsecuredToken(parseUnserializableBigIntValues(options)));
        case 6:
        case "end":
          return _context3.stop();
      }
    }, _callee3);
  }));
  return _signStructuredMessage.apply(this, arguments);
}
function openStructuredDataSignaturePopup(_x6) {
  return _openStructuredDataSignaturePopup.apply(this, arguments);
}
function _openStructuredDataSignaturePopup() {
  _openStructuredDataSignaturePopup = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(_ref) {
    var token, options, provider, signatureResponse;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) switch (_context4.prev = _context4.next) {
        case 0:
          token = _ref.token, options = _ref.options;
          provider = getStacksProvider();
          if (provider) {
            _context4.next = 4;
            break;
          }
          throw new Error("Hiro Wallet not installed.");
        case 4:
          _context4.prev = 4;
          _context4.next = 7;
          return provider.structuredDataSignatureRequest(token);
        case 7:
          signatureResponse = _context4.sent;
          options.onFinish == null ? void 0 : options.onFinish(signatureResponse);
          _context4.next = 15;
          break;
        case 11:
          _context4.prev = 11;
          _context4.t0 = _context4["catch"](4);
          console.error("[Connect] Error during signature request", _context4.t0);
          options.onCancel == null ? void 0 : options.onCancel();
        case 15:
        case "end":
          return _context4.stop();
      }
    }, _callee4, null, [[4, 11]]);
  }));
  return _openStructuredDataSignaturePopup.apply(this, arguments);
}
function openStructuredDataSignatureRequestPopup(options) {
  return generateTokenAndOpenPopup$3(options, signStructuredMessage);
}

var _excluded$4 = ["userSession", "profile"];
function signPayload$4(_x, _x2) {
  return _signPayload$4.apply(this, arguments);
}
function _signPayload$4() {
  _signPayload$4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(payload, privateKey) {
    var tokenSigner;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          tokenSigner = new jsontokens.TokenSigner("ES256k", privateKey);
          return _context2.abrupt("return", tokenSigner.signAsync(_extends({}, payload)));
        case 2:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return _signPayload$4.apply(this, arguments);
}
function getDefaultProfileUpdateRequestOptions(options) {
  var network$1 = options.network || new network.StacksTestnet();
  var userSession = getUserSession(options.userSession);
  var defaults = _extends({}, options, {
    network: network$1,
    userSession: userSession
  });
  return _extends({}, defaults);
}
function openProfileUpdatePopup(_x3) {
  return _openProfileUpdatePopup.apply(this, arguments);
}
function _openProfileUpdatePopup() {
  _openProfileUpdatePopup = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(_ref) {
    var token, options, provider, profileUpdateResponse;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          token = _ref.token, options = _ref.options;
          provider = getStacksProvider();
          if (provider) {
            _context3.next = 4;
            break;
          }
          throw new Error("Hiro Wallet not installed.");
        case 4:
          _context3.prev = 4;
          _context3.next = 7;
          return provider.profileUpdateRequest(token);
        case 7:
          profileUpdateResponse = _context3.sent;
          options.onFinish == null ? void 0 : options.onFinish(profileUpdateResponse);
          _context3.next = 15;
          break;
        case 11:
          _context3.prev = 11;
          _context3.t0 = _context3["catch"](4);
          console.error("[Connect] Error during signature request", _context3.t0);
          options.onCancel == null ? void 0 : options.onCancel();
        case 15:
        case "end":
          return _context3.stop();
      }
    }, _callee3, null, [[4, 11]]);
  }));
  return _openProfileUpdatePopup.apply(this, arguments);
}
var makeProfileUpdateToken = /*#__PURE__*/function () {
  var _ref2 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(options) {
    var userSession, profile, _options, _getKeys, privateKey, publicKey, payload2, payload;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          userSession = options.userSession, profile = options.profile, _options = _objectWithoutPropertiesLoose(options, _excluded$4);
          if (!hasAppPrivateKey(userSession)) {
            _context.next = 5;
            break;
          }
          _getKeys = getKeys(userSession), privateKey = _getKeys.privateKey, publicKey = _getKeys.publicKey;
          payload2 = _extends({}, _options, {
            profile: profile,
            publicKey: publicKey
          });
          return _context.abrupt("return", signPayload$4(payload2, privateKey));
        case 5:
          payload = _extends({}, _options);
          return _context.abrupt("return", jsontokens.createUnsecuredToken(payload));
        case 7:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function makeProfileUpdateToken(_x4) {
    return _ref2.apply(this, arguments);
  };
}();
function generateTokenAndOpenPopup$4(_x5, _x6) {
  return _generateTokenAndOpenPopup$4.apply(this, arguments);
}
function _generateTokenAndOpenPopup$4() {
  _generateTokenAndOpenPopup$4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(options, makeTokenFn) {
    var token;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) switch (_context4.prev = _context4.next) {
        case 0:
          _context4.next = 2;
          return makeTokenFn(_extends({}, getDefaultProfileUpdateRequestOptions(options), options));
        case 2:
          token = _context4.sent;
          return _context4.abrupt("return", openProfileUpdatePopup({
            token: token,
            options: options
          }));
        case 4:
        case "end":
          return _context4.stop();
      }
    }, _callee4);
  }));
  return _generateTokenAndOpenPopup$4.apply(this, arguments);
}
function openProfileUpdateRequestPopup(options) {
  return generateTokenAndOpenPopup$4(options, makeProfileUpdateToken);
}

(function (SignatureHash2) {
  SignatureHash2[SignatureHash2["DEFAULT"] = 0] = "DEFAULT";
  SignatureHash2[SignatureHash2["ALL"] = 1] = "ALL";
  SignatureHash2[SignatureHash2["NONE"] = 2] = "NONE";
  SignatureHash2[SignatureHash2["SINGLE"] = 3] = "SINGLE";
  SignatureHash2[SignatureHash2["ANYONECANPAY"] = 128] = "ANYONECANPAY";
})(exports.SignatureHash || (exports.SignatureHash = {}));

var showConnect = function showConnect(authOptions) {
  if (getStacksProvider()) {
    void authenticate(authOptions);
    return;
  }
  if (typeof window !== void 0) {
    void loader.defineCustomElements(window);
    var element = document.createElement("connect-modal");
    element.authOptions = authOptions;
    document.body.appendChild(element);
    var handleEsc = function handleEsc(ev) {
      if (ev.key === "Escape") {
        document.removeEventListener("keydown", handleEsc);
        element.remove();
      }
    };
    document.addEventListener("keydown", handleEsc);
  }
};
var showBlockstackConnect = function showBlockstackConnect(authOptions) {
  return showConnect(authOptions);
};

Object.keys(auth).forEach(function (k) {
  if (k !== 'default') Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () {
      return auth[k];
    }
  });
});
exports.authenticate = authenticate;
exports.defaultAuthURL = defaultAuthURL;
exports.getDefaultProfileUpdateRequestOptions = getDefaultProfileUpdateRequestOptions;
exports.getDefaultPsbtRequestOptions = getDefaultPsbtRequestOptions;
exports.getDefaultSignatureRequestOptions = getDefaultSignatureRequestOptions;
exports.getKeys = getKeys;
exports.getOrCreateUserSession = getOrCreateUserSession;
exports.getStacksProvider = getStacksProvider;
exports.getStxAddress = getStxAddress;
exports.getUserData = getUserData;
exports.getUserSession = getUserSession;
exports.hasAppPrivateKey = hasAppPrivateKey;
exports.isMobile = isMobile;
exports.isStacksWalletInstalled = isStacksWalletInstalled;
exports.makeContractCallToken = makeContractCallToken;
exports.makeContractDeployToken = makeContractDeployToken;
exports.makeProfileUpdateToken = makeProfileUpdateToken;
exports.makePsbtToken = makePsbtToken;
exports.makeSTXTransferToken = makeSTXTransferToken;
exports.openContractCall = openContractCall;
exports.openContractDeploy = openContractDeploy;
exports.openProfileUpdateRequestPopup = openProfileUpdateRequestPopup;
exports.openPsbtRequestPopup = openPsbtRequestPopup;
exports.openSTXTransfer = openSTXTransfer;
exports.openSignatureRequestPopup = openSignatureRequestPopup;
exports.openStructuredDataSignatureRequestPopup = openStructuredDataSignatureRequestPopup;
exports.shouldUsePopup = shouldUsePopup;
exports.showBlockstackConnect = showBlockstackConnect;
exports.showConnect = showConnect;
exports.signMessage = signMessage;
exports.signStructuredMessage = signStructuredMessage;


},{"@stacks/auth":22,"@stacks/common":36,"@stacks/connect-ui/loader":44,"@stacks/network":63,"@stacks/transactions":93,"jsontokens":121}],46:[function(require,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("@stacks/auth"),t=require("jsontokens"),n=require("@stacks/network"),r=require("@stacks/common"),o=require("@stacks/transactions"),a=require("@stacks/connect-ui/loader");function i(){i=function(){return e};var e={},t=Object.prototype,n=t.hasOwnProperty,r=Object.defineProperty||function(e,t,n){e[t]=n.value},o="function"==typeof Symbol?Symbol:{},a=o.iterator||"@@iterator",s=o.asyncIterator||"@@asyncIterator",u=o.toStringTag||"@@toStringTag";function c(e,t,n){return Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}),e[t]}try{c({},"")}catch(e){c=function(e,t,n){return e[t]=n}}function p(e,t,n,o){var a=Object.create((t&&t.prototype instanceof h?t:h).prototype),i=new E(o||[]);return r(a,"_invoke",{value:m(e,n,i)}),a}function l(e,t,n){try{return{type:"normal",arg:e.call(t,n)}}catch(e){return{type:"throw",arg:e}}}e.wrap=p;var f={};function h(){}function d(){}function v(){}var y={};c(y,a,(function(){return this}));var x=Object.getPrototypeOf,w=x&&x(x(P([])));w&&w!==t&&n.call(w,a)&&(y=w);var g=v.prototype=h.prototype=Object.create(y);function k(e){["next","throw","return"].forEach((function(t){c(e,t,(function(e){return this._invoke(t,e)}))}))}function b(e,t){var o;r(this,"_invoke",{value:function(r,a){function i(){return new t((function(o,i){!function r(o,a,i,s){var u=l(e[o],e,a);if("throw"!==u.type){var c=u.arg,p=c.value;return p&&"object"==typeof p&&n.call(p,"__await")?t.resolve(p.__await).then((function(e){r("next",e,i,s)}),(function(e){r("throw",e,i,s)})):t.resolve(p).then((function(e){c.value=e,i(c)}),(function(e){return r("throw",e,i,s)}))}s(u.arg)}(r,a,o,i)}))}return o=o?o.then(i,i):i()}})}function m(e,t,n){var r="suspendedStart";return function(o,a){if("executing"===r)throw new Error("Generator is already running");if("completed"===r){if("throw"===o)throw a;return{value:void 0,done:!0}}for(n.method=o,n.arg=a;;){var i=n.delegate;if(i){var s=S(i,n);if(s){if(s===f)continue;return s}}if("next"===n.method)n.sent=n._sent=n.arg;else if("throw"===n.method){if("suspendedStart"===r)throw r="completed",n.arg;n.dispatchException(n.arg)}else"return"===n.method&&n.abrupt("return",n.arg);r="executing";var u=l(e,t,n);if("normal"===u.type){if(r=n.done?"completed":"suspendedYield",u.arg===f)continue;return{value:u.arg,done:n.done}}"throw"===u.type&&(r="completed",n.method="throw",n.arg=u.arg)}}}function S(e,t){var n=t.method,r=e.iterator[n];if(void 0===r)return t.delegate=null,"throw"===n&&e.iterator.return&&(t.method="return",t.arg=void 0,S(e,t),"throw"===t.method)||"return"!==n&&(t.method="throw",t.arg=new TypeError("The iterator does not provide a '"+n+"' method")),f;var o=l(r,e.iterator,t.arg);if("throw"===o.type)return t.method="throw",t.arg=o.arg,t.delegate=null,f;var a=o.arg;return a?a.done?(t[e.resultName]=a.value,t.next=e.nextLoc,"return"!==t.method&&(t.method="next",t.arg=void 0),t.delegate=null,f):a:(t.method="throw",t.arg=new TypeError("iterator result is not an object"),t.delegate=null,f)}function T(e){var t={tryLoc:e[0]};1 in e&&(t.catchLoc=e[1]),2 in e&&(t.finallyLoc=e[2],t.afterLoc=e[3]),this.tryEntries.push(t)}function C(e){var t=e.completion||{};t.type="normal",delete t.arg,e.completion=t}function E(e){this.tryEntries=[{tryLoc:"root"}],e.forEach(T,this),this.reset(!0)}function P(e){if(e){var t=e[a];if(t)return t.call(e);if("function"==typeof e.next)return e;if(!isNaN(e.length)){var r=-1,o=function t(){for(;++r<e.length;)if(n.call(e,r))return t.value=e[r],t.done=!1,t;return t.value=void 0,t.done=!0,t};return o.next=o}}return{next:L}}function L(){return{value:void 0,done:!0}}return d.prototype=v,r(g,"constructor",{value:v,configurable:!0}),r(v,"constructor",{value:d,configurable:!0}),d.displayName=c(v,u,"GeneratorFunction"),e.isGeneratorFunction=function(e){var t="function"==typeof e&&e.constructor;return!!t&&(t===d||"GeneratorFunction"===(t.displayName||t.name))},e.mark=function(e){return Object.setPrototypeOf?Object.setPrototypeOf(e,v):(e.__proto__=v,c(e,u,"GeneratorFunction")),e.prototype=Object.create(g),e},e.awrap=function(e){return{__await:e}},k(b.prototype),c(b.prototype,s,(function(){return this})),e.AsyncIterator=b,e.async=function(t,n,r,o,a){void 0===a&&(a=Promise);var i=new b(p(t,n,r,o),a);return e.isGeneratorFunction(n)?i:i.next().then((function(e){return e.done?e.value:i.next()}))},k(g),c(g,u,"Generator"),c(g,a,(function(){return this})),c(g,"toString",(function(){return"[object Generator]"})),e.keys=function(e){var t=Object(e),n=[];for(var r in t)n.push(r);return n.reverse(),function e(){for(;n.length;){var r=n.pop();if(r in t)return e.value=r,e.done=!1,e}return e.done=!0,e}},e.values=P,E.prototype={constructor:E,reset:function(e){if(this.prev=0,this.next=0,this.sent=this._sent=void 0,this.done=!1,this.delegate=null,this.method="next",this.arg=void 0,this.tryEntries.forEach(C),!e)for(var t in this)"t"===t.charAt(0)&&n.call(this,t)&&!isNaN(+t.slice(1))&&(this[t]=void 0)},stop:function(){this.done=!0;var e=this.tryEntries[0].completion;if("throw"===e.type)throw e.arg;return this.rval},dispatchException:function(e){if(this.done)throw e;var t=this;function r(n,r){return i.type="throw",i.arg=e,t.next=n,r&&(t.method="next",t.arg=void 0),!!r}for(var o=this.tryEntries.length-1;o>=0;--o){var a=this.tryEntries[o],i=a.completion;if("root"===a.tryLoc)return r("end");if(a.tryLoc<=this.prev){var s=n.call(a,"catchLoc"),u=n.call(a,"finallyLoc");if(s&&u){if(this.prev<a.catchLoc)return r(a.catchLoc,!0);if(this.prev<a.finallyLoc)return r(a.finallyLoc)}else if(s){if(this.prev<a.catchLoc)return r(a.catchLoc,!0)}else{if(!u)throw new Error("try statement without catch or finally");if(this.prev<a.finallyLoc)return r(a.finallyLoc)}}}},abrupt:function(e,t){for(var r=this.tryEntries.length-1;r>=0;--r){var o=this.tryEntries[r];if(o.tryLoc<=this.prev&&n.call(o,"finallyLoc")&&this.prev<o.finallyLoc){var a=o;break}}a&&("break"===e||"continue"===e)&&a.tryLoc<=t&&t<=a.finallyLoc&&(a=null);var i=a?a.completion:{};return i.type=e,i.arg=t,a?(this.method="next",this.next=a.finallyLoc,f):this.complete(i)},complete:function(e,t){if("throw"===e.type)throw e.arg;return"break"===e.type||"continue"===e.type?this.next=e.arg:"return"===e.type?(this.rval=this.arg=e.arg,this.method="return",this.next="end"):"normal"===e.type&&t&&(this.next=t),f},finish:function(e){for(var t=this.tryEntries.length-1;t>=0;--t){var n=this.tryEntries[t];if(n.finallyLoc===e)return this.complete(n.completion,n.afterLoc),C(n),f}},catch:function(e){for(var t=this.tryEntries.length-1;t>=0;--t){var n=this.tryEntries[t];if(n.tryLoc===e){var r=n.completion;if("throw"===r.type){var o=r.arg;C(n)}return o}}throw new Error("illegal catch attempt")},delegateYield:function(e,t,n){return this.delegate={iterator:P(e),resultName:t,nextLoc:n},"next"===this.method&&(this.arg=void 0),f}},e}function s(e,t,n,r,o,a,i){try{var s=e[a](i),u=s.value}catch(e){return void n(e)}s.done?t(u):Promise.resolve(u).then(r,o)}function u(e){return function(){var t=this,n=arguments;return new Promise((function(r,o){var a=e.apply(t,n);function i(e){s(a,r,o,i,u,"next",e)}function u(e){s(a,r,o,i,u,"throw",e)}i(void 0)}))}}function c(){return(c=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e}).apply(this,arguments)}function p(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)t.indexOf(n=a[r])>=0||(o[n]=e[n]);return o}function l(){return window.StacksProvider||window.BlockstackProvider}"undefined"!=typeof window&&(window.__CONNECT_VERSION__="5.0.6-alpha.9d9606f.0");var f,h,d=function(){var e=navigator.userAgent;return!!/android/i.test(e)||!!/iPad|iPhone|iPod/.test(e)||/windows phone/i.test(e)},v=function(t){if(!t){var n=new e.AppConfig(["store_write"],document.location.href);t=new e.UserSession({appConfig:n})}return t},y=function(){var e=u(i().mark((function e(n){var r,o,a,s,u,c,p,f,h,d,y,x,w,g,k;return i().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:if(r=l()){e.next=3;break}throw new Error("Unable to authenticate without Hiro Wallet extension");case 3:return a=void 0===(o=n.redirectTo)?"/":o,s=n.manifestPath,u=n.onFinish,c=n.onCancel,f=void 0!==(p=n.sendToSignIn)&&p,h=n.appDetails,(d=v(n.userSession)).isUserSignedIn()&&d.signUserOut(),y=d.generateAndStoreTransitKey(),x=d.makeAuthRequest(y,""+document.location.origin+a,""+document.location.origin+s,d.appConfig.scopes,void 0,void 0,{sendToSignIn:f,appDetails:h,connectVersion:"5.0.6-alpha.9d9606f.0"}),e.prev=8,e.next=11,r.authenticationRequest(x);case 11:return w=e.sent,e.next=14,d.handlePendingSignIn(w);case 14:g=t.decodeToken(w),k=null==g?void 0:g.payload,null==u||u({authResponse:w,authResponsePayload:k,userSession:d}),e.next=24;break;case 20:e.prev=20,e.t0=e.catch(8),console.error("[Connect] Error during auth request",e.t0),null==c||c();case 24:case"end":return e.stop()}}),e,null,[[8,20]])})));return function(t){return e.apply(this,arguments)}}(),x=function(){var e=u(i().mark((function e(t){return i().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:if(!(t=v(t)).isUserSignedIn()){e.next=3;break}return e.abrupt("return",t.loadUserData());case 3:if(!t.isSignInPending()){e.next=5;break}return e.abrupt("return",t.handlePendingSignIn());case 5:return e.abrupt("return",null);case 6:case"end":return e.stop()}}),e)})));return function(t){return e.apply(this,arguments)}}();(f=exports.TransactionTypes||(exports.TransactionTypes={})).ContractCall="contract_call",f.ContractDeploy="smart_contract",f.STXTransfer="token_transfer",(h=exports.ContractCallArgumentType||(exports.ContractCallArgumentType={})).BUFFER="buffer",h.UINT="uint",h.INT="int",h.PRINCIPAL="principal",h.BOOL="bool";var w=["functionArgs","appDetails","userSession"],g=["appDetails","userSession"],k=["amount","appDetails","userSession"],b=function(t){var n=t;if(!n){var r=new e.AppConfig(["store_write"],document.location.href);n=new e.UserSession({appConfig:r})}return n};function m(e){try{return b(e).loadUserData().appPrivateKey}catch(e){return!1}}var S=function(e){var n=b(e).loadUserData().appPrivateKey;return{privateKey:n,publicKey:t.SECP256K1Client.derivePublicKey(n)}};function T(e){var t,n,r=e.stxAddress,a=e.userSession,i=e.network;if(r)return r;if(a&&i){var s=null==a||null==(t=a.loadUserData().profile)?void 0:t.stxAddress,u=((n={})[o.ChainID.Mainnet]="mainnet",n[o.ChainID.Testnet]="testnet",n);return null==s?void 0:s[u[i.chainId]]}}function C(e){var t=c({},e,{network:e.network||new n.StacksTestnet,userSession:b(e.userSession)});return c({stxAddress:T(t)},t)}function E(e){return e.map((function(e){return r.bytesToHex(o.serializePostCondition(e))}))}function P(e,t){return L.apply(this,arguments)}function L(){return(L=u(i().mark((function e(n,r){var o,a;return i().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return(o=n.postConditions)&&"string"!=typeof o[0]&&(o=E(o)),a=new t.TokenSigner("ES256k",r),e.abrupt("return",a.signAsync(c({},n,{postConditions:o})));case 4:case"end":return e.stop()}}),e)})))).apply(this,arguments)}function A(e){var n=e.postConditions;return n&&"string"!=typeof n[0]&&(n=E(n)),t.createUnsecuredToken(c({},e,{postConditions:n}))}var O=function(){var e=u(i().mark((function e(t){var n,a,s,u,p,f;return i().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:if(n=t.token,a=t.options,s=l()){e.next=4;break}throw new Error("Hiro Wallet not installed");case 4:return e.prev=4,e.next=7,s.transactionRequest(n);case 7:if(p=r.hexToBytes((u=e.sent).txRaw.replace(/^0x/,"")),f=o.deserializeTransaction(p),!("sponsored"in a)||!a.sponsored){e.next=14;break}return null==a.onFinish||a.onFinish(c({},u,{stacksTransaction:f})),e.abrupt("return");case 14:null==a.onFinish||a.onFinish(c({},u,{stacksTransaction:f})),e.next=21;break;case 17:e.prev=17,e.t0=e.catch(4),console.error("[Connect] Error during transaction request",e.t0),null==a.onCancel||a.onCancel();case 21:case"end":return e.stop()}}),e,null,[[4,17]])})));return function(t){return e.apply(this,arguments)}}(),D=function(){var e=u(i().mark((function e(t){var n,a,s,u,l,f,h,d,v;return i().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:if(n=t.functionArgs,a=t.appDetails,s=t.userSession,u=p(t,w),l=n.map((function(e){return"string"==typeof e?e:r.bytesToHex(o.serializeCV(e))})),!m(s)){e.next=7;break}return f=S(s),h=f.privateKey,d=c({},u,{functionArgs:l,txType:exports.TransactionTypes.ContractCall,publicKey:f.publicKey}),a&&(d.appDetails=a),e.abrupt("return",P(d,h));case 7:return v=c({},u,{functionArgs:l,txType:exports.TransactionTypes.ContractCall}),a&&(v.appDetails=a),e.abrupt("return",A(v));case 10:case"end":return e.stop()}}),e)})));return function(t){return e.apply(this,arguments)}}(),K=function(){var e=u(i().mark((function e(t){var n,r,o,a,s,u,l;return i().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:if(n=t.appDetails,r=t.userSession,o=p(t,g),!m(r)){e.next=6;break}return a=S(r),s=a.privateKey,u=c({},o,{publicKey:a.publicKey,txType:exports.TransactionTypes.ContractDeploy}),n&&(u.appDetails=n),e.abrupt("return",P(u,s));case 6:return l=c({},o,{txType:exports.TransactionTypes.ContractDeploy}),n&&(l.appDetails=n),e.abrupt("return",A(l));case 9:case"end":return e.stop()}}),e)})));return function(t){return e.apply(this,arguments)}}(),U=function(){var e=u(i().mark((function e(t){var n,r,o,a,s,u,l,f,h;return i().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:if(n=t.amount,r=t.appDetails,o=t.userSession,a=p(t,k),!m(o)){e.next=6;break}return s=S(o),u=s.privateKey,l=s.publicKey,f=c({},a,{amount:n.toString(10),publicKey:l,txType:exports.TransactionTypes.STXTransfer}),r&&(f.appDetails=r),e.abrupt("return",P(f,u));case 6:return h=c({},a,{amount:n.toString(10),txType:exports.TransactionTypes.STXTransfer}),r&&(h.appDetails=r),e.abrupt("return",A(h));case 9:case"end":return e.stop()}}),e)})));return function(t){return e.apply(this,arguments)}}();function I(e,t){return _.apply(this,arguments)}function _(){return(_=u(i().mark((function e(t,n){return i().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,n(c({},C(t),t));case 2:return e.abrupt("return",O({token:e.sent,options:t}));case 4:case"end":return e.stop()}}),e)})))).apply(this,arguments)}var q=["allowedSighash","hex","signAtIndex","userSession"];function N(e,t){return F.apply(this,arguments)}function F(){return(F=u(i().mark((function e(n,r){var o;return i().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return o=new t.TokenSigner("ES256k",r),e.abrupt("return",o.signAsync(c({},n)));case 2:case"end":return e.stop()}}),e)})))).apply(this,arguments)}function j(e){var t=c({},e,{network:e.network||new n.StacksTestnet,userSession:b(e.userSession)});return c({},t)}function R(e){return H.apply(this,arguments)}function H(){return(H=u(i().mark((function e(t){var n,r,o,a;return i().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:if(n=t.token,r=t.options,o=l()){e.next=4;break}throw new Error("Hiro Wallet not installed");case 4:return e.prev=4,e.next=7,o.psbtRequest(n);case 7:a=e.sent,null==r.onFinish||r.onFinish(a),e.next=15;break;case 11:e.prev=11,e.t0=e.catch(4),console.error("[Connect] Error during psbt request",e.t0),null==r.onCancel||r.onCancel();case 15:case"end":return e.stop()}}),e,null,[[4,11]])})))).apply(this,arguments)}var G=function(){var e=u(i().mark((function e(n){var r,o,a,s,u,l,f,h,d;return i().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:if(r=n.allowedSighash,o=n.hex,a=n.signAtIndex,s=n.userSession,u=p(n,q),!m(s)){e.next=5;break}return l=S(s),f=l.privateKey,h=c({},u,{allowedSighash:r,hex:o,signAtIndex:a,publicKey:l.publicKey}),e.abrupt("return",N(h,f));case 5:return d=c({},u),e.abrupt("return",t.createUnsecuredToken(d));case 7:case"end":return e.stop()}}),e)})));return function(t){return e.apply(this,arguments)}}();function W(){return(W=u(i().mark((function e(t,n){return i().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,n(c({},j(t),t));case 2:return e.abrupt("return",R({token:e.sent,options:t}));case 4:case"end":return e.stop()}}),e)})))).apply(this,arguments)}var M=["userSession"];function Y(e){var t,n,r=e.userSession,a=e.network;if(r&&a){var i=null==r||null==(t=r.loadUserData().profile)?void 0:t.stxAddress,s=((n={})[o.ChainID.Mainnet]="mainnet",n[o.ChainID.Testnet]="testnet",n);return null==i?void 0:i[s[a.chainId]]}}function z(e,t){return B.apply(this,arguments)}function B(){return(B=u(i().mark((function e(n,r){var o;return i().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return o=new t.TokenSigner("ES256k",r),e.abrupt("return",o.signAsync(c({},n)));case 2:case"end":return e.stop()}}),e)})))).apply(this,arguments)}function V(e){var t=c({},e,{network:e.network||new n.StacksTestnet,userSession:b(e.userSession)});return c({stxAddress:Y(t)},t)}function X(e){return J.apply(this,arguments)}function J(){return(J=u(i().mark((function e(t){var n,r,o,a;return i().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:if(n=t.token,r=t.options,o=l()){e.next=4;break}throw new Error("Hiro Wallet not installed.");case 4:return e.prev=4,e.next=7,o.signatureRequest(n);case 7:a=e.sent,null==r.onFinish||r.onFinish(a),e.next=15;break;case 11:e.prev=11,e.t0=e.catch(4),console.error("[Connect] Error during signature request",e.t0),null==r.onCancel||r.onCancel();case 15:case"end":return e.stop()}}),e,null,[[4,11]])})))).apply(this,arguments)}var Q=function(){var e=u(i().mark((function e(n){var r,o,a,s,u,l;return i().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:if(r=n.userSession,o=p(n,M),!m(r)){e.next=5;break}return a=S(r),s=a.privateKey,u=c({},o,{publicKey:a.publicKey}),e.abrupt("return",z(u,s));case 5:return l=c({},o),e.abrupt("return",t.createUnsecuredToken(l));case 7:case"end":return e.stop()}}),e)})));return function(t){return e.apply(this,arguments)}}();function Z(){return(Z=u(i().mark((function e(t,n){return i().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,n(c({},V(t),t));case 2:return e.abrupt("return",X({token:e.sent,options:t}));case 4:case"end":return e.stop()}}),e)})))).apply(this,arguments)}var $=["userSession"];function ee(){return(ee=u(i().mark((function e(t,n){return i().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,n(c({},V(t),t));case 2:return e.abrupt("return",ie({token:e.sent,options:t}));case 4:case"end":return e.stop()}}),e)})))).apply(this,arguments)}function te(e){return c({},e,{message:r.bytesToHex(o.serializeCV(e.message)),domain:r.bytesToHex(o.serializeCV(e.domain))})}function ne(e,t){return re.apply(this,arguments)}function re(){return(re=u(i().mark((function e(n,r){var o;return i().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return o=new t.TokenSigner("ES256k",r),e.abrupt("return",o.signAsync(te(n)));case 2:case"end":return e.stop()}}),e)})))).apply(this,arguments)}function oe(e){return ae.apply(this,arguments)}function ae(){return(ae=u(i().mark((function e(n){var r,o,a,s,u;return i().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:if(r=n.userSession,o=p(n,$),!m(r)){e.next=5;break}return a=S(r),s=a.privateKey,u=c({},o,{publicKey:a.publicKey}),e.abrupt("return",ne(u,s));case 5:return e.abrupt("return",t.createUnsecuredToken(te(n)));case 6:case"end":return e.stop()}}),e)})))).apply(this,arguments)}function ie(e){return se.apply(this,arguments)}function se(){return(se=u(i().mark((function e(t){var n,r,o,a;return i().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:if(n=t.token,r=t.options,o=l()){e.next=4;break}throw new Error("Hiro Wallet not installed.");case 4:return e.prev=4,e.next=7,o.structuredDataSignatureRequest(n);case 7:a=e.sent,null==r.onFinish||r.onFinish(a),e.next=15;break;case 11:e.prev=11,e.t0=e.catch(4),console.error("[Connect] Error during signature request",e.t0),null==r.onCancel||r.onCancel();case 15:case"end":return e.stop()}}),e,null,[[4,11]])})))).apply(this,arguments)}var ue=["userSession","profile"];function ce(e,t){return pe.apply(this,arguments)}function pe(){return(pe=u(i().mark((function e(n,r){var o;return i().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return o=new t.TokenSigner("ES256k",r),e.abrupt("return",o.signAsync(c({},n)));case 2:case"end":return e.stop()}}),e)})))).apply(this,arguments)}function le(e){var t=c({},e,{network:e.network||new n.StacksTestnet,userSession:b(e.userSession)});return c({},t)}function fe(e){return he.apply(this,arguments)}function he(){return(he=u(i().mark((function e(t){var n,r,o,a;return i().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:if(n=t.token,r=t.options,o=l()){e.next=4;break}throw new Error("Hiro Wallet not installed.");case 4:return e.prev=4,e.next=7,o.profileUpdateRequest(n);case 7:a=e.sent,null==r.onFinish||r.onFinish(a),e.next=15;break;case 11:e.prev=11,e.t0=e.catch(4),console.error("[Connect] Error during signature request",e.t0),null==r.onCancel||r.onCancel();case 15:case"end":return e.stop()}}),e,null,[[4,11]])})))).apply(this,arguments)}var de,ve=function(){var e=u(i().mark((function e(n){var r,o,a,s,u,l,f;return i().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:if(r=n.userSession,o=n.profile,a=p(n,ue),!m(r)){e.next=5;break}return s=S(r),u=s.privateKey,l=c({},a,{profile:o,publicKey:s.publicKey}),e.abrupt("return",ce(l,u));case 5:return f=c({},a),e.abrupt("return",t.createUnsecuredToken(f));case 7:case"end":return e.stop()}}),e)})));return function(t){return e.apply(this,arguments)}}();function ye(){return(ye=u(i().mark((function e(t,n){return i().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,n(c({},le(t),t));case 2:return e.abrupt("return",fe({token:e.sent,options:t}));case 4:case"end":return e.stop()}}),e)})))).apply(this,arguments)}(de=exports.SignatureHash||(exports.SignatureHash={}))[de.DEFAULT=0]="DEFAULT",de[de.ALL=1]="ALL",de[de.NONE=2]="NONE",de[de.SINGLE=3]="SINGLE",de[de.ANYONECANPAY=128]="ANYONECANPAY";var xe=function(e){if(l())y(e);else if(void 0!==typeof window){a.defineCustomElements(window);var t=document.createElement("connect-modal");t.authOptions=e,document.body.appendChild(t),document.addEventListener("keydown",(function e(n){"Escape"===n.key&&(document.removeEventListener("keydown",e),t.remove())}))}};Object.keys(e).forEach((function(t){"default"!==t&&Object.defineProperty(exports,t,{enumerable:!0,get:function(){return e[t]}})})),exports.authenticate=y,exports.defaultAuthURL="https://app.blockstack.org",exports.getDefaultProfileUpdateRequestOptions=le,exports.getDefaultPsbtRequestOptions=j,exports.getDefaultSignatureRequestOptions=V,exports.getKeys=S,exports.getOrCreateUserSession=v,exports.getStacksProvider=l,exports.getStxAddress=T,exports.getUserData=x,exports.getUserSession=b,exports.hasAppPrivateKey=m,exports.isMobile=d,exports.isStacksWalletInstalled=function(){return!!l()},exports.makeContractCallToken=D,exports.makeContractDeployToken=K,exports.makeProfileUpdateToken=ve,exports.makePsbtToken=G,exports.makeSTXTransferToken=U,exports.openContractCall=function(e){return I(e,D)},exports.openContractDeploy=function(e){return I(e,K)},exports.openProfileUpdateRequestPopup=function(e){return function(e,t){return ye.apply(this,arguments)}(e,ve)},exports.openPsbtRequestPopup=function(e){return function(e,t){return W.apply(this,arguments)}(e,G)},exports.openSTXTransfer=function(e){return I(e,U)},exports.openSignatureRequestPopup=function(e){return function(e,t){return Z.apply(this,arguments)}(e,Q)},exports.openStructuredDataSignatureRequestPopup=function(e){return function(e,t){return ee.apply(this,arguments)}(e,oe)},exports.shouldUsePopup=function(){return!d()},exports.showBlockstackConnect=function(e){return xe(e)},exports.showConnect=xe,exports.signMessage=Q,exports.signStructuredMessage=oe;


},{"@stacks/auth":22,"@stacks/common":36,"@stacks/connect-ui/loader":44,"@stacks/network":63,"@stacks/transactions":93,"jsontokens":121}],47:[function(require,module,exports){
(function (process){(function (){

'use strict'

if (process.env.NODE_ENV === 'production') {
  module.exports = require('./connect.cjs.production.min.js')
} else {
  module.exports = require('./connect.cjs.development.js')
}

}).call(this)}).call(this,require('_process'))
},{"./connect.cjs.development.js":45,"./connect.cjs.production.min.js":46,"_process":2}],48:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createCipher = exports.WebCryptoAesCipher = exports.NodeCryptoAesCipher = void 0;
const common_1 = require("@stacks/common");
const cryptoUtils_1 = require("./cryptoUtils");
class NodeCryptoAesCipher {
    constructor(createCipher, createDecipher) {
        this.createCipher = createCipher;
        this.createDecipher = createDecipher;
    }
    async encrypt(algorithm, key, iv, data) {
        if (algorithm !== 'aes-128-cbc' && algorithm !== 'aes-256-cbc') {
            throw new Error(`Unsupported cipher algorithm "${algorithm}"`);
        }
        const cipher = this.createCipher(algorithm, key, iv);
        const result = new Uint8Array((0, common_1.concatBytes)(cipher.update(data), cipher.final()));
        return Promise.resolve(result);
    }
    async decrypt(algorithm, key, iv, data) {
        if (algorithm !== 'aes-128-cbc' && algorithm !== 'aes-256-cbc') {
            throw new Error(`Unsupported cipher algorithm "${algorithm}"`);
        }
        const cipher = this.createDecipher(algorithm, key, iv);
        const result = new Uint8Array((0, common_1.concatBytes)(cipher.update(data), cipher.final()));
        return Promise.resolve(result);
    }
}
exports.NodeCryptoAesCipher = NodeCryptoAesCipher;
class WebCryptoAesCipher {
    constructor(subtleCrypto) {
        this.subtleCrypto = subtleCrypto;
    }
    async encrypt(algorithm, key, iv, data) {
        let algo;
        let length;
        if (algorithm === 'aes-128-cbc') {
            algo = 'AES-CBC';
            length = 128;
        }
        else if (algorithm === 'aes-256-cbc') {
            algo = 'AES-CBC';
            length = 256;
        }
        else {
            throw new Error(`Unsupported cipher algorithm "${algorithm}"`);
        }
        const cryptoKey = await this.subtleCrypto.importKey('raw', key, { name: algo, length }, false, [
            'encrypt',
        ]);
        const result = await this.subtleCrypto.encrypt({ name: algo, iv }, cryptoKey, data);
        return new Uint8Array(result);
    }
    async decrypt(algorithm, key, iv, data) {
        let algo;
        let length;
        if (algorithm === 'aes-128-cbc') {
            algo = 'AES-CBC';
            length = 128;
        }
        else if (algorithm === 'aes-256-cbc') {
            algo = 'AES-CBC';
            length = 256;
        }
        else {
            throw new Error(`Unsupported cipher algorithm "${algorithm}"`);
        }
        const cryptoKey = await this.subtleCrypto.importKey('raw', key, { name: algo, length }, false, [
            'decrypt',
        ]);
        const result = await this.subtleCrypto.decrypt({ name: algo, iv }, cryptoKey, data);
        return new Uint8Array(result);
    }
}
exports.WebCryptoAesCipher = WebCryptoAesCipher;
async function createCipher() {
    const cryptoLib = await (0, cryptoUtils_1.getCryptoLib)();
    if (cryptoLib.name === 'subtleCrypto') {
        return new WebCryptoAesCipher(cryptoLib.lib);
    }
    return new NodeCryptoAesCipher(cryptoLib.lib.createCipheriv, cryptoLib.lib.createDecipheriv);
}
exports.createCipher = createCipher;

},{"./cryptoUtils":50,"@stacks/common":36}],49:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.randomBytes = void 0;
const secp256k1_1 = require("@noble/secp256k1");
const randomBytes = (bytesLength = 32) => secp256k1_1.utils.randomBytes(bytesLength);
exports.randomBytes = randomBytes;

},{"@noble/secp256k1":15}],50:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCryptoLib = exports.NO_CRYPTO_LIB = exports.isNodeCryptoAvailable = exports.isSubtleCryptoAvailable = void 0;
function isSubtleCryptoAvailable() {
    return typeof crypto !== 'undefined' && typeof crypto.subtle !== 'undefined';
}
exports.isSubtleCryptoAvailable = isSubtleCryptoAvailable;
function isNodeCryptoAvailable(withFeature) {
    try {
        const resolvedResult = require.resolve('crypto');
        if (!resolvedResult) {
            return false;
        }
        const cryptoModule = require('crypto');
        if (!cryptoModule) {
            return false;
        }
        if (withFeature) {
            const features = withFeature(cryptoModule);
            return features;
        }
        return true;
    }
    catch (error) {
        return false;
    }
}
exports.isNodeCryptoAvailable = isNodeCryptoAvailable;
exports.NO_CRYPTO_LIB = 'Crypto lib not found. Either the WebCrypto "crypto.subtle" or Node.js "crypto" module must be available.';
async function getCryptoLib() {
    if (isSubtleCryptoAvailable()) {
        return {
            lib: crypto.subtle,
            name: 'subtleCrypto',
        };
    }
    else {
        try {
            const nodeCrypto = require('crypto');
            return {
                lib: nodeCrypto,
                name: 'nodeCrypto',
            };
        }
        catch (error) {
            throw new Error(exports.NO_CRYPTO_LIB);
        }
    }
}
exports.getCryptoLib = getCryptoLib;

},{"crypto":1}],51:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyMessageSignatureRsv = exports.verifyMessageSignature = exports.verifyECDSA = exports.signECDSA = exports.decryptECIES = exports.encryptECIES = exports.eciesGetJsonStringLength = exports.getSignedCipherObjectWrapper = exports.getCipherObjectWrapper = exports.getBytesFromBN = exports.getHexFromBN = exports.hmacSha256 = exports.aes256CbcEncrypt = exports.InvalidPublicKeyReason = void 0;
const hmac_1 = require("@noble/hashes/hmac");
const sha256_1 = require("@noble/hashes/sha256");
const secp256k1_1 = require("@noble/secp256k1");
const common_1 = require("@stacks/common");
const base64_js_1 = require("base64-js");
const aesCipher_1 = require("./aesCipher");
const keys_1 = require("./keys");
const messageSignature_1 = require("./messageSignature");
const sha2Hash_1 = require("./sha2Hash");
const utils_1 = require("./utils");
secp256k1_1.utils.hmacSha256Sync = (key, ...msgs) => {
    const h = hmac_1.hmac.create(sha256_1.sha256, key);
    msgs.forEach(msg => h.update(msg));
    return h.digest();
};
var InvalidPublicKeyReason;
(function (InvalidPublicKeyReason) {
    InvalidPublicKeyReason["InvalidFormat"] = "InvalidFormat";
    InvalidPublicKeyReason["IsNotPoint"] = "IsNotPoint";
})(InvalidPublicKeyReason = exports.InvalidPublicKeyReason || (exports.InvalidPublicKeyReason = {}));
async function aes256CbcEncrypt(iv, key, plaintext) {
    const cipher = await (0, aesCipher_1.createCipher)();
    return await cipher.encrypt('aes-256-cbc', key, iv, plaintext);
}
exports.aes256CbcEncrypt = aes256CbcEncrypt;
async function aes256CbcDecrypt(iv, key, ciphertext) {
    const cipher = await (0, aesCipher_1.createCipher)();
    return await cipher.decrypt('aes-256-cbc', key, iv, ciphertext);
}
function hmacSha256(key, content) {
    return (0, hmac_1.hmac)(sha256_1.sha256, key, content);
}
exports.hmacSha256 = hmacSha256;
function equalsConstTime(a, b) {
    if (a.length !== b.length) {
        return false;
    }
    let res = 0;
    for (let i = 0; i < a.length; i++) {
        res |= a[i] ^ b[i];
    }
    return res === 0;
}
function sharedSecretToKeys(sharedSecret) {
    const hashedSecret = (0, sha2Hash_1.hashSha512Sync)(sharedSecret);
    return {
        encryptionKey: hashedSecret.slice(0, 32),
        hmacKey: hashedSecret.slice(32),
    };
}
function allHexChars(maybe) {
    return maybe.match(/^[0-9a-f]+$/i) !== null;
}
function isValidPublicKey(pub) {
    const invalidFormat = {
        result: false,
        reason_data: 'Invalid public key format',
        reason: InvalidPublicKeyReason.InvalidFormat,
    };
    const invalidPoint = {
        result: false,
        reason_data: 'Public key is not a point',
        reason: InvalidPublicKeyReason.IsNotPoint,
    };
    if (pub.length !== 66 && pub.length !== 130)
        return invalidFormat;
    const firstByte = pub.slice(0, 2);
    if (pub.length === 130 && firstByte !== '04')
        return invalidFormat;
    if (pub.length === 66 && firstByte !== '02' && firstByte !== '03')
        return invalidFormat;
    if (!allHexChars(pub))
        return invalidFormat;
    try {
        const point = secp256k1_1.Point.fromHex(pub);
        point.assertValidity();
        return {
            result: true,
            reason_data: null,
            reason: null,
        };
    }
    catch (e) {
        return invalidPoint;
    }
}
function getHexFromBN(bnInput) {
    const hexOut = bnInput.toString(16);
    if (hexOut.length === 64) {
        return hexOut;
    }
    else if (hexOut.length < 64) {
        const padding = '0'.repeat(64 - hexOut.length);
        return `${padding}${hexOut}`;
    }
    else {
        throw new Error('Generated a > 32-byte BN for encryption. Failing.');
    }
}
exports.getHexFromBN = getHexFromBN;
function getBytesFromBN(bnInput) {
    const result = (0, common_1.bigIntToBytes)(bnInput, 32);
    if (result.byteLength !== 32) {
        throw new Error('Failed to generate a 32-byte Uint8Array');
    }
    return result;
}
exports.getBytesFromBN = getBytesFromBN;
function getCipherObjectWrapper(opts) {
    const shell = {
        iv: '',
        ephemeralPK: '',
        mac: '',
        cipherText: '',
        wasString: !!opts.wasString,
    };
    if (opts.cipherTextEncoding === 'base64') {
        shell.cipherTextEncoding = 'base64';
    }
    const ivLength = 32;
    const ephemeralPKLength = 66;
    const macLength = 64;
    return {
        payloadValuesLength: ivLength + ephemeralPKLength + macLength,
        payloadShell: JSON.stringify(shell),
    };
}
exports.getCipherObjectWrapper = getCipherObjectWrapper;
function getSignedCipherObjectWrapper(payloadShell) {
    const shell = {
        signature: '',
        publicKey: '',
        cipherText: payloadShell,
    };
    const signatureLength = 144;
    const publicKeyLength = 66;
    return {
        signedPayloadValuesLength: signatureLength + publicKeyLength,
        signedPayloadShell: JSON.stringify(shell),
    };
}
exports.getSignedCipherObjectWrapper = getSignedCipherObjectWrapper;
function eciesGetJsonStringLength(opts) {
    const { payloadShell, payloadValuesLength } = getCipherObjectWrapper(opts);
    const cipherTextLength = (0, utils_1.getAesCbcOutputLength)(opts.contentLength);
    let encodedCipherTextLength;
    if (!opts.cipherTextEncoding || opts.cipherTextEncoding === 'hex') {
        encodedCipherTextLength = cipherTextLength * 2;
    }
    else if (opts.cipherTextEncoding === 'base64') {
        encodedCipherTextLength = (0, utils_1.getBase64OutputLength)(cipherTextLength);
    }
    else {
        throw new Error(`Unexpected cipherTextEncoding "${opts.cipherTextEncoding}"`);
    }
    if (!opts.sign) {
        return payloadShell.length + payloadValuesLength + encodedCipherTextLength;
    }
    else {
        const { signedPayloadShell, signedPayloadValuesLength } = getSignedCipherObjectWrapper(payloadShell);
        return (signedPayloadShell.length +
            signedPayloadValuesLength +
            payloadValuesLength +
            encodedCipherTextLength);
    }
}
exports.eciesGetJsonStringLength = eciesGetJsonStringLength;
async function encryptECIES(publicKey, content, wasString, cipherTextEncoding) {
    const validity = isValidPublicKey(publicKey);
    if (!validity.result) {
        throw validity;
    }
    const ephemeralPrivateKey = secp256k1_1.utils.randomPrivateKey();
    const ephemeralPublicKey = (0, secp256k1_1.getPublicKey)(ephemeralPrivateKey, true);
    let sharedSecret = (0, secp256k1_1.getSharedSecret)(ephemeralPrivateKey, publicKey, true);
    sharedSecret = sharedSecret.slice(1);
    const sharedKeys = sharedSecretToKeys(sharedSecret);
    const initializationVector = secp256k1_1.utils.randomBytes(16);
    const cipherText = await aes256CbcEncrypt(initializationVector, sharedKeys.encryptionKey, content);
    const macData = (0, common_1.concatBytes)(initializationVector, ephemeralPublicKey, cipherText);
    const mac = hmacSha256(sharedKeys.hmacKey, macData);
    let cipherTextString;
    if (!cipherTextEncoding || cipherTextEncoding === 'hex') {
        cipherTextString = (0, common_1.bytesToHex)(cipherText);
    }
    else if (cipherTextEncoding === 'base64') {
        cipherTextString = (0, base64_js_1.fromByteArray)(cipherText);
    }
    else {
        throw new Error(`Unexpected cipherTextEncoding "${cipherTextEncoding}"`);
    }
    const result = {
        iv: (0, common_1.bytesToHex)(initializationVector),
        ephemeralPK: (0, common_1.bytesToHex)(ephemeralPublicKey),
        cipherText: cipherTextString,
        mac: (0, common_1.bytesToHex)(mac),
        wasString,
    };
    if (cipherTextEncoding && cipherTextEncoding !== 'hex') {
        result.cipherTextEncoding = cipherTextEncoding;
    }
    return result;
}
exports.encryptECIES = encryptECIES;
async function decryptECIES(privateKey, cipherObject) {
    if (!cipherObject.ephemeralPK) {
        throw new common_1.FailedDecryptionError('Unable to get public key from cipher object. ' +
            'You might be trying to decrypt an unencrypted object.');
    }
    const ephemeralPK = cipherObject.ephemeralPK;
    let sharedSecret = (0, secp256k1_1.getSharedSecret)(privateKey, ephemeralPK, true);
    sharedSecret = sharedSecret.slice(1);
    const sharedKeys = sharedSecretToKeys(sharedSecret);
    const ivBytes = (0, common_1.hexToBytes)(cipherObject.iv);
    let cipherTextBytes;
    if (!cipherObject.cipherTextEncoding || cipherObject.cipherTextEncoding === 'hex') {
        cipherTextBytes = (0, common_1.hexToBytes)(cipherObject.cipherText);
    }
    else if (cipherObject.cipherTextEncoding === 'base64') {
        cipherTextBytes = (0, base64_js_1.toByteArray)(cipherObject.cipherText);
    }
    else {
        throw new Error(`Unexpected cipherTextEncoding "${cipherObject.cipherText}"`);
    }
    const macData = (0, common_1.concatBytes)(ivBytes, (0, common_1.hexToBytes)(ephemeralPK), cipherTextBytes);
    const actualMac = hmacSha256(sharedKeys.hmacKey, macData);
    const expectedMac = (0, common_1.hexToBytes)(cipherObject.mac);
    if (!equalsConstTime(expectedMac, actualMac)) {
        throw new common_1.FailedDecryptionError('Decryption failed: failure in MAC check');
    }
    const plainText = await aes256CbcDecrypt(ivBytes, sharedKeys.encryptionKey, cipherTextBytes);
    if (cipherObject.wasString) {
        return (0, common_1.bytesToUtf8)(plainText);
    }
    return plainText;
}
exports.decryptECIES = decryptECIES;
function signECDSA(privateKey, content) {
    const contentBytes = typeof content === 'string' ? (0, common_1.utf8ToBytes)(content) : content;
    const publicKey = (0, keys_1.getPublicKeyFromPrivate)(privateKey);
    const contentHash = (0, sha2Hash_1.hashSha256Sync)(contentBytes);
    const signature = (0, secp256k1_1.signSync)(contentHash, privateKey);
    return {
        signature: (0, common_1.bytesToHex)(signature),
        publicKey,
    };
}
exports.signECDSA = signECDSA;
function verifyECDSA(content, publicKey, signature) {
    const contentBytes = typeof content === 'string' ? (0, common_1.utf8ToBytes)(content) : content;
    const contentHash = (0, sha2Hash_1.hashSha256Sync)(contentBytes);
    return (0, secp256k1_1.verify)(signature, contentHash, publicKey, { strict: false });
}
exports.verifyECDSA = verifyECDSA;
function verifyMessageSignature({ signature, message, publicKey, }) {
    const { r, s } = (0, common_1.parseRecoverableSignatureVrs)(signature);
    const sig = new secp256k1_1.Signature((0, common_1.hexToBigInt)(r), (0, common_1.hexToBigInt)(s));
    const hashedMsg = typeof message === 'string' ? (0, messageSignature_1.hashMessage)(message) : message;
    const verificationResult = (0, secp256k1_1.verify)(sig, hashedMsg, publicKey, { strict: false });
    if (verificationResult || typeof message !== 'string')
        return verificationResult;
    const LEGACY_PREFIX = '\x18Stacks Message Signing:\n';
    const legacyHash = (0, sha256_1.sha256)((0, messageSignature_1.encodeMessage)(message, LEGACY_PREFIX));
    return (0, secp256k1_1.verify)(sig, legacyHash, publicKey, { strict: false });
}
exports.verifyMessageSignature = verifyMessageSignature;
function verifyMessageSignatureRsv({ signature, message, publicKey, }) {
    return verifyMessageSignature({
        signature: (0, common_1.signatureRsvToVrs)(signature),
        message,
        publicKey,
    });
}
exports.verifyMessageSignatureRsv = verifyMessageSignatureRsv;

},{"./aesCipher":48,"./keys":55,"./messageSignature":56,"./sha2Hash":58,"./utils":59,"@noble/hashes/hmac":9,"@noble/hashes/sha256":12,"@noble/secp256k1":15,"@stacks/common":36,"base64-js":106}],52:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decryptContent = exports.encryptContent = void 0;
const common_1 = require("@stacks/common");
const ec_1 = require("./ec");
const keys_1 = require("./keys");
async function encryptContent(content, options) {
    const opts = Object.assign({}, options);
    let privateKey;
    if (!opts.publicKey) {
        if (!opts.privateKey) {
            throw new Error('Either public key or private key must be supplied for encryption.');
        }
        opts.publicKey = (0, keys_1.getPublicKeyFromPrivate)(opts.privateKey);
    }
    const wasString = typeof opts.wasString === 'boolean' ? opts.wasString : typeof content === 'string';
    const contentBytes = typeof content === 'string' ? (0, common_1.utf8ToBytes)(content) : content;
    const cipherObject = await (0, ec_1.encryptECIES)(opts.publicKey, contentBytes, wasString, opts.cipherTextEncoding);
    let cipherPayload = JSON.stringify(cipherObject);
    if (opts.sign) {
        if (typeof opts.sign === 'string') {
            privateKey = opts.sign;
        }
        else if (!privateKey) {
            privateKey = opts.privateKey;
        }
        const signatureObject = (0, ec_1.signECDSA)(privateKey, cipherPayload);
        const signedCipherObject = {
            signature: signatureObject.signature,
            publicKey: signatureObject.publicKey,
            cipherText: cipherPayload,
        };
        cipherPayload = JSON.stringify(signedCipherObject);
    }
    return cipherPayload;
}
exports.encryptContent = encryptContent;
function decryptContent(content, options) {
    const opts = Object.assign({}, options);
    if (!opts.privateKey) {
        throw new Error('Private key is required for decryption.');
    }
    try {
        const cipherObject = JSON.parse(content);
        return (0, ec_1.decryptECIES)(opts.privateKey, cipherObject);
    }
    catch (err) {
        if (err instanceof SyntaxError) {
            throw new Error('Failed to parse encrypted content JSON. The content may not ' +
                'be encrypted. If using getFile, try passing { decrypt: false }.');
        }
        else {
            throw err;
        }
    }
}
exports.decryptContent = decryptContent;

},{"./ec":51,"./keys":55,"@stacks/common":36}],53:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hashRipemd160 = void 0;
const ripemd160_1 = require("@noble/hashes/ripemd160");
function hashRipemd160(data) {
    return (0, ripemd160_1.ripemd160)(data);
}
exports.hashRipemd160 = hashRipemd160;

},{"@noble/hashes/ripemd160":11}],54:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decryptMnemonic = exports.encryptMnemonic = void 0;
__exportStar(require("./ec"), exports);
__exportStar(require("./keys"), exports);
__exportStar(require("./cryptoRandom"), exports);
__exportStar(require("./sha2Hash"), exports);
__exportStar(require("./encryption"), exports);
__exportStar(require("./utils"), exports);
__exportStar(require("./messageSignature"), exports);
var wallet_1 = require("./wallet");
Object.defineProperty(exports, "encryptMnemonic", { enumerable: true, get: function () { return wallet_1.encryptMnemonic; } });
Object.defineProperty(exports, "decryptMnemonic", { enumerable: true, get: function () { return wallet_1.decryptMnemonic; } });

},{"./cryptoRandom":49,"./ec":51,"./encryption":52,"./keys":55,"./messageSignature":56,"./sha2Hash":58,"./utils":59,"./wallet":61}],55:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.compressPrivateKey = exports.isValidPrivateKey = exports.ecSign = exports.getPublicKeyFromPrivate = exports.publicKeyToBtcAddress = exports.base58CheckEncode = exports.base58Encode = exports.base58CheckDecode = exports.makeECPrivateKey = void 0;
const hmac_1 = require("@noble/hashes/hmac");
const sha256_1 = require("@noble/hashes/sha256");
const secp256k1_1 = require("@noble/secp256k1");
const common_1 = require("@stacks/common");
const bs58_1 = __importDefault(require("bs58"));
const hashRipemd160_1 = require("./hashRipemd160");
const sha2Hash_1 = require("./sha2Hash");
const BITCOIN_PUBKEYHASH = 0x00;
secp256k1_1.utils.hmacSha256Sync = (key, ...msgs) => {
    const h = hmac_1.hmac.create(sha256_1.sha256, key);
    msgs.forEach(msg => h.update(msg));
    return h.digest();
};
function makeECPrivateKey() {
    return (0, common_1.bytesToHex)(secp256k1_1.utils.randomPrivateKey());
}
exports.makeECPrivateKey = makeECPrivateKey;
function base58CheckDecode(btcAddress) {
    const bytes = bs58_1.default.decode(btcAddress);
    const payload = bytes.slice(0, -4);
    const checksum = bytes.slice(-4);
    const newChecksum = (0, sha256_1.sha256)((0, sha256_1.sha256)(payload));
    if ((checksum[0] ^ newChecksum[0]) |
        (checksum[1] ^ newChecksum[1]) |
        (checksum[2] ^ newChecksum[2]) |
        (checksum[3] ^ newChecksum[3])) {
        throw new Error('Invalid checksum');
    }
    if (payload.length !== 21)
        throw new TypeError('Invalid address length');
    const version = (0, common_1.readUInt8)(payload, 0);
    const hash = payload.slice(1);
    return { version, hash };
}
exports.base58CheckDecode = base58CheckDecode;
function base58Encode(hash) {
    const checksum = (0, sha256_1.sha256)((0, sha256_1.sha256)(hash));
    return bs58_1.default.encode((0, common_1.concatBytes)(hash, checksum).slice(0, hash.length + 4));
}
exports.base58Encode = base58Encode;
function base58CheckEncode(version, hash) {
    return base58Encode((0, common_1.concatBytes)(new Uint8Array([version]), hash.slice(0, 20)));
}
exports.base58CheckEncode = base58CheckEncode;
function publicKeyToBtcAddress(publicKey, version = BITCOIN_PUBKEYHASH) {
    const publicKeyBytes = typeof publicKey === 'string' ? (0, common_1.hexToBytes)(publicKey) : publicKey;
    const publicKeyHash160 = (0, hashRipemd160_1.hashRipemd160)((0, sha2Hash_1.hashSha256Sync)(publicKeyBytes));
    return base58CheckEncode(version, publicKeyHash160);
}
exports.publicKeyToBtcAddress = publicKeyToBtcAddress;
function getPublicKeyFromPrivate(privateKey) {
    const privateKeyBytes = (0, common_1.privateKeyToBytes)(privateKey);
    return (0, common_1.bytesToHex)((0, secp256k1_1.getPublicKey)(privateKeyBytes.slice(0, 32), true));
}
exports.getPublicKeyFromPrivate = getPublicKeyFromPrivate;
function ecSign(messageHash, hexPrivateKey) {
    return (0, secp256k1_1.signSync)(messageHash, (0, common_1.privateKeyToBytes)(hexPrivateKey).slice(0, 32), {
        der: false,
    });
}
exports.ecSign = ecSign;
function isValidPrivateKey(privateKey) {
    return secp256k1_1.utils.isValidPrivateKey((0, common_1.privateKeyToBytes)(privateKey));
}
exports.isValidPrivateKey = isValidPrivateKey;
function compressPrivateKey(privateKey) {
    const privateKeyBytes = (0, common_1.privateKeyToBytes)(privateKey);
    return privateKeyBytes.length == common_1.PRIVATE_KEY_COMPRESSED_LENGTH
        ? privateKeyBytes
        : (0, common_1.concatBytes)(privateKeyBytes, new Uint8Array([1]));
}
exports.compressPrivateKey = compressPrivateKey;

},{"./hashRipemd160":53,"./sha2Hash":58,"@noble/hashes/hmac":9,"@noble/hashes/sha256":12,"@noble/secp256k1":15,"@stacks/common":36,"bs58":107}],56:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeMessage = exports.encodeMessage = exports.hashMessage = void 0;
const sha256_1 = require("@noble/hashes/sha256");
const common_1 = require("@stacks/common");
const varuint_1 = require("./varuint");
const chainPrefix = '\x17Stacks Signed Message:\n';
function hashMessage(message, prefix = chainPrefix) {
    return (0, sha256_1.sha256)(encodeMessage(message, prefix));
}
exports.hashMessage = hashMessage;
function encodeMessage(message, prefix = chainPrefix) {
    const messageBytes = typeof message == 'string' ? (0, common_1.utf8ToBytes)(message) : message;
    const encodedLength = (0, varuint_1.encode)(messageBytes.length);
    return (0, common_1.concatBytes)((0, common_1.utf8ToBytes)(prefix), encodedLength, messageBytes);
}
exports.encodeMessage = encodeMessage;
function decodeMessage(encodedMessage, prefix = chainPrefix) {
    const prefixByteLength = (0, common_1.utf8ToBytes)(prefix).byteLength;
    const messageWithoutChainPrefix = encodedMessage.subarray(prefixByteLength);
    const decoded = (0, varuint_1.decode)(messageWithoutChainPrefix);
    const varIntLength = (0, varuint_1.encodingLength)(decoded);
    return messageWithoutChainPrefix.slice(varIntLength);
}
exports.decodeMessage = decodeMessage;

},{"./varuint":60,"@noble/hashes/sha256":12,"@stacks/common":36}],57:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createPbkdf2 = exports.WebCryptoPartialPbkdf2 = exports.WebCryptoPbkdf2 = exports.NodeCryptoPbkdf2 = void 0;
const common_1 = require("@stacks/common");
const cryptoUtils_1 = require("./cryptoUtils");
class NodeCryptoPbkdf2 {
    constructor(nodePbkdf2) {
        this.nodePbkdf2 = nodePbkdf2;
    }
    async derive(password, salt, iterations, keyLength, digest) {
        if (digest !== 'sha512' && digest !== 'sha256') {
            throw new Error(`Unsupported digest "${digest}" for Pbkdf2`);
        }
        return new Promise((resolve, reject) => {
            this.nodePbkdf2(password, salt, iterations, keyLength, digest, (error, result) => {
                if (error) {
                    reject(error);
                }
                resolve(result);
            });
        });
    }
}
exports.NodeCryptoPbkdf2 = NodeCryptoPbkdf2;
class WebCryptoPbkdf2 {
    constructor(subtleCrypto) {
        this.subtleCrypto = subtleCrypto;
    }
    async derive(password, salt, iterations, keyLength, digest) {
        let algo;
        if (digest === 'sha256') {
            algo = 'SHA-256';
        }
        else if (digest === 'sha512') {
            algo = 'SHA-512';
        }
        else {
            throw new Error(`Unsupported Pbkdf2 digest algorithm "${digest}"`);
        }
        const passwordBytes = (0, common_1.utf8ToBytes)(password);
        try {
            const key = await this.subtleCrypto.importKey('raw', passwordBytes, 'PBKDF2', false, [
                'deriveBits',
            ]);
            const result = await this.subtleCrypto.deriveBits({
                name: 'PBKDF2',
                salt,
                iterations,
                hash: { name: algo },
            }, key, keyLength * 8);
            return new Uint8Array(result);
        }
        catch (error) {
            const partialWebCrypto = new WebCryptoPartialPbkdf2(this.subtleCrypto);
            return partialWebCrypto.derive(password, salt, iterations, keyLength, digest);
        }
    }
}
exports.WebCryptoPbkdf2 = WebCryptoPbkdf2;
class WebCryptoPartialPbkdf2 {
    constructor(subtleCrypto) {
        this.subtleCrypto = subtleCrypto;
    }
    async derive(password, salt, iterations, keyLength, digest) {
        if (digest !== 'sha512' && digest !== 'sha256') {
            throw new Error(`Unsupported digest "${digest}" for Pbkdf2`);
        }
        const passwordBytes = (0, common_1.utf8ToBytes)(password);
        const algo = digest === 'sha512' ? 'SHA-512' : 'SHA-256';
        const algoOpts = { name: 'HMAC', hash: algo };
        const hmacDigest = (key, data) => this.subtleCrypto
            .importKey('raw', key, algoOpts, true, ['sign'])
            .then(cryptoKey => this.subtleCrypto.sign(algoOpts, cryptoKey, data))
            .then(result => new Uint8Array(result));
        const DK = new Uint8Array(keyLength);
        const saltLength = salt.length;
        const block1 = new Uint8Array(saltLength + 4);
        block1.set(salt);
        let destPos = 0;
        const hLen = digest === 'sha512' ? 64 : 32;
        const l = Math.ceil(keyLength / hLen);
        for (let i = 1; i <= l; i++) {
            (0, common_1.writeUInt32BE)(block1, i, saltLength);
            const T = await hmacDigest(passwordBytes, block1);
            let U = T;
            for (let j = 1; j < iterations; j++) {
                U = await hmacDigest(passwordBytes, U);
                for (let k = 0; k < hLen; k++) {
                    T[k] ^= U[k];
                }
            }
            DK.set(T.subarray(0, DK.byteLength - destPos), destPos);
            destPos += hLen;
        }
        return DK;
    }
}
exports.WebCryptoPartialPbkdf2 = WebCryptoPartialPbkdf2;
async function createPbkdf2() {
    const cryptoLib = await (0, cryptoUtils_1.getCryptoLib)();
    if (cryptoLib.name === 'subtleCrypto') {
        return new WebCryptoPbkdf2(cryptoLib.lib);
    }
    return new NodeCryptoPbkdf2(cryptoLib.lib.pbkdf2);
}
exports.createPbkdf2 = createPbkdf2;

},{"./cryptoUtils":50,"@stacks/common":36}],58:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hashSha512Sync = exports.hashSha256Sync = exports.createSha2Hash = exports.WebCryptoSha2Hash = exports.NodeCryptoSha2Hash = void 0;
const sha256_1 = require("@noble/hashes/sha256");
const sha512_1 = require("@noble/hashes/sha512");
const cryptoUtils_1 = require("./cryptoUtils");
class NodeCryptoSha2Hash {
    constructor(createHash) {
        this.createHash = createHash;
    }
    async digest(data, algorithm = 'sha256') {
        try {
            const result = this.createHash(algorithm).update(data).digest();
            return Promise.resolve(result);
        }
        catch (error) {
            console.log(error);
            console.log(`Error performing ${algorithm} digest with Node.js 'crypto.createHash', falling back to JS implementation.`);
            return Promise.resolve(algorithm === 'sha256' ? hashSha256Sync(data) : hashSha512Sync(data));
        }
    }
}
exports.NodeCryptoSha2Hash = NodeCryptoSha2Hash;
class WebCryptoSha2Hash {
    constructor(subtleCrypto) {
        this.subtleCrypto = subtleCrypto;
    }
    async digest(data, algorithm = 'sha256') {
        let algo;
        if (algorithm === 'sha256') {
            algo = 'SHA-256';
        }
        else if (algorithm === 'sha512') {
            algo = 'SHA-512';
        }
        else {
            throw new Error(`Unsupported hash algorithm ${algorithm}`);
        }
        try {
            const hash = await this.subtleCrypto.digest(algo, data);
            return new Uint8Array(hash);
        }
        catch (error) {
            console.log(error);
            console.log(`Error performing ${algorithm} digest with WebCrypto, falling back to JS implementation.`);
            return Promise.resolve(algorithm === 'sha256' ? hashSha256Sync(data) : hashSha512Sync(data));
        }
    }
}
exports.WebCryptoSha2Hash = WebCryptoSha2Hash;
async function createSha2Hash() {
    const cryptoLib = await (0, cryptoUtils_1.getCryptoLib)();
    if (cryptoLib.name === 'subtleCrypto') {
        return new WebCryptoSha2Hash(cryptoLib.lib);
    }
    else {
        return new NodeCryptoSha2Hash(cryptoLib.lib.createHash);
    }
}
exports.createSha2Hash = createSha2Hash;
function hashSha256Sync(data) {
    return (0, sha256_1.sha256)(data);
}
exports.hashSha256Sync = hashSha256Sync;
function hashSha512Sync(data) {
    return (0, sha512_1.sha512)(data);
}
exports.hashSha512Sync = hashSha512Sync;

},{"./cryptoUtils":50,"@noble/hashes/sha256":12,"@noble/hashes/sha512":13}],59:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hashCode = exports.getBase64OutputLength = exports.getAesCbcOutputLength = exports.verifySignature = exports.Signature = void 0;
const secp256k1_1 = require("@noble/secp256k1");
Object.defineProperty(exports, "Signature", { enumerable: true, get: function () { return secp256k1_1.Signature; } });
Object.defineProperty(exports, "verifySignature", { enumerable: true, get: function () { return secp256k1_1.verify; } });
function getAesCbcOutputLength(inputByteLength) {
    const cipherTextLength = (Math.floor(inputByteLength / 16) + 1) * 16;
    return cipherTextLength;
}
exports.getAesCbcOutputLength = getAesCbcOutputLength;
function getBase64OutputLength(inputByteLength) {
    const encodedLength = Math.ceil(inputByteLength / 3) * 4;
    return encodedLength;
}
exports.getBase64OutputLength = getBase64OutputLength;
function hashCode(string) {
    let hash = 0;
    if (string.length === 0)
        return hash;
    for (let i = 0; i < string.length; i++) {
        const character = string.charCodeAt(i);
        hash = (hash << 5) - hash + character;
        hash &= hash;
    }
    return hash & 0x7fffffff;
}
exports.hashCode = hashCode;

},{"@noble/secp256k1":15}],60:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodingLength = exports.decode = exports.encode = void 0;
const common_1 = require("@stacks/common");
const MAX_SAFE_INTEGER = 9007199254740991;
function ensureUInt53(n) {
    if (n < 0 || n > MAX_SAFE_INTEGER || n % 1 !== 0)
        throw new RangeError('value out of range');
}
function encode(number, bytes, offset = 0) {
    ensureUInt53(number);
    if (!bytes)
        bytes = new Uint8Array(encodingLength(number));
    if (number < 0xfd) {
        (0, common_1.writeUInt8)(bytes, number, offset);
    }
    else if (number <= 65535) {
        (0, common_1.writeUInt8)(bytes, 0xfd, offset);
        (0, common_1.writeUInt16LE)(bytes, number, offset + 1);
    }
    else if (number <= 4294967295) {
        (0, common_1.writeUInt8)(bytes, 0xfe, offset);
        (0, common_1.writeUInt32LE)(bytes, number, offset + 1);
    }
    else {
        (0, common_1.writeUInt8)(bytes, 0xff, offset);
        (0, common_1.writeUInt32LE)(bytes, number >>> 0, offset + 1);
        (0, common_1.writeUInt32LE)(bytes, (number / 4294967296) | 0, offset + 5);
    }
    return bytes;
}
exports.encode = encode;
function decode(bytes, offset = 0) {
    const first = (0, common_1.readUInt8)(bytes, offset);
    if (first < 0xfd) {
        return first;
    }
    else if (first === 0xfd) {
        return (0, common_1.readUInt16LE)(bytes, offset + 1);
    }
    else if (first === 0xfe) {
        return (0, common_1.readUInt32LE)(bytes, offset + 1);
    }
    else {
        const lo = (0, common_1.readUInt32LE)(bytes, offset + 1);
        const hi = (0, common_1.readUInt32LE)(bytes, offset + 5);
        const number = hi * 4294967296 + lo;
        ensureUInt53(number);
        return number;
    }
}
exports.decode = decode;
function encodingLength(number) {
    ensureUInt53(number);
    return number < 0xfd ? 1 : number <= 65535 ? 3 : number <= 4294967295 ? 5 : 9;
}
exports.encodingLength = encodingLength;

},{"@stacks/common":36}],61:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decryptMnemonic = exports.encryptMnemonic = void 0;
const bip39_1 = require("@scure/bip39");
const english_1 = require("@scure/bip39/wordlists/english");
const cryptoRandom_1 = require("./cryptoRandom");
const sha2Hash_1 = require("./sha2Hash");
const aesCipher_1 = require("./aesCipher");
const pbkdf2_1 = require("./pbkdf2");
const common_1 = require("@stacks/common");
const ec_1 = require("./ec");
async function encryptMnemonic(phrase, password, opts) {
    let mnemonicEntropy;
    try {
        const entropyBytes = (0, bip39_1.mnemonicToEntropy)(phrase, english_1.wordlist);
        mnemonicEntropy = (0, common_1.bytesToHex)(entropyBytes);
    }
    catch (error) {
        console.error('Invalid mnemonic phrase provided');
        console.error(error);
        throw new Error('Not a valid bip39 mnemonic');
    }
    const plaintextNormalized = (0, common_1.hexToBytes)(mnemonicEntropy);
    const pbkdf2 = await (0, pbkdf2_1.createPbkdf2)();
    const salt = opts?.getRandomBytes ? opts.getRandomBytes(16) : (0, cryptoRandom_1.randomBytes)(16);
    const keysAndIV = await pbkdf2.derive(password, salt, 100000, 48, 'sha512');
    const encKey = keysAndIV.slice(0, 16);
    const macKey = keysAndIV.slice(16, 32);
    const iv = keysAndIV.slice(32, 48);
    const cipher = await (0, aesCipher_1.createCipher)();
    const cipherText = await cipher.encrypt('aes-128-cbc', encKey, iv, plaintextNormalized);
    const hmacPayload = (0, common_1.concatBytes)(salt, cipherText);
    const hmacDigest = (0, ec_1.hmacSha256)(macKey, hmacPayload);
    const payload = (0, common_1.concatBytes)(salt, hmacDigest, cipherText);
    return payload;
}
exports.encryptMnemonic = encryptMnemonic;
class PasswordError extends Error {
}
async function decryptMnemonicBytes(dataBytes, password) {
    const salt = dataBytes.slice(0, 16);
    const hmacSig = dataBytes.slice(16, 48);
    const cipherText = dataBytes.slice(48);
    const hmacPayload = (0, common_1.concatBytes)(salt, cipherText);
    const pbkdf2 = await (0, pbkdf2_1.createPbkdf2)();
    const keysAndIV = await pbkdf2.derive(password, salt, 100000, 48, 'sha512');
    const encKey = keysAndIV.slice(0, 16);
    const macKey = keysAndIV.slice(16, 32);
    const iv = keysAndIV.slice(32, 48);
    const decipher = await (0, aesCipher_1.createCipher)();
    const decryptedResult = await decipher.decrypt('aes-128-cbc', encKey, iv, cipherText);
    const hmacDigest = (0, ec_1.hmacSha256)(macKey, hmacPayload);
    const sha2Hash = await (0, sha2Hash_1.createSha2Hash)();
    const hmacSigHash = await sha2Hash.digest(hmacSig);
    const hmacDigestHash = await sha2Hash.digest(hmacDigest);
    if (!(0, common_1.equals)(hmacSigHash, hmacDigestHash)) {
        throw new PasswordError('Wrong password (HMAC mismatch)');
    }
    let mnemonic;
    try {
        mnemonic = (0, bip39_1.entropyToMnemonic)(decryptedResult, english_1.wordlist);
    }
    catch (error) {
        console.error('Error thrown by `entropyToMnemonic`');
        console.error(error);
        throw new PasswordError('Wrong password (invalid plaintext)');
    }
    if (!(0, bip39_1.validateMnemonic)(mnemonic, english_1.wordlist)) {
        throw new PasswordError('Wrong password (invalid plaintext)');
    }
    return mnemonic;
}
function decryptLegacy(dataBytes, password, triplesecDecrypt) {
    return new Promise((resolve, reject) => {
        if (!triplesecDecrypt) {
            reject(new Error('The `triplesec.decrypt` function must be provided'));
        }
        triplesecDecrypt({
            key: (0, common_1.utf8ToBytes)(password),
            data: dataBytes,
        }, (err, plaintextBytes) => {
            if (!err) {
                resolve(plaintextBytes);
            }
            else {
                reject(err);
            }
        });
    });
}
async function decryptMnemonic(data, password, triplesecDecrypt) {
    const dataBytes = typeof data === 'string' ? (0, common_1.hexToBytes)(data) : data;
    try {
        return await decryptMnemonicBytes(dataBytes, password);
    }
    catch (error) {
        if (error instanceof PasswordError)
            throw error;
        const data = await decryptLegacy(dataBytes, password, triplesecDecrypt);
        return (0, common_1.bytesToUtf8)(data);
    }
}
exports.decryptMnemonic = decryptMnemonic;

},{"./aesCipher":48,"./cryptoRandom":49,"./ec":51,"./pbkdf2":57,"./sha2Hash":58,"@scure/bip39":17,"@scure/bip39/wordlists/english":18,"@stacks/common":36}],62:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createFetchFn = exports.createApiKeyMiddleware = exports.hostMatches = exports.fetchWrapper = exports.setFetchOptions = exports.getFetchOptions = void 0;
require("cross-fetch/polyfill");
const defaultFetchOpts = {
    referrerPolicy: 'origin',
};
const getFetchOptions = () => {
    return defaultFetchOpts;
};
exports.getFetchOptions = getFetchOptions;
const setFetchOptions = (ops) => {
    return Object.assign(defaultFetchOpts, ops);
};
exports.setFetchOptions = setFetchOptions;
async function fetchWrapper(input, init) {
    const fetchOpts = {};
    Object.assign(fetchOpts, init, defaultFetchOpts);
    const fetchResult = await fetch(input, fetchOpts);
    return fetchResult;
}
exports.fetchWrapper = fetchWrapper;
function hostMatches(host, pattern) {
    if (typeof pattern === 'string')
        return pattern === host;
    return pattern.exec(host);
}
exports.hostMatches = hostMatches;
function createApiKeyMiddleware({ apiKey, host = /(.*)api(.*)\.stacks\.co$/i, httpHeader = 'x-api-key', }) {
    return {
        pre: context => {
            const reqUrl = new URL(context.url);
            if (!hostMatches(reqUrl.host, host))
                return;
            const headers = new Headers(context.init.headers);
            headers.set(httpHeader, apiKey);
            context.init.headers = headers;
        },
    };
}
exports.createApiKeyMiddleware = createApiKeyMiddleware;
function argsForCreateFetchFn(args) {
    let fetchLib = fetchWrapper;
    let middlewares = [];
    if (args.length > 0 && typeof args[0] === 'function') {
        fetchLib = args.shift();
    }
    if (args.length > 0) {
        middlewares = args;
    }
    return { fetchLib, middlewares };
}
function createFetchFn(...args) {
    const { fetchLib, middlewares } = argsForCreateFetchFn(args);
    const fetchFn = async (url, init) => {
        let fetchParams = { url, init: init ?? {} };
        for (const middleware of middlewares) {
            if (typeof middleware.pre === 'function') {
                const result = await Promise.resolve(middleware.pre({
                    fetch: fetchLib,
                    ...fetchParams,
                }));
                fetchParams = result ?? fetchParams;
            }
        }
        let response = await fetchLib(fetchParams.url, fetchParams.init);
        for (const middleware of middlewares) {
            if (typeof middleware.post === 'function') {
                const result = await Promise.resolve(middleware.post({
                    fetch: fetchLib,
                    url: fetchParams.url,
                    init: fetchParams.init,
                    response: response?.clone() ?? response,
                }));
                response = result ?? response;
            }
        }
        return response;
    };
    return fetchFn;
}
exports.createFetchFn = createFetchFn;

},{"cross-fetch/polyfill":113}],63:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./fetch"), exports);
__exportStar(require("./network"), exports);

},{"./fetch":62,"./network":64}],64:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StacksMocknet = exports.StacksTestnet = exports.StacksMainnet = exports.StacksNetwork = exports.StacksNetworks = exports.HIRO_MOCKNET_DEFAULT = exports.HIRO_TESTNET_DEFAULT = exports.HIRO_MAINNET_DEFAULT = void 0;
const common_1 = require("@stacks/common");
const fetch_1 = require("./fetch");
exports.HIRO_MAINNET_DEFAULT = 'https://stacks-node-api.mainnet.stacks.co';
exports.HIRO_TESTNET_DEFAULT = 'https://stacks-node-api.testnet.stacks.co';
exports.HIRO_MOCKNET_DEFAULT = 'http://localhost:3999';
exports.StacksNetworks = ['mainnet', 'testnet'];
class StacksNetwork {
    constructor(networkConfig) {
        this.version = common_1.TransactionVersion.Mainnet;
        this.chainId = common_1.ChainID.Mainnet;
        this.bnsLookupUrl = 'https://stacks-node-api.mainnet.stacks.co';
        this.broadcastEndpoint = '/v2/transactions';
        this.transferFeeEstimateEndpoint = '/v2/fees/transfer';
        this.transactionFeeEstimateEndpoint = '/v2/fees/transaction';
        this.accountEndpoint = '/v2/accounts';
        this.contractAbiEndpoint = '/v2/contracts/interface';
        this.readOnlyFunctionCallEndpoint = '/v2/contracts/call-read';
        this.isMainnet = () => this.version === common_1.TransactionVersion.Mainnet;
        this.getBroadcastApiUrl = () => `${this.coreApiUrl}${this.broadcastEndpoint}`;
        this.getTransferFeeEstimateApiUrl = () => `${this.coreApiUrl}${this.transferFeeEstimateEndpoint}`;
        this.getTransactionFeeEstimateApiUrl = () => `${this.coreApiUrl}${this.transactionFeeEstimateEndpoint}`;
        this.getAccountApiUrl = (address) => `${this.coreApiUrl}${this.accountEndpoint}/${address}?proof=0`;
        this.getAccountExtendedBalancesApiUrl = (address) => `${this.coreApiUrl}/extended/v1/address/${address}/balances`;
        this.getAbiApiUrl = (address, contract) => `${this.coreApiUrl}${this.contractAbiEndpoint}/${address}/${contract}`;
        this.getReadOnlyFunctionCallApiUrl = (contractAddress, contractName, functionName) => `${this.coreApiUrl}${this.readOnlyFunctionCallEndpoint}/${contractAddress}/${contractName}/${encodeURIComponent(functionName)}`;
        this.getInfoUrl = () => `${this.coreApiUrl}/v2/info`;
        this.getBlockTimeInfoUrl = () => `${this.coreApiUrl}/extended/v1/info/network_block_times`;
        this.getPoxInfoUrl = () => `${this.coreApiUrl}/v2/pox`;
        this.getRewardsUrl = (address, options) => {
            let url = `${this.coreApiUrl}/extended/v1/burnchain/rewards/${address}`;
            if (options) {
                url = `${url}?limit=${options.limit}&offset=${options.offset}`;
            }
            return url;
        };
        this.getRewardsTotalUrl = (address) => `${this.coreApiUrl}/extended/v1/burnchain/rewards/${address}/total`;
        this.getRewardHoldersUrl = (address, options) => {
            let url = `${this.coreApiUrl}/extended/v1/burnchain/reward_slot_holders/${address}`;
            if (options) {
                url = `${url}?limit=${options.limit}&offset=${options.offset}`;
            }
            return url;
        };
        this.getStackerInfoUrl = (contractAddress, contractName) => `${this.coreApiUrl}${this.readOnlyFunctionCallEndpoint}
    ${contractAddress}/${contractName}/get-stacker-info`;
        this.getDataVarUrl = (contractAddress, contractName, dataVarName) => `${this.coreApiUrl}/v2/data_var/${contractAddress}/${contractName}/${dataVarName}?proof=0`;
        this.coreApiUrl = networkConfig.url;
        this.fetchFn = networkConfig.fetchFn ?? (0, fetch_1.createFetchFn)();
    }
    getNameInfo(fullyQualifiedName) {
        const nameLookupURL = `${this.bnsLookupUrl}/v1/names/${fullyQualifiedName}`;
        return this.fetchFn(nameLookupURL)
            .then(resp => {
            if (resp.status === 404) {
                throw new Error('Name not found');
            }
            else if (resp.status !== 200) {
                throw new Error(`Bad response status: ${resp.status}`);
            }
            else {
                return resp.json();
            }
        })
            .then(nameInfo => {
            if (nameInfo.address) {
                return Object.assign({}, nameInfo, { address: nameInfo.address });
            }
            else {
                return nameInfo;
            }
        });
    }
}
exports.StacksNetwork = StacksNetwork;
StacksNetwork.fromName = (networkName) => {
    switch (networkName) {
        case 'mainnet':
            return new StacksMainnet();
        case 'testnet':
            return new StacksTestnet();
        default:
            throw new Error(`Invalid network name provided. Must be one of the following: ${exports.StacksNetworks.join(', ')}`);
    }
};
StacksNetwork.fromNameOrNetwork = (network) => {
    if (typeof network !== 'string' && 'version' in network) {
        return network;
    }
    return StacksNetwork.fromName(network);
};
class StacksMainnet extends StacksNetwork {
    constructor(opts) {
        super({
            url: opts?.url ?? exports.HIRO_MAINNET_DEFAULT,
            fetchFn: opts?.fetchFn,
        });
        this.version = common_1.TransactionVersion.Mainnet;
        this.chainId = common_1.ChainID.Mainnet;
    }
}
exports.StacksMainnet = StacksMainnet;
class StacksTestnet extends StacksNetwork {
    constructor(opts) {
        super({
            url: opts?.url ?? exports.HIRO_TESTNET_DEFAULT,
            fetchFn: opts?.fetchFn,
        });
        this.version = common_1.TransactionVersion.Testnet;
        this.chainId = common_1.ChainID.Testnet;
    }
}
exports.StacksTestnet = StacksTestnet;
class StacksMocknet extends StacksNetwork {
    constructor(opts) {
        super({
            url: opts?.url ?? exports.HIRO_MOCKNET_DEFAULT,
            fetchFn: opts?.fetchFn,
        });
        this.version = common_1.TransactionVersion.Testnet;
        this.chainId = common_1.ChainID.Testnet;
    }
}
exports.StacksMocknet = StacksMocknet;

},{"./fetch":62,"@stacks/common":36}],65:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractProfile = exports.verifyProfileToken = exports.wrapProfileToken = exports.signProfileToken = exports.resolveZoneFileToPerson = exports.resolveZoneFileToProfile = exports.getTokenFileUrl = exports.makeProfileZoneFile = exports.Person = exports.Profile = void 0;
var profile_1 = require("./profile");
Object.defineProperty(exports, "Profile", { enumerable: true, get: function () { return profile_1.Profile; } });
Object.defineProperty(exports, "Person", { enumerable: true, get: function () { return profile_1.Person; } });
Object.defineProperty(exports, "makeProfileZoneFile", { enumerable: true, get: function () { return profile_1.makeProfileZoneFile; } });
Object.defineProperty(exports, "getTokenFileUrl", { enumerable: true, get: function () { return profile_1.getTokenFileUrl; } });
Object.defineProperty(exports, "resolveZoneFileToProfile", { enumerable: true, get: function () { return profile_1.resolveZoneFileToProfile; } });
var profileSchemas_1 = require("./profileSchemas");
Object.defineProperty(exports, "resolveZoneFileToPerson", { enumerable: true, get: function () { return profileSchemas_1.resolveZoneFileToPerson; } });
var profileTokens_1 = require("./profileTokens");
Object.defineProperty(exports, "signProfileToken", { enumerable: true, get: function () { return profileTokens_1.signProfileToken; } });
Object.defineProperty(exports, "wrapProfileToken", { enumerable: true, get: function () { return profileTokens_1.wrapProfileToken; } });
Object.defineProperty(exports, "verifyProfileToken", { enumerable: true, get: function () { return profileTokens_1.verifyProfileToken; } });
Object.defineProperty(exports, "extractProfile", { enumerable: true, get: function () { return profileTokens_1.extractProfile; } });

},{"./profile":66,"./profileSchemas":67,"./profileTokens":71}],66:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveZoneFileToProfile = exports.getTokenFileUrl = exports.makeProfileZoneFile = exports.Person = exports.Profile = void 0;
const profileTokens_1 = require("./profileTokens");
const profileSchemas_1 = require("./profileSchemas");
const personUtils_1 = require("./profileSchemas/personUtils");
const zone_file_1 = require("zone-file");
const inspector = __importStar(require("schema-inspector"));
const common_1 = require("@stacks/common");
const network_1 = require("@stacks/network");
const schemaDefinition = {
    type: 'object',
    properties: {
        '@context': { type: 'string', optional: true },
        '@type': { type: 'string' },
    },
};
class Profile {
    constructor(profile = {}) {
        this._profile = Object.assign({}, {
            '@context': 'http://schema.org/',
        }, profile);
    }
    toJSON() {
        return Object.assign({}, this._profile);
    }
    toToken(privateKey) {
        return (0, profileTokens_1.signProfileToken)(this.toJSON(), privateKey);
    }
    static validateSchema(profile, strict = false) {
        schemaDefinition.strict = strict;
        return inspector.validate(schemaDefinition, profile);
    }
    static fromToken(token, publicKeyOrAddress = null) {
        const profile = (0, profileTokens_1.extractProfile)(token, publicKeyOrAddress);
        return new Profile(profile);
    }
    static makeZoneFile(domainName, tokenFileURL) {
        return makeProfileZoneFile(domainName, tokenFileURL);
    }
}
exports.Profile = Profile;
const personSchemaDefinition = {
    type: 'object',
    strict: false,
    properties: {
        '@context': { type: 'string', optional: true },
        '@type': { type: 'string' },
        '@id': { type: 'string', optional: true },
        name: { type: 'string', optional: true },
        givenName: { type: 'string', optional: true },
        familyName: { type: 'string', optional: true },
        description: { type: 'string', optional: true },
        image: {
            type: 'array',
            optional: true,
            items: {
                type: 'object',
                properties: {
                    '@type': { type: 'string' },
                    name: { type: 'string', optional: true },
                    contentUrl: { type: 'string', optional: true },
                },
            },
        },
        website: {
            type: 'array',
            optional: true,
            items: {
                type: 'object',
                properties: {
                    '@type': { type: 'string' },
                    url: { type: 'string', optional: true },
                },
            },
        },
        account: {
            type: 'array',
            optional: true,
            items: {
                type: 'object',
                properties: {
                    '@type': { type: 'string' },
                    service: { type: 'string', optional: true },
                    identifier: { type: 'string', optional: true },
                    proofType: { type: 'string', optional: true },
                    proofUrl: { type: 'string', optional: true },
                    proofMessage: { type: 'string', optional: true },
                    proofSignature: { type: 'string', optional: true },
                },
            },
        },
        worksFor: {
            type: 'array',
            optional: true,
            items: {
                type: 'object',
                properties: {
                    '@type': { type: 'string' },
                    '@id': { type: 'string', optional: true },
                },
            },
        },
        knows: {
            type: 'array',
            optional: true,
            items: {
                type: 'object',
                properties: {
                    '@type': { type: 'string' },
                    '@id': { type: 'string', optional: true },
                },
            },
        },
        address: {
            type: 'object',
            optional: true,
            properties: {
                '@type': { type: 'string' },
                streetAddress: { type: 'string', optional: true },
                addressLocality: { type: 'string', optional: true },
                postalCode: { type: 'string', optional: true },
                addressCountry: { type: 'string', optional: true },
            },
        },
        birthDate: { type: 'string', optional: true },
        taxID: { type: 'string', optional: true },
    },
};
class Person extends Profile {
    constructor(profile = { '@type': 'Person' }) {
        super(profile);
        this._profile = Object.assign({}, {
            '@type': 'Person',
        }, this._profile);
    }
    static validateSchema(profile, strict = false) {
        personSchemaDefinition.strict = strict;
        return inspector.validate(schemaDefinition, profile);
    }
    static fromToken(token, publicKeyOrAddress = null) {
        const profile = (0, profileTokens_1.extractProfile)(token, publicKeyOrAddress);
        return new Person(profile);
    }
    static fromLegacyFormat(legacyProfile) {
        const profile = (0, profileSchemas_1.getPersonFromLegacyFormat)(legacyProfile);
        return new Person(profile);
    }
    toJSON() {
        return {
            profile: this.profile(),
            name: this.name(),
            givenName: this.givenName(),
            familyName: this.familyName(),
            description: this.description(),
            avatarUrl: this.avatarUrl(),
            verifiedAccounts: this.verifiedAccounts(),
            address: this.address(),
            birthDate: this.birthDate(),
            connections: this.connections(),
            organizations: this.organizations(),
        };
    }
    profile() {
        return Object.assign({}, this._profile);
    }
    name() {
        return (0, personUtils_1.getName)(this.profile());
    }
    givenName() {
        return (0, personUtils_1.getGivenName)(this.profile());
    }
    familyName() {
        return (0, personUtils_1.getFamilyName)(this.profile());
    }
    description() {
        return (0, personUtils_1.getDescription)(this.profile());
    }
    avatarUrl() {
        return (0, personUtils_1.getAvatarUrl)(this.profile());
    }
    verifiedAccounts(verifications) {
        return (0, personUtils_1.getVerifiedAccounts)(this.profile(), verifications);
    }
    address() {
        return (0, personUtils_1.getAddress)(this.profile());
    }
    birthDate() {
        return (0, personUtils_1.getBirthDate)(this.profile());
    }
    connections() {
        return (0, personUtils_1.getConnections)(this.profile());
    }
    organizations() {
        return (0, personUtils_1.getOrganizations)(this.profile());
    }
}
exports.Person = Person;
function makeProfileZoneFile(origin, tokenFileUrl) {
    if (!tokenFileUrl.includes('://')) {
        throw new Error('Invalid token file url');
    }
    const urlScheme = tokenFileUrl.split('://')[0];
    const urlParts = tokenFileUrl.split('://')[1].split('/');
    const domain = urlParts[0];
    const pathname = `/${urlParts.slice(1).join('/')}`;
    const zoneFile = {
        $origin: origin,
        $ttl: 3600,
        uri: [
            {
                name: '_http._tcp',
                priority: 10,
                weight: 1,
                target: `${urlScheme}://${domain}${pathname}`,
            },
        ],
    };
    const zoneFileTemplate = '{$origin}\n{$ttl}\n{uri}\n';
    return (0, zone_file_1.makeZoneFile)(zoneFile, zoneFileTemplate);
}
exports.makeProfileZoneFile = makeProfileZoneFile;
function getTokenFileUrl(zoneFileJson) {
    if (!zoneFileJson.hasOwnProperty('uri')) {
        return null;
    }
    if (!Array.isArray(zoneFileJson.uri)) {
        return null;
    }
    if (zoneFileJson.uri.length < 1) {
        return null;
    }
    const validRecords = zoneFileJson.uri.filter((record) => record.hasOwnProperty('target') && record.name === '_http._tcp');
    if (validRecords.length < 1) {
        return null;
    }
    const firstValidRecord = validRecords[0];
    if (!firstValidRecord.hasOwnProperty('target')) {
        return null;
    }
    let tokenFileUrl = firstValidRecord.target;
    if (tokenFileUrl.startsWith('https')) {
    }
    else if (tokenFileUrl.startsWith('http')) {
    }
    else {
        tokenFileUrl = `https://${tokenFileUrl}`;
    }
    return tokenFileUrl;
}
exports.getTokenFileUrl = getTokenFileUrl;
function resolveZoneFileToProfile(zoneFile, publicKeyOrAddress, fetchFn = (0, network_1.createFetchFn)()) {
    return new Promise((resolve, reject) => {
        let zoneFileJson = null;
        try {
            zoneFileJson = (0, zone_file_1.parseZoneFile)(zoneFile);
            if (!zoneFileJson.hasOwnProperty('$origin')) {
                zoneFileJson = null;
            }
        }
        catch (e) {
            reject(e);
        }
        let tokenFileUrl = null;
        if (zoneFileJson && Object.keys(zoneFileJson).length > 0) {
            tokenFileUrl = getTokenFileUrl(zoneFileJson);
        }
        else {
            try {
                return resolve(Person.fromLegacyFormat(JSON.parse(zoneFile)).profile());
            }
            catch (error) {
                return reject(error);
            }
        }
        if (tokenFileUrl) {
            fetchFn(tokenFileUrl)
                .then(response => response.text())
                .then(responseText => JSON.parse(responseText))
                .then(responseJson => {
                const tokenRecords = responseJson;
                const profile = (0, profileTokens_1.extractProfile)(tokenRecords[0].token, publicKeyOrAddress);
                resolve(profile);
            })
                .catch(error => {
                common_1.Logger.error(`resolveZoneFileToProfile: error fetching token file ${tokenFileUrl}: ${error}`);
                reject(error);
            });
        }
        else {
            common_1.Logger.debug('Token file url not found. Resolving to blank profile.');
            resolve({});
        }
    });
}
exports.resolveZoneFileToProfile = resolveZoneFileToProfile;

},{"./profileSchemas":67,"./profileSchemas/personUtils":69,"./profileTokens":71,"@stacks/common":36,"@stacks/network":63,"schema-inspector":125,"zone-file":127}],67:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveZoneFileToPerson = exports.getPersonFromLegacyFormat = void 0;
var personLegacy_1 = require("./personLegacy");
Object.defineProperty(exports, "getPersonFromLegacyFormat", { enumerable: true, get: function () { return personLegacy_1.getPersonFromLegacyFormat; } });
var personZoneFiles_1 = require("./personZoneFiles");
Object.defineProperty(exports, "resolveZoneFileToPerson", { enumerable: true, get: function () { return personZoneFiles_1.resolveZoneFileToPerson; } });

},{"./personLegacy":68,"./personZoneFiles":70}],68:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPersonFromLegacyFormat = void 0;
function formatAccount(serviceName, data) {
    let proofUrl;
    if (data.proof && data.proof.url) {
        proofUrl = data.proof.url;
    }
    return {
        '@type': 'Account',
        service: serviceName,
        identifier: data.username,
        proofType: 'http',
        proofUrl,
    };
}
function getPersonFromLegacyFormat(profile) {
    const profileData = {
        '@type': 'Person',
    };
    if (profile) {
        if (profile.name && profile.name.formatted) {
            profileData.name = profile.name.formatted;
        }
        if (profile.bio) {
            profileData.description = profile.bio;
        }
        if (profile.location && profile.location.formatted) {
            profileData.address = {
                '@type': 'PostalAddress',
                addressLocality: profile.location.formatted,
            };
        }
        const images = [];
        if (profile.avatar && profile.avatar.url) {
            images.push({
                '@type': 'ImageObject',
                name: 'avatar',
                contentUrl: profile.avatar.url,
            });
        }
        if (profile.cover && profile.cover.url) {
            images.push({
                '@type': 'ImageObject',
                name: 'cover',
                contentUrl: profile.cover.url,
            });
        }
        if (images.length) {
            profileData.image = images;
        }
        if (profile.website) {
            profileData.website = [
                {
                    '@type': 'WebSite',
                    url: profile.website,
                },
            ];
        }
        const accounts = [];
        if (profile.bitcoin && profile.bitcoin.address) {
            accounts.push({
                '@type': 'Account',
                role: 'payment',
                service: 'bitcoin',
                identifier: profile.bitcoin.address,
            });
        }
        if (profile.twitter && profile.twitter.username) {
            accounts.push(formatAccount('twitter', profile.twitter));
        }
        if (profile.facebook && profile.facebook.username) {
            accounts.push(formatAccount('facebook', profile.facebook));
        }
        if (profile.github && profile.github.username) {
            accounts.push(formatAccount('github', profile.github));
        }
        if (profile.auth) {
            if (profile.auth.length > 0) {
                if (profile.auth[0] && profile.auth[0].publicKeychain) {
                    accounts.push({
                        '@type': 'Account',
                        role: 'key',
                        service: 'bip32',
                        identifier: profile.auth[0].publicKeychain,
                    });
                }
            }
        }
        if (profile.pgp && profile.pgp.url) {
            accounts.push({
                '@type': 'Account',
                role: 'key',
                service: 'pgp',
                identifier: profile.pgp.fingerprint,
                contentUrl: profile.pgp.url,
            });
        }
        profileData.account = accounts;
    }
    return profileData;
}
exports.getPersonFromLegacyFormat = getPersonFromLegacyFormat;

},{}],69:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBirthDate = exports.getAddress = exports.getConnections = exports.getOrganizations = exports.getVerifiedAccounts = exports.getAvatarUrl = exports.getDescription = exports.getFamilyName = exports.getGivenName = exports.getName = void 0;
function getName(profile) {
    if (!profile) {
        return null;
    }
    let name = null;
    if (profile.name) {
        name = profile.name;
    }
    else if (profile.givenName || profile.familyName) {
        name = '';
        if (profile.givenName) {
            name = profile.givenName;
        }
        if (profile.familyName) {
            name += ` ${profile.familyName}`;
        }
    }
    return name;
}
exports.getName = getName;
function getGivenName(profile) {
    if (!profile) {
        return null;
    }
    let givenName = null;
    if (profile.givenName) {
        givenName = profile.givenName;
    }
    else if (profile.name) {
        const nameParts = profile.name.split(' ');
        givenName = nameParts.slice(0, -1).join(' ');
    }
    return givenName;
}
exports.getGivenName = getGivenName;
function getFamilyName(profile) {
    if (!profile) {
        return null;
    }
    let familyName = null;
    if (profile.familyName) {
        familyName = profile.familyName;
    }
    else if (profile.name) {
        const nameParts = profile.name.split(' ');
        familyName = nameParts.pop();
    }
    return familyName;
}
exports.getFamilyName = getFamilyName;
function getDescription(profile) {
    if (!profile) {
        return null;
    }
    let description = null;
    if (profile.description) {
        description = profile.description;
    }
    return description;
}
exports.getDescription = getDescription;
function getAvatarUrl(profile) {
    if (!profile) {
        return null;
    }
    let avatarContentUrl = null;
    if (profile.image) {
        profile.image.map((image) => {
            if (image.name === 'avatar') {
                avatarContentUrl = image.contentUrl;
                return avatarContentUrl;
            }
            else {
                return null;
            }
        });
    }
    return avatarContentUrl;
}
exports.getAvatarUrl = getAvatarUrl;
function getVerifiedAccounts(profile, verifications) {
    if (!profile) {
        return null;
    }
    const filteredAccounts = [];
    if (profile.hasOwnProperty('account') && verifications) {
        profile.account.map((account) => {
            let accountIsValid = false;
            let proofUrl = null;
            verifications.map(verification => {
                if (verification.hasOwnProperty('proof_url')) {
                    verification.proofUrl = verification.proof_url;
                }
                if (verification.valid &&
                    verification.service === account.service &&
                    verification.identifier === account.identifier &&
                    verification.proofUrl) {
                    accountIsValid = true;
                    proofUrl = verification.proofUrl;
                    return true;
                }
                else {
                    return false;
                }
            });
            if (accountIsValid) {
                account.proofUrl = proofUrl;
                filteredAccounts.push(account);
                return account;
            }
            else {
                return null;
            }
        });
    }
    return filteredAccounts;
}
exports.getVerifiedAccounts = getVerifiedAccounts;
function getOrganizations(profile) {
    if (!profile) {
        return null;
    }
    const organizations = [];
    if (profile.hasOwnProperty('worksFor')) {
        return profile.worksFor;
    }
    return organizations;
}
exports.getOrganizations = getOrganizations;
function getConnections(profile) {
    if (!profile) {
        return null;
    }
    let connections = [];
    if (profile.hasOwnProperty('knows')) {
        connections = profile.knows;
    }
    return connections;
}
exports.getConnections = getConnections;
function getAddress(profile) {
    if (!profile) {
        return null;
    }
    let addressString = null;
    if (profile.hasOwnProperty('address')) {
        const addressParts = [];
        if (profile.address.hasOwnProperty('streetAddress')) {
            addressParts.push(profile.address.streetAddress);
        }
        if (profile.address.hasOwnProperty('addressLocality')) {
            addressParts.push(profile.address.addressLocality);
        }
        if (profile.address.hasOwnProperty('postalCode')) {
            addressParts.push(profile.address.postalCode);
        }
        if (profile.address.hasOwnProperty('addressCountry')) {
            addressParts.push(profile.address.addressCountry);
        }
        if (addressParts.length) {
            addressString = addressParts.join(', ');
        }
    }
    return addressString;
}
exports.getAddress = getAddress;
function getBirthDate(profile) {
    if (!profile) {
        return null;
    }
    const monthNames = [
        'January',
        'February',
        'March',
        'April',
        'May',
        'June',
        'July',
        'August',
        'September',
        'October',
        'November',
        'December',
    ];
    let birthDateString = null;
    if (profile.hasOwnProperty('birthDate')) {
        const date = new Date(profile.birthDate);
        birthDateString = `${monthNames[date.getMonth()]} ${date.getDate()}, ${date.getFullYear()}`;
    }
    return birthDateString;
}
exports.getBirthDate = getBirthDate;

},{}],70:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveZoneFileToPerson = void 0;
const network_1 = require("@stacks/network");
const zone_file_1 = require("zone-file");
const profile_1 = require("../profile");
const profileTokens_1 = require("../profileTokens");
function resolveZoneFileToPerson(zoneFile, publicKeyOrAddress, callback, fetchFn = (0, network_1.createFetchFn)()) {
    let zoneFileJson = null;
    try {
        zoneFileJson = (0, zone_file_1.parseZoneFile)(zoneFile);
        if (!zoneFileJson.hasOwnProperty('$origin')) {
            zoneFileJson = null;
            throw new Error('zone file is missing an origin');
        }
    }
    catch (e) {
        console.error(e);
    }
    let tokenFileUrl = null;
    if (zoneFileJson && Object.keys(zoneFileJson).length > 0) {
        tokenFileUrl = (0, profile_1.getTokenFileUrl)(zoneFileJson);
    }
    else {
        let profile = null;
        try {
            profile = JSON.parse(zoneFile);
            const person = profile_1.Person.fromLegacyFormat(profile);
            profile = person.profile();
        }
        catch (error) {
            console.warn(error);
        }
        callback(profile);
        return;
    }
    if (tokenFileUrl) {
        fetchFn(tokenFileUrl)
            .then(response => response.text())
            .then(responseText => JSON.parse(responseText))
            .then(responseJson => {
            const tokenRecords = responseJson;
            const token = tokenRecords[0].token;
            const profile = (0, profileTokens_1.extractProfile)(token, publicKeyOrAddress);
            callback(profile);
        })
            .catch(error => {
            console.warn(error);
        });
    }
    else {
        console.warn('Token file url not found');
        callback({});
    }
}
exports.resolveZoneFileToPerson = resolveZoneFileToPerson;

},{"../profile":66,"../profileTokens":71,"@stacks/network":63,"zone-file":127}],71:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractProfile = exports.verifyProfileToken = exports.wrapProfileToken = exports.signProfileToken = void 0;
const jsontokens_1 = require("jsontokens");
const common_1 = require("@stacks/common");
const transactions_1 = require("@stacks/transactions");
function signProfileToken(profile, privateKey, subject, issuer, signingAlgorithm = 'ES256K', issuedAt = new Date(), expiresAt = (0, common_1.nextYear)()) {
    if (signingAlgorithm !== 'ES256K') {
        throw new Error('Signing algorithm not supported');
    }
    const publicKey = jsontokens_1.SECP256K1Client.derivePublicKey(privateKey);
    if (!subject) {
        subject = { publicKey };
    }
    if (!issuer) {
        issuer = { publicKey };
    }
    const tokenSigner = new jsontokens_1.TokenSigner(signingAlgorithm, privateKey);
    const payload = {
        jti: (0, common_1.makeUUID4)(),
        iat: issuedAt.toISOString(),
        exp: expiresAt.toISOString(),
        subject,
        issuer,
        claim: profile,
    };
    return tokenSigner.sign(payload);
}
exports.signProfileToken = signProfileToken;
function wrapProfileToken(token) {
    return {
        token,
        decodedToken: (0, jsontokens_1.decodeToken)(token),
    };
}
exports.wrapProfileToken = wrapProfileToken;
function verifyProfileToken(token, publicKeyOrAddress) {
    const decodedToken = (0, jsontokens_1.decodeToken)(token);
    const payload = decodedToken.payload;
    if (typeof payload === 'string') {
        throw new Error('Unexpected token payload type of string');
    }
    if (payload.hasOwnProperty('subject') && payload.subject) {
        if (!payload.subject.hasOwnProperty('publicKey')) {
            throw new Error("Token doesn't have a subject public key");
        }
    }
    else {
        throw new Error("Token doesn't have a subject");
    }
    if (payload.hasOwnProperty('issuer') && payload.issuer) {
        if (!payload.issuer.hasOwnProperty('publicKey')) {
            throw new Error("Token doesn't have an issuer public key");
        }
    }
    else {
        throw new Error("Token doesn't have an issuer");
    }
    if (!payload.hasOwnProperty('claim')) {
        throw new Error("Token doesn't have a claim");
    }
    const issuerPublicKey = payload.issuer.publicKey;
    const address = (0, transactions_1.getAddressFromPublicKey)(issuerPublicKey);
    if (publicKeyOrAddress === issuerPublicKey) {
    }
    else if (publicKeyOrAddress === address) {
    }
    else {
        throw new Error('Token issuer public key does not match the verifying value');
    }
    const tokenVerifier = new jsontokens_1.TokenVerifier(decodedToken.header.alg, issuerPublicKey);
    if (!tokenVerifier) {
        throw new Error('Invalid token verifier');
    }
    const tokenVerified = tokenVerifier.verify(token);
    if (!tokenVerified) {
        throw new Error('Token verification failed');
    }
    return decodedToken;
}
exports.verifyProfileToken = verifyProfileToken;
function extractProfile(token, publicKeyOrAddress = null) {
    let decodedToken;
    if (publicKeyOrAddress) {
        decodedToken = verifyProfileToken(token, publicKeyOrAddress);
    }
    else {
        decodedToken = (0, jsontokens_1.decodeToken)(token);
    }
    let profile = {};
    if (decodedToken.hasOwnProperty('payload')) {
        const payload = decodedToken.payload;
        if (typeof payload === 'string') {
            throw new Error('Unexpected token payload type of string');
        }
        if (payload.hasOwnProperty('claim')) {
            profile = payload.claim;
        }
    }
    return profile;
}
exports.extractProfile = extractProfile;

},{"@stacks/common":36,"@stacks/transactions":93,"jsontokens":121}],72:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deserializeAuthorization = exports.serializeAuthorization = exports.setSponsor = exports.setSponsorNonce = exports.setNonce = exports.getFee = exports.setFee = exports.verifyOrigin = exports.intoInitialSighashAuth = exports.createSponsoredAuth = exports.createStandardAuth = exports.nextVerification = exports.nextSignature = exports.makeSigHashPreSign = exports.deserializeSpendingCondition = exports.serializeSpendingCondition = exports.deserializeMultiSigSpendingCondition = exports.deserializeSingleSigSpendingCondition = exports.serializeMultiSigSpendingCondition = exports.serializeSingleSigSpendingCondition = exports.isSingleSig = exports.createMultiSigSpendingCondition = exports.createSingleSigSpendingCondition = exports.emptyMessageSignature = void 0;
const common_1 = require("@stacks/common");
const constants_1 = require("./constants");
const utils_1 = require("./utils");
const signature_1 = require("./signature");
const types_1 = require("./types");
const keys_1 = require("./keys");
const errors_1 = require("./errors");
function emptyMessageSignature() {
    return {
        type: constants_1.StacksMessageType.MessageSignature,
        data: (0, common_1.bytesToHex)(new Uint8Array(constants_1.RECOVERABLE_ECDSA_SIG_LENGTH_BYTES)),
    };
}
exports.emptyMessageSignature = emptyMessageSignature;
function createSingleSigSpendingCondition(hashMode, pubKey, nonce, fee) {
    const signer = (0, types_1.addressFromPublicKeys)(0, hashMode, 1, [(0, keys_1.createStacksPublicKey)(pubKey)]).hash160;
    const keyEncoding = (0, keys_1.isCompressed)((0, keys_1.createStacksPublicKey)(pubKey))
        ? constants_1.PubKeyEncoding.Compressed
        : constants_1.PubKeyEncoding.Uncompressed;
    return {
        hashMode,
        signer,
        nonce: (0, common_1.intToBigInt)(nonce, false),
        fee: (0, common_1.intToBigInt)(fee, false),
        keyEncoding,
        signature: emptyMessageSignature(),
    };
}
exports.createSingleSigSpendingCondition = createSingleSigSpendingCondition;
function createMultiSigSpendingCondition(hashMode, numSigs, pubKeys, nonce, fee) {
    const stacksPublicKeys = pubKeys.map(keys_1.createStacksPublicKey);
    const signer = (0, types_1.addressFromPublicKeys)(0, hashMode, numSigs, stacksPublicKeys).hash160;
    return {
        hashMode,
        signer,
        nonce: (0, common_1.intToBigInt)(nonce, false),
        fee: (0, common_1.intToBigInt)(fee, false),
        fields: [],
        signaturesRequired: numSigs,
    };
}
exports.createMultiSigSpendingCondition = createMultiSigSpendingCondition;
function isSingleSig(condition) {
    return 'signature' in condition;
}
exports.isSingleSig = isSingleSig;
function clearCondition(condition) {
    const cloned = (0, utils_1.cloneDeep)(condition);
    cloned.nonce = 0;
    cloned.fee = 0;
    if (isSingleSig(cloned)) {
        cloned.signature = emptyMessageSignature();
    }
    else {
        cloned.fields = [];
    }
    return {
        ...cloned,
        nonce: BigInt(0),
        fee: BigInt(0),
    };
}
function serializeSingleSigSpendingCondition(condition) {
    const bytesArray = [
        condition.hashMode,
        (0, common_1.hexToBytes)(condition.signer),
        (0, common_1.intToBytes)(condition.nonce, false, 8),
        (0, common_1.intToBytes)(condition.fee, false, 8),
        condition.keyEncoding,
        (0, signature_1.serializeMessageSignature)(condition.signature),
    ];
    return (0, common_1.concatArray)(bytesArray);
}
exports.serializeSingleSigSpendingCondition = serializeSingleSigSpendingCondition;
function serializeMultiSigSpendingCondition(condition) {
    const bytesArray = [
        condition.hashMode,
        (0, common_1.hexToBytes)(condition.signer),
        (0, common_1.intToBytes)(condition.nonce, false, 8),
        (0, common_1.intToBytes)(condition.fee, false, 8),
    ];
    const fields = (0, types_1.createLPList)(condition.fields);
    bytesArray.push((0, types_1.serializeLPList)(fields));
    const numSigs = new Uint8Array(2);
    (0, common_1.writeUInt16BE)(numSigs, condition.signaturesRequired, 0);
    bytesArray.push(numSigs);
    return (0, common_1.concatArray)(bytesArray);
}
exports.serializeMultiSigSpendingCondition = serializeMultiSigSpendingCondition;
function deserializeSingleSigSpendingCondition(hashMode, bytesReader) {
    const signer = (0, common_1.bytesToHex)(bytesReader.readBytes(20));
    const nonce = BigInt(`0x${(0, common_1.bytesToHex)(bytesReader.readBytes(8))}`);
    const fee = BigInt(`0x${(0, common_1.bytesToHex)(bytesReader.readBytes(8))}`);
    const keyEncoding = bytesReader.readUInt8Enum(constants_1.PubKeyEncoding, n => {
        throw new errors_1.DeserializationError(`Could not parse ${n} as PubKeyEncoding`);
    });
    if (hashMode === constants_1.AddressHashMode.SerializeP2WPKH && keyEncoding != constants_1.PubKeyEncoding.Compressed) {
        throw new errors_1.DeserializationError('Failed to parse singlesig spending condition: incomaptible hash mode and key encoding');
    }
    const signature = (0, signature_1.deserializeMessageSignature)(bytesReader);
    return {
        hashMode,
        signer,
        nonce,
        fee,
        keyEncoding,
        signature,
    };
}
exports.deserializeSingleSigSpendingCondition = deserializeSingleSigSpendingCondition;
function deserializeMultiSigSpendingCondition(hashMode, bytesReader) {
    const signer = (0, common_1.bytesToHex)(bytesReader.readBytes(20));
    const nonce = BigInt('0x' + (0, common_1.bytesToHex)(bytesReader.readBytes(8)));
    const fee = BigInt('0x' + (0, common_1.bytesToHex)(bytesReader.readBytes(8)));
    const fields = (0, types_1.deserializeLPList)(bytesReader, constants_1.StacksMessageType.TransactionAuthField)
        .values;
    let haveUncompressed = false;
    let numSigs = 0;
    for (const field of fields) {
        switch (field.contents.type) {
            case constants_1.StacksMessageType.PublicKey:
                if (!(0, keys_1.isCompressed)(field.contents))
                    haveUncompressed = true;
                break;
            case constants_1.StacksMessageType.MessageSignature:
                if (field.pubKeyEncoding === constants_1.PubKeyEncoding.Uncompressed)
                    haveUncompressed = true;
                numSigs += 1;
                if (numSigs === 65536)
                    throw new errors_1.VerificationError('Failed to parse multisig spending condition: too many signatures');
                break;
        }
    }
    const signaturesRequired = bytesReader.readUInt16BE();
    if (haveUncompressed && hashMode === constants_1.AddressHashMode.SerializeP2SH)
        throw new errors_1.VerificationError('Uncompressed keys are not allowed in this hash mode');
    return {
        hashMode,
        signer,
        nonce,
        fee,
        fields,
        signaturesRequired,
    };
}
exports.deserializeMultiSigSpendingCondition = deserializeMultiSigSpendingCondition;
function serializeSpendingCondition(condition) {
    if (isSingleSig(condition)) {
        return serializeSingleSigSpendingCondition(condition);
    }
    return serializeMultiSigSpendingCondition(condition);
}
exports.serializeSpendingCondition = serializeSpendingCondition;
function deserializeSpendingCondition(bytesReader) {
    const hashMode = bytesReader.readUInt8Enum(constants_1.AddressHashMode, n => {
        throw new errors_1.DeserializationError(`Could not parse ${n} as AddressHashMode`);
    });
    if (hashMode === constants_1.AddressHashMode.SerializeP2PKH || hashMode === constants_1.AddressHashMode.SerializeP2WPKH) {
        return deserializeSingleSigSpendingCondition(hashMode, bytesReader);
    }
    else {
        return deserializeMultiSigSpendingCondition(hashMode, bytesReader);
    }
}
exports.deserializeSpendingCondition = deserializeSpendingCondition;
function makeSigHashPreSign(curSigHash, authType, fee, nonce) {
    const hashLength = 32 + 1 + 8 + 8;
    const sigHash = curSigHash +
        (0, common_1.bytesToHex)(new Uint8Array([authType])) +
        (0, common_1.bytesToHex)((0, common_1.intToBytes)(fee, false, 8)) +
        (0, common_1.bytesToHex)((0, common_1.intToBytes)(nonce, false, 8));
    if ((0, common_1.hexToBytes)(sigHash).byteLength !== hashLength) {
        throw Error('Invalid signature hash length');
    }
    return (0, utils_1.txidFromData)((0, common_1.hexToBytes)(sigHash));
}
exports.makeSigHashPreSign = makeSigHashPreSign;
function makeSigHashPostSign(curSigHash, pubKey, signature) {
    const hashLength = 32 + 1 + constants_1.RECOVERABLE_ECDSA_SIG_LENGTH_BYTES;
    const pubKeyEncoding = (0, keys_1.isCompressed)(pubKey)
        ? constants_1.PubKeyEncoding.Compressed
        : constants_1.PubKeyEncoding.Uncompressed;
    const sigHash = curSigHash + (0, utils_1.leftPadHex)(pubKeyEncoding.toString(16)) + signature.data;
    const sigHashBytes = (0, common_1.hexToBytes)(sigHash);
    if (sigHashBytes.byteLength > hashLength) {
        throw Error('Invalid signature hash length');
    }
    return (0, utils_1.txidFromData)(sigHashBytes);
}
function nextSignature(curSigHash, authType, fee, nonce, privateKey) {
    const sigHashPreSign = makeSigHashPreSign(curSigHash, authType, fee, nonce);
    const signature = (0, keys_1.signWithKey)(privateKey, sigHashPreSign);
    const publicKey = (0, keys_1.getPublicKey)(privateKey);
    const nextSigHash = makeSigHashPostSign(sigHashPreSign, publicKey, signature);
    return {
        nextSig: signature,
        nextSigHash,
    };
}
exports.nextSignature = nextSignature;
function nextVerification(initialSigHash, authType, fee, nonce, pubKeyEncoding, signature) {
    const sigHashPreSign = makeSigHashPreSign(initialSigHash, authType, fee, nonce);
    const publicKey = (0, keys_1.createStacksPublicKey)((0, keys_1.publicKeyFromSignatureVrs)(sigHashPreSign, signature, pubKeyEncoding));
    const nextSigHash = makeSigHashPostSign(sigHashPreSign, publicKey, signature);
    return {
        pubKey: publicKey,
        nextSigHash,
    };
}
exports.nextVerification = nextVerification;
function newInitialSigHash() {
    const spendingCondition = createSingleSigSpendingCondition(constants_1.AddressHashMode.SerializeP2PKH, '', 0, 0);
    spendingCondition.signer = (0, types_1.createEmptyAddress)().hash160;
    spendingCondition.keyEncoding = constants_1.PubKeyEncoding.Compressed;
    spendingCondition.signature = emptyMessageSignature();
    return spendingCondition;
}
function verify(condition, initialSigHash, authType) {
    if (isSingleSig(condition)) {
        return verifySingleSig(condition, initialSigHash, authType);
    }
    else {
        return verifyMultiSig(condition, initialSigHash, authType);
    }
}
function verifySingleSig(condition, initialSigHash, authType) {
    const { pubKey, nextSigHash } = nextVerification(initialSigHash, authType, condition.fee, condition.nonce, condition.keyEncoding, condition.signature);
    const addrBytes = (0, types_1.addressFromPublicKeys)(0, condition.hashMode, 1, [pubKey]).hash160;
    if (addrBytes !== condition.signer)
        throw new errors_1.VerificationError(`Signer hash does not equal hash of public key(s): ${addrBytes} != ${condition.signer}`);
    return nextSigHash;
}
function verifyMultiSig(condition, initialSigHash, authType) {
    const publicKeys = [];
    let curSigHash = initialSigHash;
    let haveUncompressed = false;
    let numSigs = 0;
    for (const field of condition.fields) {
        let foundPubKey;
        switch (field.contents.type) {
            case constants_1.StacksMessageType.PublicKey:
                if (!(0, keys_1.isCompressed)(field.contents))
                    haveUncompressed = true;
                foundPubKey = field.contents;
                break;
            case constants_1.StacksMessageType.MessageSignature:
                if (field.pubKeyEncoding === constants_1.PubKeyEncoding.Uncompressed)
                    haveUncompressed = true;
                const { pubKey, nextSigHash } = nextVerification(curSigHash, authType, condition.fee, condition.nonce, field.pubKeyEncoding, field.contents);
                curSigHash = nextSigHash;
                foundPubKey = pubKey;
                numSigs += 1;
                if (numSigs === 65536)
                    throw new errors_1.VerificationError('Too many signatures');
                break;
        }
        publicKeys.push(foundPubKey);
    }
    if (numSigs !== condition.signaturesRequired)
        throw new errors_1.VerificationError('Incorrect number of signatures');
    if (haveUncompressed && condition.hashMode === constants_1.AddressHashMode.SerializeP2SH)
        throw new errors_1.VerificationError('Uncompressed keys are not allowed in this hash mode');
    const addrBytes = (0, types_1.addressFromPublicKeys)(0, condition.hashMode, condition.signaturesRequired, publicKeys).hash160;
    if (addrBytes !== condition.signer)
        throw new errors_1.VerificationError(`Signer hash does not equal hash of public key(s): ${addrBytes} != ${condition.signer}`);
    return curSigHash;
}
function createStandardAuth(spendingCondition) {
    return {
        authType: constants_1.AuthType.Standard,
        spendingCondition,
    };
}
exports.createStandardAuth = createStandardAuth;
function createSponsoredAuth(spendingCondition, sponsorSpendingCondition) {
    return {
        authType: constants_1.AuthType.Sponsored,
        spendingCondition,
        sponsorSpendingCondition: sponsorSpendingCondition
            ? sponsorSpendingCondition
            : createSingleSigSpendingCondition(constants_1.AddressHashMode.SerializeP2PKH, '0'.repeat(66), 0, 0),
    };
}
exports.createSponsoredAuth = createSponsoredAuth;
function intoInitialSighashAuth(auth) {
    if (auth.spendingCondition) {
        switch (auth.authType) {
            case constants_1.AuthType.Standard:
                return createStandardAuth(clearCondition(auth.spendingCondition));
            case constants_1.AuthType.Sponsored:
                return createSponsoredAuth(clearCondition(auth.spendingCondition), newInitialSigHash());
            default:
                throw new errors_1.SigningError('Unexpected authorization type for signing');
        }
    }
    throw new Error('Authorization missing SpendingCondition');
}
exports.intoInitialSighashAuth = intoInitialSighashAuth;
function verifyOrigin(auth, initialSigHash) {
    switch (auth.authType) {
        case constants_1.AuthType.Standard:
            return verify(auth.spendingCondition, initialSigHash, constants_1.AuthType.Standard);
        case constants_1.AuthType.Sponsored:
            return verify(auth.spendingCondition, initialSigHash, constants_1.AuthType.Standard);
        default:
            throw new errors_1.SigningError('Invalid origin auth type');
    }
}
exports.verifyOrigin = verifyOrigin;
function setFee(auth, amount) {
    switch (auth.authType) {
        case constants_1.AuthType.Standard:
            const spendingCondition = {
                ...auth.spendingCondition,
                fee: (0, common_1.intToBigInt)(amount, false),
            };
            return { ...auth, spendingCondition };
        case constants_1.AuthType.Sponsored:
            const sponsorSpendingCondition = {
                ...auth.sponsorSpendingCondition,
                fee: (0, common_1.intToBigInt)(amount, false),
            };
            return { ...auth, sponsorSpendingCondition };
    }
}
exports.setFee = setFee;
function getFee(auth) {
    switch (auth.authType) {
        case constants_1.AuthType.Standard:
            return auth.spendingCondition.fee;
        case constants_1.AuthType.Sponsored:
            return auth.sponsorSpendingCondition.fee;
    }
}
exports.getFee = getFee;
function setNonce(auth, nonce) {
    const spendingCondition = {
        ...auth.spendingCondition,
        nonce: (0, common_1.intToBigInt)(nonce, false),
    };
    return {
        ...auth,
        spendingCondition,
    };
}
exports.setNonce = setNonce;
function setSponsorNonce(auth, nonce) {
    const sponsorSpendingCondition = {
        ...auth.sponsorSpendingCondition,
        nonce: (0, common_1.intToBigInt)(nonce, false),
    };
    return {
        ...auth,
        sponsorSpendingCondition,
    };
}
exports.setSponsorNonce = setSponsorNonce;
function setSponsor(auth, sponsorSpendingCondition) {
    const sc = {
        ...sponsorSpendingCondition,
        nonce: (0, common_1.intToBigInt)(sponsorSpendingCondition.nonce, false),
        fee: (0, common_1.intToBigInt)(sponsorSpendingCondition.fee, false),
    };
    return {
        ...auth,
        sponsorSpendingCondition: sc,
    };
}
exports.setSponsor = setSponsor;
function serializeAuthorization(auth) {
    const bytesArray = [];
    bytesArray.push(auth.authType);
    switch (auth.authType) {
        case constants_1.AuthType.Standard:
            bytesArray.push(serializeSpendingCondition(auth.spendingCondition));
            break;
        case constants_1.AuthType.Sponsored:
            bytesArray.push(serializeSpendingCondition(auth.spendingCondition));
            bytesArray.push(serializeSpendingCondition(auth.sponsorSpendingCondition));
            break;
    }
    return (0, common_1.concatArray)(bytesArray);
}
exports.serializeAuthorization = serializeAuthorization;
function deserializeAuthorization(bytesReader) {
    const authType = bytesReader.readUInt8Enum(constants_1.AuthType, n => {
        throw new errors_1.DeserializationError(`Could not parse ${n} as AuthType`);
    });
    let spendingCondition;
    switch (authType) {
        case constants_1.AuthType.Standard:
            spendingCondition = deserializeSpendingCondition(bytesReader);
            return createStandardAuth(spendingCondition);
        case constants_1.AuthType.Sponsored:
            spendingCondition = deserializeSpendingCondition(bytesReader);
            const sponsorSpendingCondition = deserializeSpendingCondition(bytesReader);
            return createSponsoredAuth(spendingCondition, sponsorSpendingCondition);
    }
}
exports.deserializeAuthorization = deserializeAuthorization;

},{"./constants":90,"./errors":92,"./keys":94,"./signature":98,"./types":102,"./utils":103,"@stacks/common":36}],73:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.estimateTransactionFeeWithFallback = exports.estimateTransactionByteLength = exports.sponsorTransaction = exports.callReadOnlyFunction = exports.makeContractNonFungiblePostCondition = exports.makeStandardNonFungiblePostCondition = exports.makeContractFungiblePostCondition = exports.makeStandardFungiblePostCondition = exports.makeContractSTXPostCondition = exports.makeStandardSTXPostCondition = exports.makeContractCall = exports.makeUnsignedContractCall = exports.estimateContractFunctionCall = exports.makeUnsignedContractDeploy = exports.makeContractDeploy = exports.estimateContractDeploy = exports.makeSTXTokenTransfer = exports.makeUnsignedSTXTokenTransfer = exports.getAbi = exports.broadcastRawTransaction = exports.broadcastTransaction = exports.estimateTransaction = exports.estimateTransferUnsafe = exports.estimateTransfer = exports.getNonce = void 0;
const common_1 = require("@stacks/common");
const network_1 = require("@stacks/network");
const c32check_1 = require("c32check");
const authorization_1 = require("./authorization");
const constants_1 = require("./constants");
const contract_abi_1 = require("./contract-abi");
const errors_1 = require("./errors");
const keys_1 = require("./keys");
const payload_1 = require("./payload");
const postcondition_1 = require("./postcondition");
const postcondition_types_1 = require("./postcondition-types");
const signer_1 = require("./signer");
const transaction_1 = require("./transaction");
const types_1 = require("./types");
const utils_1 = require("./utils");
async function getNonce(address, network) {
    const derivedNetwork = network_1.StacksNetwork.fromNameOrNetwork(network ?? new network_1.StacksMainnet());
    const url = derivedNetwork.getAccountApiUrl(address);
    const response = await derivedNetwork.fetchFn(url);
    if (!response.ok) {
        let msg = '';
        try {
            msg = await response.text();
        }
        catch (error) { }
        throw new Error(`Error fetching nonce. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: "${msg}"`);
    }
    const responseText = await response.text();
    const result = JSON.parse(responseText);
    return BigInt(result.nonce);
}
exports.getNonce = getNonce;
async function estimateTransfer(transaction, network) {
    if (transaction.payload.payloadType !== constants_1.PayloadType.TokenTransfer) {
        throw new Error(`Transaction fee estimation only possible with ${constants_1.PayloadType[constants_1.PayloadType.TokenTransfer]} transactions. Invoked with: ${constants_1.PayloadType[transaction.payload.payloadType]}`);
    }
    return estimateTransferUnsafe(transaction, network);
}
exports.estimateTransfer = estimateTransfer;
async function estimateTransferUnsafe(transaction, network) {
    const requestHeaders = {
        Accept: 'application/text',
    };
    const fetchOptions = {
        method: 'GET',
        headers: requestHeaders,
    };
    const derivedNetwork = network_1.StacksNetwork.fromNameOrNetwork(network ?? deriveNetwork(transaction));
    const url = derivedNetwork.getTransferFeeEstimateApiUrl();
    const response = await derivedNetwork.fetchFn(url, fetchOptions);
    if (!response.ok) {
        let msg = '';
        try {
            msg = await response.text();
        }
        catch (error) { }
        throw new Error(`Error estimating transaction fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: "${msg}"`);
    }
    const feeRateResult = await response.text();
    const txBytes = BigInt(transaction.serialize().byteLength);
    const feeRate = BigInt(feeRateResult);
    return feeRate * txBytes;
}
exports.estimateTransferUnsafe = estimateTransferUnsafe;
async function estimateTransaction(transactionPayload, estimatedLen, network) {
    const options = {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            transaction_payload: (0, common_1.bytesToHex)((0, payload_1.serializePayload)(transactionPayload)),
            ...(estimatedLen ? { estimated_len: estimatedLen } : {}),
        }),
    };
    const derivedNetwork = network_1.StacksNetwork.fromNameOrNetwork(network ?? new network_1.StacksMainnet());
    const url = derivedNetwork.getTransactionFeeEstimateApiUrl();
    const response = await derivedNetwork.fetchFn(url, options);
    if (!response.ok) {
        const body = await response.json().catch(() => ({}));
        if (body?.reason === 'NoEstimateAvailable') {
            throw new errors_1.NoEstimateAvailableError(body?.reason_data?.message ?? '');
        }
        throw new Error(`Error estimating transaction fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: "${body}"`);
    }
    const data = await response.json();
    return data.estimations;
}
exports.estimateTransaction = estimateTransaction;
async function broadcastTransaction(transaction, network, attachment) {
    const rawTx = transaction.serialize();
    const derivedNetwork = network_1.StacksNetwork.fromNameOrNetwork(network ?? deriveNetwork(transaction));
    const url = derivedNetwork.getBroadcastApiUrl();
    return broadcastRawTransaction(rawTx, url, attachment, derivedNetwork.fetchFn);
}
exports.broadcastTransaction = broadcastTransaction;
async function broadcastRawTransaction(rawTx, url, attachment, fetchFn = (0, network_1.createFetchFn)()) {
    const options = {
        method: 'POST',
        headers: { 'Content-Type': attachment ? 'application/json' : 'application/octet-stream' },
        body: attachment
            ? JSON.stringify({
                tx: (0, common_1.bytesToHex)(rawTx),
                attachment: (0, common_1.bytesToHex)(attachment),
            })
            : rawTx,
    };
    const response = await fetchFn(url, options);
    if (!response.ok) {
        try {
            return (await response.json());
        }
        catch (e) {
            throw Error(`Failed to broadcast transaction: ${e.message}`);
        }
    }
    const text = await response.text();
    const txid = text.replace(/["]+/g, '');
    if (!(0, utils_1.validateTxId)(txid))
        throw new Error(text);
    return { txid };
}
exports.broadcastRawTransaction = broadcastRawTransaction;
async function getAbi(address, contractName, network) {
    const options = {
        method: 'GET',
    };
    const derivedNetwork = network_1.StacksNetwork.fromNameOrNetwork(network);
    const url = derivedNetwork.getAbiApiUrl(address, contractName);
    const response = await derivedNetwork.fetchFn(url, options);
    if (!response.ok) {
        const msg = await response.text().catch(() => '');
        throw new Error(`Error fetching contract ABI for contract "${contractName}" at address ${address}. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: "${msg}"`);
    }
    return JSON.parse(await response.text());
}
exports.getAbi = getAbi;
function deriveNetwork(transaction) {
    switch (transaction.version) {
        case constants_1.TransactionVersion.Mainnet:
            return new network_1.StacksMainnet();
        case constants_1.TransactionVersion.Testnet:
            return new network_1.StacksTestnet();
    }
}
async function makeUnsignedSTXTokenTransfer(txOptions) {
    const defaultOptions = {
        fee: BigInt(0),
        nonce: BigInt(0),
        network: new network_1.StacksMainnet(),
        postConditionMode: constants_1.PostConditionMode.Deny,
        memo: '',
        sponsored: false,
    };
    const options = Object.assign(defaultOptions, txOptions);
    const payload = (0, payload_1.createTokenTransferPayload)(options.recipient, options.amount, options.memo);
    let authorization = null;
    let spendingCondition = null;
    if ('publicKey' in options) {
        spendingCondition = (0, authorization_1.createSingleSigSpendingCondition)(constants_1.AddressHashMode.SerializeP2PKH, options.publicKey, options.nonce, options.fee);
    }
    else {
        spendingCondition = (0, authorization_1.createMultiSigSpendingCondition)(constants_1.AddressHashMode.SerializeP2SH, options.numSignatures, options.publicKeys, options.nonce, options.fee);
    }
    if (options.sponsored) {
        authorization = (0, authorization_1.createSponsoredAuth)(spendingCondition);
    }
    else {
        authorization = (0, authorization_1.createStandardAuth)(spendingCondition);
    }
    const network = network_1.StacksNetwork.fromNameOrNetwork(options.network);
    const postConditions = [];
    if (options.postConditions && options.postConditions.length > 0) {
        options.postConditions.forEach(postCondition => {
            postConditions.push(postCondition);
        });
    }
    const lpPostConditions = (0, types_1.createLPList)(postConditions);
    const transaction = new transaction_1.StacksTransaction(network.version, authorization, payload, lpPostConditions, options.postConditionMode, options.anchorMode, network.chainId);
    if (txOptions.fee === undefined || txOptions.fee === null) {
        const fee = await estimateTransactionFeeWithFallback(transaction, network);
        transaction.setFee(fee);
    }
    if (txOptions.nonce === undefined || txOptions.nonce === null) {
        const addressVersion = options.network.version === constants_1.TransactionVersion.Mainnet
            ? constants_1.AddressVersion.MainnetSingleSig
            : constants_1.AddressVersion.TestnetSingleSig;
        const senderAddress = (0, c32check_1.c32address)(addressVersion, transaction.auth.spendingCondition.signer);
        const txNonce = await getNonce(senderAddress, options.network);
        transaction.setNonce(txNonce);
    }
    return transaction;
}
exports.makeUnsignedSTXTokenTransfer = makeUnsignedSTXTokenTransfer;
async function makeSTXTokenTransfer(txOptions) {
    if ('senderKey' in txOptions) {
        const publicKey = (0, keys_1.publicKeyToString)((0, keys_1.getPublicKey)((0, keys_1.createStacksPrivateKey)(txOptions.senderKey)));
        const options = (0, utils_1.omit)(txOptions, 'senderKey');
        const transaction = await makeUnsignedSTXTokenTransfer({ publicKey, ...options });
        const privKey = (0, keys_1.createStacksPrivateKey)(txOptions.senderKey);
        const signer = new signer_1.TransactionSigner(transaction);
        signer.signOrigin(privKey);
        return transaction;
    }
    else {
        const options = (0, utils_1.omit)(txOptions, 'signerKeys');
        const transaction = await makeUnsignedSTXTokenTransfer(options);
        const signer = new signer_1.TransactionSigner(transaction);
        let pubKeys = txOptions.publicKeys;
        for (const key of txOptions.signerKeys) {
            const pubKey = (0, keys_1.pubKeyfromPrivKey)(key);
            pubKeys = pubKeys.filter(pk => pk !== (0, common_1.bytesToHex)(pubKey.data));
            signer.signOrigin((0, keys_1.createStacksPrivateKey)(key));
        }
        for (const key of pubKeys) {
            signer.appendOrigin((0, keys_1.publicKeyFromBytes)((0, common_1.hexToBytes)(key)));
        }
        return transaction;
    }
}
exports.makeSTXTokenTransfer = makeSTXTokenTransfer;
async function estimateContractDeploy(transaction, network) {
    if (transaction.payload.payloadType !== constants_1.PayloadType.SmartContract &&
        transaction.payload.payloadType !== constants_1.PayloadType.VersionedSmartContract) {
        throw new Error(`Contract deploy fee estimation only possible with ${constants_1.PayloadType[constants_1.PayloadType.SmartContract]} transactions. Invoked with: ${constants_1.PayloadType[transaction.payload.payloadType]}`);
    }
    const requestHeaders = {
        Accept: 'application/text',
    };
    const fetchOptions = {
        method: 'GET',
        headers: requestHeaders,
    };
    const derivedNetwork = network_1.StacksNetwork.fromNameOrNetwork(network ?? deriveNetwork(transaction));
    const url = derivedNetwork.getTransferFeeEstimateApiUrl();
    const response = await derivedNetwork.fetchFn(url, fetchOptions);
    if (!response.ok) {
        const msg = await response.text().catch(() => '');
        throw new Error(`Error estimating contract deploy fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: "${msg}"`);
    }
    const feeRateResult = await response.text();
    const txBytes = (0, common_1.intToBigInt)(transaction.serialize().byteLength, false);
    const feeRate = (0, common_1.intToBigInt)(feeRateResult, false);
    return feeRate * txBytes;
}
exports.estimateContractDeploy = estimateContractDeploy;
async function makeContractDeploy(txOptions) {
    const privKey = (0, keys_1.createStacksPrivateKey)(txOptions.senderKey);
    const stacksPublicKey = (0, keys_1.getPublicKey)(privKey);
    const publicKey = (0, keys_1.publicKeyToString)(stacksPublicKey);
    const unsignedTxOptions = { ...txOptions, publicKey };
    const transaction = await makeUnsignedContractDeploy(unsignedTxOptions);
    if (txOptions.senderKey) {
        const signer = new signer_1.TransactionSigner(transaction);
        signer.signOrigin(privKey);
    }
    return transaction;
}
exports.makeContractDeploy = makeContractDeploy;
async function makeUnsignedContractDeploy(txOptions) {
    const defaultOptions = {
        fee: BigInt(0),
        nonce: BigInt(0),
        network: new network_1.StacksMainnet(),
        postConditionMode: constants_1.PostConditionMode.Deny,
        sponsored: false,
    };
    const options = Object.assign(defaultOptions, txOptions);
    const payload = (0, payload_1.createSmartContractPayload)(options.contractName, options.codeBody, options.clarityVersion);
    const addressHashMode = constants_1.AddressHashMode.SerializeP2PKH;
    const pubKey = (0, keys_1.createStacksPublicKey)(options.publicKey);
    let authorization = null;
    const spendingCondition = (0, authorization_1.createSingleSigSpendingCondition)(addressHashMode, (0, keys_1.publicKeyToString)(pubKey), options.nonce, options.fee);
    if (options.sponsored) {
        authorization = (0, authorization_1.createSponsoredAuth)(spendingCondition);
    }
    else {
        authorization = (0, authorization_1.createStandardAuth)(spendingCondition);
    }
    const network = network_1.StacksNetwork.fromNameOrNetwork(options.network);
    const postConditions = [];
    if (options.postConditions && options.postConditions.length > 0) {
        options.postConditions.forEach(postCondition => {
            postConditions.push(postCondition);
        });
    }
    const lpPostConditions = (0, types_1.createLPList)(postConditions);
    const transaction = new transaction_1.StacksTransaction(network.version, authorization, payload, lpPostConditions, options.postConditionMode, options.anchorMode, network.chainId);
    if (txOptions.fee === undefined || txOptions.fee === null) {
        const fee = await estimateTransactionFeeWithFallback(transaction, network);
        transaction.setFee(fee);
    }
    if (txOptions.nonce === undefined || txOptions.nonce === null) {
        const addressVersion = options.network.version === constants_1.TransactionVersion.Mainnet
            ? constants_1.AddressVersion.MainnetSingleSig
            : constants_1.AddressVersion.TestnetSingleSig;
        const senderAddress = (0, keys_1.publicKeyToAddress)(addressVersion, pubKey);
        const txNonce = await getNonce(senderAddress, options.network);
        transaction.setNonce(txNonce);
    }
    return transaction;
}
exports.makeUnsignedContractDeploy = makeUnsignedContractDeploy;
async function estimateContractFunctionCall(transaction, network) {
    if (transaction.payload.payloadType !== constants_1.PayloadType.ContractCall) {
        throw new Error(`Contract call fee estimation only possible with ${constants_1.PayloadType[constants_1.PayloadType.ContractCall]} transactions. Invoked with: ${constants_1.PayloadType[transaction.payload.payloadType]}`);
    }
    const requestHeaders = {
        Accept: 'application/text',
    };
    const fetchOptions = {
        method: 'GET',
        headers: requestHeaders,
    };
    const derivedNetwork = network_1.StacksNetwork.fromNameOrNetwork(network ?? deriveNetwork(transaction));
    const url = derivedNetwork.getTransferFeeEstimateApiUrl();
    const response = await derivedNetwork.fetchFn(url, fetchOptions);
    if (!response.ok) {
        const msg = await response.text().catch(() => '');
        throw new Error(`Error estimating contract call fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: "${msg}"`);
    }
    const feeRateResult = await response.text();
    const txBytes = (0, common_1.intToBigInt)(transaction.serialize().byteLength, false);
    const feeRate = (0, common_1.intToBigInt)(feeRateResult, false);
    return feeRate * txBytes;
}
exports.estimateContractFunctionCall = estimateContractFunctionCall;
async function makeUnsignedContractCall(txOptions) {
    const defaultOptions = {
        fee: BigInt(0),
        nonce: BigInt(0),
        network: new network_1.StacksMainnet(),
        postConditionMode: constants_1.PostConditionMode.Deny,
        sponsored: false,
    };
    const options = Object.assign(defaultOptions, txOptions);
    const payload = (0, payload_1.createContractCallPayload)(options.contractAddress, options.contractName, options.functionName, options.functionArgs);
    if (options?.validateWithAbi) {
        let abi;
        if (typeof options.validateWithAbi === 'boolean') {
            if (options?.network) {
                abi = await getAbi(options.contractAddress, options.contractName, options.network);
            }
            else {
                throw new Error('Network option must be provided in order to validate with ABI');
            }
        }
        else {
            abi = options.validateWithAbi;
        }
        (0, contract_abi_1.validateContractCall)(payload, abi);
    }
    let spendingCondition = null;
    let authorization = null;
    if ('publicKey' in options) {
        spendingCondition = (0, authorization_1.createSingleSigSpendingCondition)(constants_1.AddressHashMode.SerializeP2PKH, options.publicKey, options.nonce, options.fee);
    }
    else {
        spendingCondition = (0, authorization_1.createMultiSigSpendingCondition)(constants_1.AddressHashMode.SerializeP2SH, options.numSignatures, options.publicKeys, options.nonce, options.fee);
    }
    if (options.sponsored) {
        authorization = (0, authorization_1.createSponsoredAuth)(spendingCondition);
    }
    else {
        authorization = (0, authorization_1.createStandardAuth)(spendingCondition);
    }
    const network = network_1.StacksNetwork.fromNameOrNetwork(options.network);
    const postConditions = [];
    if (options.postConditions && options.postConditions.length > 0) {
        options.postConditions.forEach(postCondition => {
            postConditions.push(postCondition);
        });
    }
    const lpPostConditions = (0, types_1.createLPList)(postConditions);
    const transaction = new transaction_1.StacksTransaction(network.version, authorization, payload, lpPostConditions, options.postConditionMode, options.anchorMode, network.chainId);
    if (txOptions.fee === undefined || txOptions.fee === null) {
        const fee = await estimateTransactionFeeWithFallback(transaction, network);
        transaction.setFee(fee);
    }
    if (txOptions.nonce === undefined || txOptions.nonce === null) {
        const addressVersion = network.version === constants_1.TransactionVersion.Mainnet
            ? constants_1.AddressVersion.MainnetSingleSig
            : constants_1.AddressVersion.TestnetSingleSig;
        const senderAddress = (0, c32check_1.c32address)(addressVersion, transaction.auth.spendingCondition.signer);
        const txNonce = await getNonce(senderAddress, network);
        transaction.setNonce(txNonce);
    }
    return transaction;
}
exports.makeUnsignedContractCall = makeUnsignedContractCall;
async function makeContractCall(txOptions) {
    if ('senderKey' in txOptions) {
        const publicKey = (0, keys_1.publicKeyToString)((0, keys_1.getPublicKey)((0, keys_1.createStacksPrivateKey)(txOptions.senderKey)));
        const options = (0, utils_1.omit)(txOptions, 'senderKey');
        const transaction = await makeUnsignedContractCall({ publicKey, ...options });
        const privKey = (0, keys_1.createStacksPrivateKey)(txOptions.senderKey);
        const signer = new signer_1.TransactionSigner(transaction);
        signer.signOrigin(privKey);
        return transaction;
    }
    else {
        const options = (0, utils_1.omit)(txOptions, 'signerKeys');
        const transaction = await makeUnsignedContractCall(options);
        const signer = new signer_1.TransactionSigner(transaction);
        let pubKeys = txOptions.publicKeys;
        for (const key of txOptions.signerKeys) {
            const pubKey = (0, keys_1.pubKeyfromPrivKey)(key);
            pubKeys = pubKeys.filter(pk => pk !== (0, common_1.bytesToHex)(pubKey.data));
            signer.signOrigin((0, keys_1.createStacksPrivateKey)(key));
        }
        for (const key of pubKeys) {
            signer.appendOrigin((0, keys_1.publicKeyFromBytes)((0, common_1.hexToBytes)(key)));
        }
        return transaction;
    }
}
exports.makeContractCall = makeContractCall;
function makeStandardSTXPostCondition(address, conditionCode, amount) {
    return (0, postcondition_1.createSTXPostCondition)((0, postcondition_types_1.createStandardPrincipal)(address), conditionCode, amount);
}
exports.makeStandardSTXPostCondition = makeStandardSTXPostCondition;
function makeContractSTXPostCondition(address, contractName, conditionCode, amount) {
    return (0, postcondition_1.createSTXPostCondition)((0, postcondition_types_1.createContractPrincipal)(address, contractName), conditionCode, amount);
}
exports.makeContractSTXPostCondition = makeContractSTXPostCondition;
function makeStandardFungiblePostCondition(address, conditionCode, amount, assetInfo) {
    return (0, postcondition_1.createFungiblePostCondition)((0, postcondition_types_1.createStandardPrincipal)(address), conditionCode, amount, assetInfo);
}
exports.makeStandardFungiblePostCondition = makeStandardFungiblePostCondition;
function makeContractFungiblePostCondition(address, contractName, conditionCode, amount, assetInfo) {
    return (0, postcondition_1.createFungiblePostCondition)((0, postcondition_types_1.createContractPrincipal)(address, contractName), conditionCode, amount, assetInfo);
}
exports.makeContractFungiblePostCondition = makeContractFungiblePostCondition;
function makeStandardNonFungiblePostCondition(address, conditionCode, assetInfo, assetName) {
    return (0, postcondition_1.createNonFungiblePostCondition)((0, postcondition_types_1.createStandardPrincipal)(address), conditionCode, assetInfo, assetName);
}
exports.makeStandardNonFungiblePostCondition = makeStandardNonFungiblePostCondition;
function makeContractNonFungiblePostCondition(address, contractName, conditionCode, assetInfo, assetName) {
    return (0, postcondition_1.createNonFungiblePostCondition)((0, postcondition_types_1.createContractPrincipal)(address, contractName), conditionCode, assetInfo, assetName);
}
exports.makeContractNonFungiblePostCondition = makeContractNonFungiblePostCondition;
async function callReadOnlyFunction(readOnlyFunctionOptions) {
    const defaultOptions = {
        network: new network_1.StacksMainnet(),
    };
    const options = Object.assign(defaultOptions, readOnlyFunctionOptions);
    const { contractName, contractAddress, functionName, functionArgs, senderAddress } = options;
    const network = network_1.StacksNetwork.fromNameOrNetwork(options.network);
    const url = network.getReadOnlyFunctionCallApiUrl(contractAddress, contractName, functionName);
    const args = functionArgs.map(arg => (0, utils_1.cvToHex)(arg));
    const body = JSON.stringify({
        sender: senderAddress,
        arguments: args,
    });
    const response = await network.fetchFn(url, {
        method: 'POST',
        body,
        headers: {
            'Content-Type': 'application/json',
        },
    });
    if (!response.ok) {
        const msg = await response.text().catch(() => '');
        throw new Error(`Error calling read-only function. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: "${msg}"`);
    }
    return response.json().then(responseJson => (0, utils_1.parseReadOnlyResponse)(responseJson));
}
exports.callReadOnlyFunction = callReadOnlyFunction;
async function sponsorTransaction(sponsorOptions) {
    const defaultOptions = {
        fee: 0,
        sponsorNonce: 0,
        sponsorAddressHashmode: constants_1.AddressHashMode.SerializeP2PKH,
        network: sponsorOptions.transaction.version === constants_1.TransactionVersion.Mainnet
            ? new network_1.StacksMainnet()
            : new network_1.StacksTestnet(),
    };
    const options = Object.assign(defaultOptions, sponsorOptions);
    const network = network_1.StacksNetwork.fromNameOrNetwork(options.network);
    const sponsorPubKey = (0, keys_1.pubKeyfromPrivKey)(options.sponsorPrivateKey);
    if (sponsorOptions.fee === undefined || sponsorOptions.fee === null) {
        let txFee = 0;
        switch (options.transaction.payload.payloadType) {
            case constants_1.PayloadType.TokenTransfer:
            case constants_1.PayloadType.SmartContract:
            case constants_1.PayloadType.VersionedSmartContract:
            case constants_1.PayloadType.ContractCall:
                const estimatedLen = estimateTransactionByteLength(options.transaction);
                try {
                    txFee = (await estimateTransaction(options.transaction.payload, estimatedLen, network))[1]
                        .fee;
                }
                catch (e) {
                    throw e;
                }
                break;
            default:
                throw new Error(`Sponsored transactions not supported for transaction type ${constants_1.PayloadType[options.transaction.payload.payloadType]}`);
        }
        options.transaction.setFee(txFee);
        options.fee = txFee;
    }
    if (sponsorOptions.sponsorNonce === undefined || sponsorOptions.sponsorNonce === null) {
        const addressVersion = network.version === constants_1.TransactionVersion.Mainnet
            ? constants_1.AddressVersion.MainnetSingleSig
            : constants_1.AddressVersion.TestnetSingleSig;
        const senderAddress = (0, keys_1.publicKeyToAddress)(addressVersion, sponsorPubKey);
        const sponsorNonce = await getNonce(senderAddress, network);
        options.sponsorNonce = sponsorNonce;
    }
    const sponsorSpendingCondition = (0, authorization_1.createSingleSigSpendingCondition)(options.sponsorAddressHashmode, (0, keys_1.publicKeyToString)(sponsorPubKey), options.sponsorNonce, options.fee);
    options.transaction.setSponsor(sponsorSpendingCondition);
    const privKey = (0, keys_1.createStacksPrivateKey)(options.sponsorPrivateKey);
    const signer = signer_1.TransactionSigner.createSponsorSigner(options.transaction, sponsorSpendingCondition);
    signer.signSponsor(privKey);
    return signer.transaction;
}
exports.sponsorTransaction = sponsorTransaction;
function estimateTransactionByteLength(transaction) {
    const hashMode = transaction.auth.spendingCondition.hashMode;
    const multiSigHashModes = [constants_1.AddressHashMode.SerializeP2SH, constants_1.AddressHashMode.SerializeP2WSH];
    if (multiSigHashModes.includes(hashMode)) {
        const multiSigSpendingCondition = transaction.auth
            .spendingCondition;
        const existingSignatures = multiSigSpendingCondition.fields.filter(field => field.contents.type === constants_1.StacksMessageType.MessageSignature).length;
        const totalSignatureLength = (multiSigSpendingCondition.signaturesRequired - existingSignatures) *
            (constants_1.RECOVERABLE_ECDSA_SIG_LENGTH_BYTES + 1);
        return transaction.serialize().byteLength + totalSignatureLength;
    }
    else {
        return transaction.serialize().byteLength;
    }
}
exports.estimateTransactionByteLength = estimateTransactionByteLength;
async function estimateTransactionFeeWithFallback(transaction, network) {
    try {
        const estimatedLen = estimateTransactionByteLength(transaction);
        return (await estimateTransaction(transaction.payload, estimatedLen, network))[1].fee;
    }
    catch (error) {
        if (error instanceof errors_1.NoEstimateAvailableError) {
            return await estimateTransferUnsafe(transaction, network);
        }
        throw error;
    }
}
exports.estimateTransactionFeeWithFallback = estimateTransactionFeeWithFallback;

},{"./authorization":72,"./constants":90,"./contract-abi":91,"./errors":92,"./keys":94,"./payload":95,"./postcondition":97,"./postcondition-types":96,"./signer":99,"./transaction":101,"./types":102,"./utils":103,"@stacks/common":36,"@stacks/network":63,"c32check":112}],74:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BytesReader = exports.isEnum = void 0;
const common_1 = require("@stacks/common");
function createEnumChecker(enumVariable) {
    const enumValues = Object.values(enumVariable).filter(v => typeof v === 'number');
    const enumValueSet = new Set(enumValues);
    return (value) => enumValueSet.has(value);
}
const enumCheckFunctions = new Map();
function isEnum(enumVariable, value) {
    const checker = enumCheckFunctions.get(enumVariable);
    if (checker !== undefined) {
        return checker(value);
    }
    const newChecker = createEnumChecker(enumVariable);
    enumCheckFunctions.set(enumVariable, newChecker);
    return isEnum(enumVariable, value);
}
exports.isEnum = isEnum;
class BytesReader {
    constructor(arr) {
        this.consumed = 0;
        this.source = arr;
    }
    readBytes(length) {
        const view = this.source.subarray(this.consumed, this.consumed + length);
        this.consumed += length;
        return view;
    }
    readUInt32BE() {
        return (0, common_1.readUInt32BE)(this.readBytes(4), 0);
    }
    readUInt8() {
        return (0, common_1.readUInt8)(this.readBytes(1), 0);
    }
    readUInt16BE() {
        return (0, common_1.readUInt16BE)(this.readBytes(2), 0);
    }
    readBigUIntLE(length) {
        const bytes = this.readBytes(length).slice().reverse();
        const hex = (0, common_1.bytesToHex)(bytes);
        return BigInt(`0x${hex}`);
    }
    readBigUIntBE(length) {
        const bytes = this.readBytes(length);
        const hex = (0, common_1.bytesToHex)(bytes);
        return BigInt(`0x${hex}`);
    }
    get readOffset() {
        return this.consumed;
    }
    set readOffset(val) {
        this.consumed = val;
    }
    get internalBytes() {
        return this.source;
    }
    readUInt8Enum(enumVariable, invalidEnumErrorFormatter) {
        const num = this.readUInt8();
        if (isEnum(enumVariable, num)) {
            return num;
        }
        throw invalidEnumErrorFormatter(num);
    }
}
exports.BytesReader = BytesReader;

},{"@stacks/common":36}],75:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCVTypeString = exports.cvToJSON = exports.cvToValue = exports.cvToString = void 0;
const principalCV_1 = require("./types/principalCV");
const constants_1 = require("./constants");
const common_1 = require("@stacks/common");
function cvToString(val, encoding = 'hex') {
    switch (val.type) {
        case constants_1.ClarityType.BoolTrue:
            return 'true';
        case constants_1.ClarityType.BoolFalse:
            return 'false';
        case constants_1.ClarityType.Int:
            return val.value.toString();
        case constants_1.ClarityType.UInt:
            return `u${val.value.toString()}`;
        case constants_1.ClarityType.Buffer:
            if (encoding === 'tryAscii') {
                const str = (0, common_1.bytesToAscii)(val.buffer);
                if (/[ -~]/.test(str)) {
                    return JSON.stringify(str);
                }
            }
            return `0x${(0, common_1.bytesToHex)(val.buffer)}`;
        case constants_1.ClarityType.OptionalNone:
            return 'none';
        case constants_1.ClarityType.OptionalSome:
            return `(some ${cvToString(val.value, encoding)})`;
        case constants_1.ClarityType.ResponseErr:
            return `(err ${cvToString(val.value, encoding)})`;
        case constants_1.ClarityType.ResponseOk:
            return `(ok ${cvToString(val.value, encoding)})`;
        case constants_1.ClarityType.PrincipalStandard:
        case constants_1.ClarityType.PrincipalContract:
            return (0, principalCV_1.principalToString)(val);
        case constants_1.ClarityType.List:
            return `(list ${val.list.map(v => cvToString(v, encoding)).join(' ')})`;
        case constants_1.ClarityType.Tuple:
            return `(tuple ${Object.keys(val.data)
                .map(key => `(${key} ${cvToString(val.data[key], encoding)})`)
                .join(' ')})`;
        case constants_1.ClarityType.StringASCII:
            return `"${val.data}"`;
        case constants_1.ClarityType.StringUTF8:
            return `u"${val.data}"`;
    }
}
exports.cvToString = cvToString;
function cvToValue(val, strictJsonCompat = false) {
    switch (val.type) {
        case constants_1.ClarityType.BoolTrue:
            return true;
        case constants_1.ClarityType.BoolFalse:
            return false;
        case constants_1.ClarityType.Int:
        case constants_1.ClarityType.UInt:
            if (strictJsonCompat) {
                return val.value.toString();
            }
            return val.value;
        case constants_1.ClarityType.Buffer:
            return `0x${(0, common_1.bytesToHex)(val.buffer)}`;
        case constants_1.ClarityType.OptionalNone:
            return null;
        case constants_1.ClarityType.OptionalSome:
            return cvToJSON(val.value);
        case constants_1.ClarityType.ResponseErr:
            return cvToJSON(val.value);
        case constants_1.ClarityType.ResponseOk:
            return cvToJSON(val.value);
        case constants_1.ClarityType.PrincipalStandard:
        case constants_1.ClarityType.PrincipalContract:
            return (0, principalCV_1.principalToString)(val);
        case constants_1.ClarityType.List:
            return val.list.map(v => cvToJSON(v));
        case constants_1.ClarityType.Tuple:
            const result = {};
            Object.keys(val.data).forEach(key => {
                result[key] = cvToJSON(val.data[key]);
            });
            return result;
        case constants_1.ClarityType.StringASCII:
            return val.data;
        case constants_1.ClarityType.StringUTF8:
            return val.data;
    }
}
exports.cvToValue = cvToValue;
function cvToJSON(val) {
    switch (val.type) {
        case constants_1.ClarityType.ResponseErr:
            return { type: getCVTypeString(val), value: cvToValue(val, true), success: false };
        case constants_1.ClarityType.ResponseOk:
            return { type: getCVTypeString(val), value: cvToValue(val, true), success: true };
        default:
            return { type: getCVTypeString(val), value: cvToValue(val, true) };
    }
}
exports.cvToJSON = cvToJSON;
function getCVTypeString(val) {
    switch (val.type) {
        case constants_1.ClarityType.BoolTrue:
        case constants_1.ClarityType.BoolFalse:
            return 'bool';
        case constants_1.ClarityType.Int:
            return 'int';
        case constants_1.ClarityType.UInt:
            return 'uint';
        case constants_1.ClarityType.Buffer:
            return `(buff ${val.buffer.length})`;
        case constants_1.ClarityType.OptionalNone:
            return '(optional none)';
        case constants_1.ClarityType.OptionalSome:
            return `(optional ${getCVTypeString(val.value)})`;
        case constants_1.ClarityType.ResponseErr:
            return `(response UnknownType ${getCVTypeString(val.value)})`;
        case constants_1.ClarityType.ResponseOk:
            return `(response ${getCVTypeString(val.value)} UnknownType)`;
        case constants_1.ClarityType.PrincipalStandard:
        case constants_1.ClarityType.PrincipalContract:
            return 'principal';
        case constants_1.ClarityType.List:
            return `(list ${val.list.length} ${val.list.length ? getCVTypeString(val.list[0]) : 'UnknownType'})`;
        case constants_1.ClarityType.Tuple:
            return `(tuple ${Object.keys(val.data)
                .map(key => `(${key} ${getCVTypeString(val.data[key])})`)
                .join(' ')})`;
        case constants_1.ClarityType.StringASCII:
            return `(string-ascii ${(0, common_1.asciiToBytes)(val.data).length})`;
        case constants_1.ClarityType.StringUTF8:
            return `(string-utf8 ${(0, common_1.utf8ToBytes)(val.data).length})`;
    }
}
exports.getCVTypeString = getCVTypeString;

},{"./constants":76,"./types/principalCV":85,"@stacks/common":36}],76:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClarityType = void 0;
var ClarityType;
(function (ClarityType) {
    ClarityType[ClarityType["Int"] = 0] = "Int";
    ClarityType[ClarityType["UInt"] = 1] = "UInt";
    ClarityType[ClarityType["Buffer"] = 2] = "Buffer";
    ClarityType[ClarityType["BoolTrue"] = 3] = "BoolTrue";
    ClarityType[ClarityType["BoolFalse"] = 4] = "BoolFalse";
    ClarityType[ClarityType["PrincipalStandard"] = 5] = "PrincipalStandard";
    ClarityType[ClarityType["PrincipalContract"] = 6] = "PrincipalContract";
    ClarityType[ClarityType["ResponseOk"] = 7] = "ResponseOk";
    ClarityType[ClarityType["ResponseErr"] = 8] = "ResponseErr";
    ClarityType[ClarityType["OptionalNone"] = 9] = "OptionalNone";
    ClarityType[ClarityType["OptionalSome"] = 10] = "OptionalSome";
    ClarityType[ClarityType["List"] = 11] = "List";
    ClarityType[ClarityType["Tuple"] = 12] = "Tuple";
    ClarityType[ClarityType["StringASCII"] = 13] = "StringASCII";
    ClarityType[ClarityType["StringUTF8"] = 14] = "StringUTF8";
})(ClarityType = exports.ClarityType || (exports.ClarityType = {}));

},{}],77:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const _1 = require(".");
const bytesReader_1 = require("../bytesReader");
const types_1 = require("../types");
const errors_1 = require("../errors");
const stringCV_1 = require("./types/stringCV");
const common_1 = require("@stacks/common");
function deserializeCV(serializedClarityValue) {
    let bytesReader;
    if (typeof serializedClarityValue === 'string') {
        const hasHexPrefix = serializedClarityValue.slice(0, 2).toLowerCase() === '0x';
        bytesReader = new bytesReader_1.BytesReader((0, common_1.hexToBytes)(hasHexPrefix ? serializedClarityValue.slice(2) : serializedClarityValue));
    }
    else if (serializedClarityValue instanceof Uint8Array) {
        bytesReader = new bytesReader_1.BytesReader(serializedClarityValue);
    }
    else {
        bytesReader = serializedClarityValue;
    }
    const type = bytesReader.readUInt8Enum(_1.ClarityType, n => {
        throw new errors_1.DeserializationError(`Cannot recognize Clarity Type: ${n}`);
    });
    switch (type) {
        case _1.ClarityType.Int:
            return (0, _1.intCV)(bytesReader.readBytes(16));
        case _1.ClarityType.UInt:
            return (0, _1.uintCV)(bytesReader.readBytes(16));
        case _1.ClarityType.Buffer:
            const bufferLength = bytesReader.readUInt32BE();
            return (0, _1.bufferCV)(bytesReader.readBytes(bufferLength));
        case _1.ClarityType.BoolTrue:
            return (0, _1.trueCV)();
        case _1.ClarityType.BoolFalse:
            return (0, _1.falseCV)();
        case _1.ClarityType.PrincipalStandard:
            const sAddress = (0, types_1.deserializeAddress)(bytesReader);
            return (0, _1.standardPrincipalCVFromAddress)(sAddress);
        case _1.ClarityType.PrincipalContract:
            const cAddress = (0, types_1.deserializeAddress)(bytesReader);
            const contractName = (0, types_1.deserializeLPString)(bytesReader);
            return (0, _1.contractPrincipalCVFromAddress)(cAddress, contractName);
        case _1.ClarityType.ResponseOk:
            return (0, _1.responseOkCV)(deserializeCV(bytesReader));
        case _1.ClarityType.ResponseErr:
            return (0, _1.responseErrorCV)(deserializeCV(bytesReader));
        case _1.ClarityType.OptionalNone:
            return (0, _1.noneCV)();
        case _1.ClarityType.OptionalSome:
            return (0, _1.someCV)(deserializeCV(bytesReader));
        case _1.ClarityType.List:
            const listLength = bytesReader.readUInt32BE();
            const listContents = [];
            for (let i = 0; i < listLength; i++) {
                listContents.push(deserializeCV(bytesReader));
            }
            return (0, _1.listCV)(listContents);
        case _1.ClarityType.Tuple:
            const tupleLength = bytesReader.readUInt32BE();
            const tupleContents = {};
            for (let i = 0; i < tupleLength; i++) {
                const clarityName = (0, types_1.deserializeLPString)(bytesReader).content;
                if (clarityName === undefined) {
                    throw new errors_1.DeserializationError('"content" is undefined');
                }
                tupleContents[clarityName] = deserializeCV(bytesReader);
            }
            return (0, _1.tupleCV)(tupleContents);
        case _1.ClarityType.StringASCII:
            const asciiStrLen = bytesReader.readUInt32BE();
            const asciiStr = (0, common_1.bytesToAscii)(bytesReader.readBytes(asciiStrLen));
            return (0, stringCV_1.stringAsciiCV)(asciiStr);
        case _1.ClarityType.StringUTF8:
            const utf8StrLen = bytesReader.readUInt32BE();
            const utf8Str = (0, common_1.bytesToUtf8)(bytesReader.readBytes(utf8StrLen));
            return (0, stringCV_1.stringUtf8CV)(utf8Str);
        default:
            throw new errors_1.DeserializationError('Unable to deserialize Clarity Value from Uint8Array. Could not find valid Clarity Type.');
    }
}
exports.default = deserializeCV;

},{".":78,"../bytesReader":74,"../errors":92,"../types":102,"./types/stringCV":87,"@stacks/common":36}],78:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.cvToValue = exports.cvToJSON = exports.cvToString = exports.deserializeCV = exports.serializeCV = exports.getCVTypeString = exports.stringUtf8CV = exports.stringAsciiCV = exports.stringCV = exports.tupleCV = exports.listCV = exports.contractPrincipalCVFromStandard = exports.contractPrincipalCVFromAddress = exports.contractPrincipalCV = exports.standardPrincipalCVFromAddress = exports.standardPrincipalCV = exports.principalCV = exports.responseErrorCV = exports.responseOkCV = exports.optionalCVOf = exports.someCV = exports.noneCV = exports.bufferCVFromString = exports.bufferCV = exports.uintCV = exports.intCV = exports.falseCV = exports.trueCV = exports.boolCV = exports.ClarityType = void 0;
const clarityValue_1 = require("./clarityValue");
Object.defineProperty(exports, "getCVTypeString", { enumerable: true, get: function () { return clarityValue_1.getCVTypeString; } });
Object.defineProperty(exports, "cvToString", { enumerable: true, get: function () { return clarityValue_1.cvToString; } });
Object.defineProperty(exports, "cvToJSON", { enumerable: true, get: function () { return clarityValue_1.cvToJSON; } });
Object.defineProperty(exports, "cvToValue", { enumerable: true, get: function () { return clarityValue_1.cvToValue; } });
const constants_1 = require("./constants");
Object.defineProperty(exports, "ClarityType", { enumerable: true, get: function () { return constants_1.ClarityType; } });
const booleanCV_1 = require("./types/booleanCV");
Object.defineProperty(exports, "trueCV", { enumerable: true, get: function () { return booleanCV_1.trueCV; } });
Object.defineProperty(exports, "falseCV", { enumerable: true, get: function () { return booleanCV_1.falseCV; } });
Object.defineProperty(exports, "boolCV", { enumerable: true, get: function () { return booleanCV_1.boolCV; } });
const intCV_1 = require("./types/intCV");
Object.defineProperty(exports, "intCV", { enumerable: true, get: function () { return intCV_1.intCV; } });
Object.defineProperty(exports, "uintCV", { enumerable: true, get: function () { return intCV_1.uintCV; } });
const bufferCV_1 = require("./types/bufferCV");
Object.defineProperty(exports, "bufferCV", { enumerable: true, get: function () { return bufferCV_1.bufferCV; } });
Object.defineProperty(exports, "bufferCVFromString", { enumerable: true, get: function () { return bufferCV_1.bufferCVFromString; } });
const optionalCV_1 = require("./types/optionalCV");
Object.defineProperty(exports, "noneCV", { enumerable: true, get: function () { return optionalCV_1.noneCV; } });
Object.defineProperty(exports, "someCV", { enumerable: true, get: function () { return optionalCV_1.someCV; } });
Object.defineProperty(exports, "optionalCVOf", { enumerable: true, get: function () { return optionalCV_1.optionalCVOf; } });
const responseCV_1 = require("./types/responseCV");
Object.defineProperty(exports, "responseOkCV", { enumerable: true, get: function () { return responseCV_1.responseOkCV; } });
Object.defineProperty(exports, "responseErrorCV", { enumerable: true, get: function () { return responseCV_1.responseErrorCV; } });
const principalCV_1 = require("./types/principalCV");
Object.defineProperty(exports, "standardPrincipalCV", { enumerable: true, get: function () { return principalCV_1.standardPrincipalCV; } });
Object.defineProperty(exports, "contractPrincipalCV", { enumerable: true, get: function () { return principalCV_1.contractPrincipalCV; } });
Object.defineProperty(exports, "standardPrincipalCVFromAddress", { enumerable: true, get: function () { return principalCV_1.standardPrincipalCVFromAddress; } });
Object.defineProperty(exports, "contractPrincipalCVFromAddress", { enumerable: true, get: function () { return principalCV_1.contractPrincipalCVFromAddress; } });
Object.defineProperty(exports, "contractPrincipalCVFromStandard", { enumerable: true, get: function () { return principalCV_1.contractPrincipalCVFromStandard; } });
Object.defineProperty(exports, "principalCV", { enumerable: true, get: function () { return principalCV_1.principalCV; } });
const listCV_1 = require("./types/listCV");
Object.defineProperty(exports, "listCV", { enumerable: true, get: function () { return listCV_1.listCV; } });
const tupleCV_1 = require("./types/tupleCV");
Object.defineProperty(exports, "tupleCV", { enumerable: true, get: function () { return tupleCV_1.tupleCV; } });
const stringCV_1 = require("./types/stringCV");
Object.defineProperty(exports, "stringUtf8CV", { enumerable: true, get: function () { return stringCV_1.stringUtf8CV; } });
Object.defineProperty(exports, "stringAsciiCV", { enumerable: true, get: function () { return stringCV_1.stringAsciiCV; } });
Object.defineProperty(exports, "stringCV", { enumerable: true, get: function () { return stringCV_1.stringCV; } });
const serialize_1 = require("./serialize");
Object.defineProperty(exports, "serializeCV", { enumerable: true, get: function () { return serialize_1.serializeCV; } });
const deserialize_1 = __importDefault(require("./deserialize"));
exports.deserializeCV = deserialize_1.default;

},{"./clarityValue":75,"./constants":76,"./deserialize":77,"./serialize":79,"./types/booleanCV":80,"./types/bufferCV":81,"./types/intCV":82,"./types/listCV":83,"./types/optionalCV":84,"./types/principalCV":85,"./types/responseCV":86,"./types/stringCV":87,"./types/tupleCV":88}],79:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.serializeCV = void 0;
const common_1 = require("@stacks/common");
const types_1 = require("../types");
const postcondition_types_1 = require("../postcondition-types");
const constants_1 = require("./constants");
const errors_1 = require("../errors");
const constants_2 = require("../constants");
function bytesWithTypeID(typeId, bytes) {
    return (0, common_1.concatArray)([typeId, bytes]);
}
function serializeBoolCV(value) {
    return new Uint8Array([value.type]);
}
function serializeOptionalCV(cv) {
    if (cv.type === constants_1.ClarityType.OptionalNone) {
        return new Uint8Array([cv.type]);
    }
    else {
        return bytesWithTypeID(cv.type, serializeCV(cv.value));
    }
}
function serializeBufferCV(cv) {
    const length = new Uint8Array(4);
    (0, common_1.writeUInt32BE)(length, cv.buffer.length, 0);
    return bytesWithTypeID(cv.type, (0, common_1.concatBytes)(length, cv.buffer));
}
function serializeIntCV(cv) {
    const bytes = (0, common_1.bigIntToBytes)((0, common_1.toTwos)(cv.value, BigInt(constants_2.CLARITY_INT_SIZE)), constants_2.CLARITY_INT_BYTE_SIZE);
    return bytesWithTypeID(cv.type, bytes);
}
function serializeUIntCV(cv) {
    const bytes = (0, common_1.bigIntToBytes)(cv.value, constants_2.CLARITY_INT_BYTE_SIZE);
    return bytesWithTypeID(cv.type, bytes);
}
function serializeStandardPrincipalCV(cv) {
    return bytesWithTypeID(cv.type, (0, types_1.serializeAddress)(cv.address));
}
function serializeContractPrincipalCV(cv) {
    return bytesWithTypeID(cv.type, (0, common_1.concatBytes)((0, types_1.serializeAddress)(cv.address), (0, types_1.serializeLPString)(cv.contractName)));
}
function serializeResponseCV(cv) {
    return bytesWithTypeID(cv.type, serializeCV(cv.value));
}
function serializeListCV(cv) {
    const bytesArray = [];
    const length = new Uint8Array(4);
    (0, common_1.writeUInt32BE)(length, cv.list.length, 0);
    bytesArray.push(length);
    for (const value of cv.list) {
        const serializedValue = serializeCV(value);
        bytesArray.push(serializedValue);
    }
    return bytesWithTypeID(cv.type, (0, common_1.concatArray)(bytesArray));
}
function serializeTupleCV(cv) {
    const bytesArray = [];
    const length = new Uint8Array(4);
    (0, common_1.writeUInt32BE)(length, Object.keys(cv.data).length, 0);
    bytesArray.push(length);
    const lexicographicOrder = Object.keys(cv.data).sort((a, b) => a.localeCompare(b));
    for (const key of lexicographicOrder) {
        const nameWithLength = (0, postcondition_types_1.createLPString)(key);
        bytesArray.push((0, types_1.serializeLPString)(nameWithLength));
        const serializedValue = serializeCV(cv.data[key]);
        bytesArray.push(serializedValue);
    }
    return bytesWithTypeID(cv.type, (0, common_1.concatArray)(bytesArray));
}
function serializeStringCV(cv, encoding) {
    const bytesArray = [];
    const str = encoding == 'ascii' ? (0, common_1.asciiToBytes)(cv.data) : (0, common_1.utf8ToBytes)(cv.data);
    const len = new Uint8Array(4);
    (0, common_1.writeUInt32BE)(len, str.length, 0);
    bytesArray.push(len);
    bytesArray.push(str);
    return bytesWithTypeID(cv.type, (0, common_1.concatArray)(bytesArray));
}
function serializeStringAsciiCV(cv) {
    return serializeStringCV(cv, 'ascii');
}
function serializeStringUtf8CV(cv) {
    return serializeStringCV(cv, 'utf8');
}
function serializeCV(value) {
    switch (value.type) {
        case constants_1.ClarityType.BoolTrue:
        case constants_1.ClarityType.BoolFalse:
            return serializeBoolCV(value);
        case constants_1.ClarityType.OptionalNone:
        case constants_1.ClarityType.OptionalSome:
            return serializeOptionalCV(value);
        case constants_1.ClarityType.Buffer:
            return serializeBufferCV(value);
        case constants_1.ClarityType.UInt:
            return serializeUIntCV(value);
        case constants_1.ClarityType.Int:
            return serializeIntCV(value);
        case constants_1.ClarityType.PrincipalStandard:
            return serializeStandardPrincipalCV(value);
        case constants_1.ClarityType.PrincipalContract:
            return serializeContractPrincipalCV(value);
        case constants_1.ClarityType.ResponseOk:
        case constants_1.ClarityType.ResponseErr:
            return serializeResponseCV(value);
        case constants_1.ClarityType.List:
            return serializeListCV(value);
        case constants_1.ClarityType.Tuple:
            return serializeTupleCV(value);
        case constants_1.ClarityType.StringASCII:
            return serializeStringAsciiCV(value);
        case constants_1.ClarityType.StringUTF8:
            return serializeStringUtf8CV(value);
        default:
            throw new errors_1.SerializationError('Unable to serialize. Invalid Clarity Value.');
    }
}
exports.serializeCV = serializeCV;

},{"../constants":90,"../errors":92,"../postcondition-types":96,"../types":102,"./constants":76,"@stacks/common":36}],80:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.falseCV = exports.trueCV = exports.boolCV = void 0;
const constants_1 = require("../constants");
const trueCV = () => ({ type: constants_1.ClarityType.BoolTrue });
exports.trueCV = trueCV;
const falseCV = () => ({ type: constants_1.ClarityType.BoolFalse });
exports.falseCV = falseCV;
const boolCV = (bool) => (bool ? trueCV() : falseCV());
exports.boolCV = boolCV;

},{"../constants":76}],81:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.bufferCVFromString = exports.bufferCV = void 0;
const common_1 = require("@stacks/common");
const constants_1 = require("../constants");
const bufferCV = (buffer) => {
    if (buffer.length > 1000000) {
        throw new Error('Cannot construct clarity buffer that is greater than 1MB');
    }
    return { type: constants_1.ClarityType.Buffer, buffer };
};
exports.bufferCV = bufferCV;
const bufferCVFromString = (str) => bufferCV((0, common_1.utf8ToBytes)(str));
exports.bufferCVFromString = bufferCVFromString;

},{"../constants":76,"@stacks/common":36}],82:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.uintCV = exports.intCV = void 0;
const common_1 = require("@stacks/common");
const constants_1 = require("../constants");
const MAX_U128 = BigInt('0xffffffffffffffffffffffffffffffff');
const MIN_U128 = BigInt(0);
const MAX_I128 = BigInt('0x7fffffffffffffffffffffffffffffff');
const MIN_I128 = BigInt('-170141183460469231731687303715884105728');
const intCV = (value) => {
    const bigInt = (0, common_1.intToBigInt)(value, true);
    if (bigInt > MAX_I128) {
        throw new RangeError(`Cannot construct clarity integer from value greater than ${MAX_I128}`);
    }
    else if (bigInt < MIN_I128) {
        throw new RangeError(`Cannot construct clarity integer form value less than ${MIN_I128}`);
    }
    return { type: constants_1.ClarityType.Int, value: bigInt };
};
exports.intCV = intCV;
const uintCV = (value) => {
    const bigInt = (0, common_1.intToBigInt)(value, false);
    if (bigInt < MIN_U128) {
        throw new RangeError('Cannot construct unsigned clarity integer from negative value');
    }
    else if (bigInt > MAX_U128) {
        throw new RangeError(`Cannot construct unsigned clarity integer greater than ${MAX_U128}`);
    }
    return { type: constants_1.ClarityType.UInt, value: bigInt };
};
exports.uintCV = uintCV;

},{"../constants":76,"@stacks/common":36}],83:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.listCV = void 0;
const constants_1 = require("../constants");
function listCV(values) {
    return { type: constants_1.ClarityType.List, list: values };
}
exports.listCV = listCV;

},{"../constants":76}],84:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.optionalCVOf = exports.someCV = exports.noneCV = void 0;
const constants_1 = require("../constants");
function noneCV() {
    return { type: constants_1.ClarityType.OptionalNone };
}
exports.noneCV = noneCV;
function someCV(value) {
    return { type: constants_1.ClarityType.OptionalSome, value };
}
exports.someCV = someCV;
function optionalCVOf(value) {
    if (value) {
        return someCV(value);
    }
    else {
        return noneCV();
    }
}
exports.optionalCVOf = optionalCVOf;

},{"../constants":76}],85:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.contractPrincipalCVFromStandard = exports.contractPrincipalCVFromAddress = exports.contractPrincipalCV = exports.standardPrincipalCVFromAddress = exports.standardPrincipalCV = exports.principalToString = exports.principalCV = void 0;
const postcondition_types_1 = require("../../postcondition-types");
const common_1 = require("../../common");
const constants_1 = require("../constants");
const common_2 = require("@stacks/common");
function principalToString(principal) {
    if (principal.type === constants_1.ClarityType.PrincipalStandard) {
        return (0, common_1.addressToString)(principal.address);
    }
    else if (principal.type === constants_1.ClarityType.PrincipalContract) {
        const address = (0, common_1.addressToString)(principal.address);
        return `${address}.${principal.contractName.content}`;
    }
    else {
        throw new Error(`Unexpected principal data: ${JSON.stringify(principal)}`);
    }
}
exports.principalToString = principalToString;
function principalCV(principal) {
    if (principal.includes('.')) {
        const [address, contractName] = principal.split('.');
        return contractPrincipalCV(address, contractName);
    }
    else {
        return standardPrincipalCV(principal);
    }
}
exports.principalCV = principalCV;
function standardPrincipalCV(addressString) {
    const addr = (0, postcondition_types_1.createAddress)(addressString);
    return { type: constants_1.ClarityType.PrincipalStandard, address: addr };
}
exports.standardPrincipalCV = standardPrincipalCV;
function standardPrincipalCVFromAddress(address) {
    return { type: constants_1.ClarityType.PrincipalStandard, address };
}
exports.standardPrincipalCVFromAddress = standardPrincipalCVFromAddress;
function contractPrincipalCV(addressString, contractName) {
    const addr = (0, postcondition_types_1.createAddress)(addressString);
    const lengthPrefixedContractName = (0, postcondition_types_1.createLPString)(contractName);
    return contractPrincipalCVFromAddress(addr, lengthPrefixedContractName);
}
exports.contractPrincipalCV = contractPrincipalCV;
function contractPrincipalCVFromAddress(address, contractName) {
    if ((0, common_2.utf8ToBytes)(contractName.content).byteLength >= 128) {
        throw new Error('Contract name must be less than 128 bytes');
    }
    return { type: constants_1.ClarityType.PrincipalContract, address, contractName };
}
exports.contractPrincipalCVFromAddress = contractPrincipalCVFromAddress;
function contractPrincipalCVFromStandard(sp, contractName) {
    const lengthPrefixedContractName = (0, postcondition_types_1.createLPString)(contractName);
    return {
        type: constants_1.ClarityType.PrincipalContract,
        address: sp.address,
        contractName: lengthPrefixedContractName,
    };
}
exports.contractPrincipalCVFromStandard = contractPrincipalCVFromStandard;

},{"../../common":89,"../../postcondition-types":96,"../constants":76,"@stacks/common":36}],86:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.responseOkCV = exports.responseErrorCV = void 0;
const constants_1 = require("../constants");
function responseErrorCV(value) {
    return { type: constants_1.ClarityType.ResponseErr, value };
}
exports.responseErrorCV = responseErrorCV;
function responseOkCV(value) {
    return { type: constants_1.ClarityType.ResponseOk, value };
}
exports.responseOkCV = responseOkCV;

},{"../constants":76}],87:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.stringCV = exports.stringUtf8CV = exports.stringAsciiCV = void 0;
const constants_1 = require("../constants");
const stringAsciiCV = (data) => {
    return { type: constants_1.ClarityType.StringASCII, data };
};
exports.stringAsciiCV = stringAsciiCV;
const stringUtf8CV = (data) => {
    return { type: constants_1.ClarityType.StringUTF8, data };
};
exports.stringUtf8CV = stringUtf8CV;
const stringCV = (data, encoding) => {
    switch (encoding) {
        case 'ascii':
            return stringAsciiCV(data);
        case 'utf8':
            return stringAsciiCV(data);
    }
};
exports.stringCV = stringCV;

},{"../constants":76}],88:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tupleCV = void 0;
const constants_1 = require("../constants");
const utils_1 = require("../../utils");
function tupleCV(data) {
    for (const key in data) {
        if (!(0, utils_1.isClarityName)(key)) {
            throw new Error(`"${key}" is not a valid Clarity name`);
        }
    }
    return { type: constants_1.ClarityType.Tuple, data };
}
exports.tupleCV = tupleCV;

},{"../../utils":103,"../constants":76}],89:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addressToString = exports.addressFromVersionHash = exports.addressHashModeToVersion = exports.createMessageSignature = void 0;
const constants_1 = require("./constants");
const c32check_1 = require("c32check");
const common_1 = require("@stacks/common");
function createMessageSignature(signature) {
    const length = (0, common_1.hexToBytes)(signature).byteLength;
    if (length != constants_1.RECOVERABLE_ECDSA_SIG_LENGTH_BYTES) {
        throw Error('Invalid signature');
    }
    return {
        type: constants_1.StacksMessageType.MessageSignature,
        data: signature,
    };
}
exports.createMessageSignature = createMessageSignature;
function addressHashModeToVersion(hashMode, txVersion) {
    switch (hashMode) {
        case constants_1.AddressHashMode.SerializeP2PKH:
            switch (txVersion) {
                case constants_1.TransactionVersion.Mainnet:
                    return constants_1.AddressVersion.MainnetSingleSig;
                case constants_1.TransactionVersion.Testnet:
                    return constants_1.AddressVersion.TestnetSingleSig;
                default:
                    throw new Error(`Unexpected txVersion ${JSON.stringify(txVersion)} for hashMode ${hashMode}`);
            }
        case constants_1.AddressHashMode.SerializeP2SH:
        case constants_1.AddressHashMode.SerializeP2WPKH:
        case constants_1.AddressHashMode.SerializeP2WSH:
            switch (txVersion) {
                case constants_1.TransactionVersion.Mainnet:
                    return constants_1.AddressVersion.MainnetMultiSig;
                case constants_1.TransactionVersion.Testnet:
                    return constants_1.AddressVersion.TestnetMultiSig;
                default:
                    throw new Error(`Unexpected txVersion ${JSON.stringify(txVersion)} for hashMode ${hashMode}`);
            }
        default:
            throw new Error(`Unexpected hashMode ${JSON.stringify(hashMode)}`);
    }
}
exports.addressHashModeToVersion = addressHashModeToVersion;
function addressFromVersionHash(version, hash) {
    return { type: constants_1.StacksMessageType.Address, version, hash160: hash };
}
exports.addressFromVersionHash = addressFromVersionHash;
function addressToString(address) {
    return (0, c32check_1.c32address)(address.version, address.hash160);
}
exports.addressToString = addressToString;

},{"./constants":90,"@stacks/common":36,"c32check":112}],90:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TxRejectedReason = exports.AssetType = exports.NonFungibleConditionCode = exports.FungibleConditionCode = exports.PubKeyEncoding = exports.AddressVersion = exports.AddressHashMode = exports.AuthType = exports.PostConditionPrincipalID = exports.PostConditionType = exports.PostConditionMode = exports.TransactionVersion = exports.anchorModeFromNameOrValue = exports.AnchorModeNames = exports.AnchorMode = exports.ClarityVersion = exports.PayloadType = exports.StacksMessageType = exports.ChainID = exports.DEFAULT_CORE_NODE_API_URL = exports.MEMO_MAX_LENGTH_BYTES = exports.UNCOMPRESSED_PUBKEY_LENGTH_BYTES = exports.COMPRESSED_PUBKEY_LENGTH_BYTES = exports.RECOVERABLE_ECDSA_SIG_LENGTH_BYTES = exports.DEFAULT_TRANSACTION_VERSION = exports.DEFAULT_CHAIN_ID = exports.COINBASE_BYTES_LENGTH = exports.CLARITY_INT_BYTE_SIZE = exports.CLARITY_INT_SIZE = exports.MAX_STRING_LENGTH_BYTES = exports.whenMessageType = void 0;
var ChainID;
(function (ChainID) {
    ChainID[ChainID["Testnet"] = 2147483648] = "Testnet";
    ChainID[ChainID["Mainnet"] = 1] = "Mainnet";
})(ChainID || (ChainID = {}));
exports.ChainID = ChainID;
const DEFAULT_CHAIN_ID = ChainID.Mainnet;
exports.DEFAULT_CHAIN_ID = DEFAULT_CHAIN_ID;
const MAX_STRING_LENGTH_BYTES = 128;
exports.MAX_STRING_LENGTH_BYTES = MAX_STRING_LENGTH_BYTES;
const CLARITY_INT_SIZE = 128;
exports.CLARITY_INT_SIZE = CLARITY_INT_SIZE;
const CLARITY_INT_BYTE_SIZE = 16;
exports.CLARITY_INT_BYTE_SIZE = CLARITY_INT_BYTE_SIZE;
const COINBASE_LENGTH_BYTES = 32;
exports.COINBASE_BYTES_LENGTH = COINBASE_LENGTH_BYTES;
const RECOVERABLE_ECDSA_SIG_LENGTH_BYTES = 65;
exports.RECOVERABLE_ECDSA_SIG_LENGTH_BYTES = RECOVERABLE_ECDSA_SIG_LENGTH_BYTES;
const COMPRESSED_PUBKEY_LENGTH_BYTES = 32;
exports.COMPRESSED_PUBKEY_LENGTH_BYTES = COMPRESSED_PUBKEY_LENGTH_BYTES;
const UNCOMPRESSED_PUBKEY_LENGTH_BYTES = 64;
exports.UNCOMPRESSED_PUBKEY_LENGTH_BYTES = UNCOMPRESSED_PUBKEY_LENGTH_BYTES;
const MEMO_MAX_LENGTH_BYTES = 34;
exports.MEMO_MAX_LENGTH_BYTES = MEMO_MAX_LENGTH_BYTES;
const DEFAULT_CORE_NODE_API_URL = 'https://stacks-node-api.mainnet.stacks.co';
exports.DEFAULT_CORE_NODE_API_URL = DEFAULT_CORE_NODE_API_URL;
var StacksMessageType;
(function (StacksMessageType) {
    StacksMessageType[StacksMessageType["Address"] = 0] = "Address";
    StacksMessageType[StacksMessageType["Principal"] = 1] = "Principal";
    StacksMessageType[StacksMessageType["LengthPrefixedString"] = 2] = "LengthPrefixedString";
    StacksMessageType[StacksMessageType["MemoString"] = 3] = "MemoString";
    StacksMessageType[StacksMessageType["AssetInfo"] = 4] = "AssetInfo";
    StacksMessageType[StacksMessageType["PostCondition"] = 5] = "PostCondition";
    StacksMessageType[StacksMessageType["PublicKey"] = 6] = "PublicKey";
    StacksMessageType[StacksMessageType["LengthPrefixedList"] = 7] = "LengthPrefixedList";
    StacksMessageType[StacksMessageType["Payload"] = 8] = "Payload";
    StacksMessageType[StacksMessageType["MessageSignature"] = 9] = "MessageSignature";
    StacksMessageType[StacksMessageType["StructuredDataSignature"] = 10] = "StructuredDataSignature";
    StacksMessageType[StacksMessageType["TransactionAuthField"] = 11] = "TransactionAuthField";
})(StacksMessageType || (StacksMessageType = {}));
exports.StacksMessageType = StacksMessageType;
function whenMessageType(messageType) {
    return (messageTypeMap) => messageTypeMap[messageType];
}
exports.whenMessageType = whenMessageType;
var PayloadType;
(function (PayloadType) {
    PayloadType[PayloadType["TokenTransfer"] = 0] = "TokenTransfer";
    PayloadType[PayloadType["SmartContract"] = 1] = "SmartContract";
    PayloadType[PayloadType["VersionedSmartContract"] = 6] = "VersionedSmartContract";
    PayloadType[PayloadType["ContractCall"] = 2] = "ContractCall";
    PayloadType[PayloadType["PoisonMicroblock"] = 3] = "PoisonMicroblock";
    PayloadType[PayloadType["Coinbase"] = 4] = "Coinbase";
    PayloadType[PayloadType["CoinbaseToAltRecipient"] = 5] = "CoinbaseToAltRecipient";
})(PayloadType || (PayloadType = {}));
exports.PayloadType = PayloadType;
var ClarityVersion;
(function (ClarityVersion) {
    ClarityVersion[ClarityVersion["Clarity1"] = 1] = "Clarity1";
    ClarityVersion[ClarityVersion["Clarity2"] = 2] = "Clarity2";
})(ClarityVersion || (ClarityVersion = {}));
exports.ClarityVersion = ClarityVersion;
var AnchorMode;
(function (AnchorMode) {
    AnchorMode[AnchorMode["OnChainOnly"] = 1] = "OnChainOnly";
    AnchorMode[AnchorMode["OffChainOnly"] = 2] = "OffChainOnly";
    AnchorMode[AnchorMode["Any"] = 3] = "Any";
})(AnchorMode || (AnchorMode = {}));
exports.AnchorMode = AnchorMode;
const AnchorModeNames = ['onChainOnly', 'offChainOnly', 'any'];
exports.AnchorModeNames = AnchorModeNames;
const AnchorModeMap = {
    [AnchorModeNames[0]]: AnchorMode.OnChainOnly,
    [AnchorModeNames[1]]: AnchorMode.OffChainOnly,
    [AnchorModeNames[2]]: AnchorMode.Any,
    [AnchorMode.OnChainOnly]: AnchorMode.OnChainOnly,
    [AnchorMode.OffChainOnly]: AnchorMode.OffChainOnly,
    [AnchorMode.Any]: AnchorMode.Any,
};
function anchorModeFromNameOrValue(mode) {
    if (mode in AnchorModeMap) {
        return AnchorModeMap[mode];
    }
    throw new Error(`Invalid anchor mode "${mode}", must be one of: ${AnchorModeNames.join(', ')}`);
}
exports.anchorModeFromNameOrValue = anchorModeFromNameOrValue;
var TransactionVersion;
(function (TransactionVersion) {
    TransactionVersion[TransactionVersion["Mainnet"] = 0] = "Mainnet";
    TransactionVersion[TransactionVersion["Testnet"] = 128] = "Testnet";
})(TransactionVersion || (TransactionVersion = {}));
exports.TransactionVersion = TransactionVersion;
const DEFAULT_TRANSACTION_VERSION = TransactionVersion.Mainnet;
exports.DEFAULT_TRANSACTION_VERSION = DEFAULT_TRANSACTION_VERSION;
var PostConditionMode;
(function (PostConditionMode) {
    PostConditionMode[PostConditionMode["Allow"] = 1] = "Allow";
    PostConditionMode[PostConditionMode["Deny"] = 2] = "Deny";
})(PostConditionMode || (PostConditionMode = {}));
exports.PostConditionMode = PostConditionMode;
var PostConditionType;
(function (PostConditionType) {
    PostConditionType[PostConditionType["STX"] = 0] = "STX";
    PostConditionType[PostConditionType["Fungible"] = 1] = "Fungible";
    PostConditionType[PostConditionType["NonFungible"] = 2] = "NonFungible";
})(PostConditionType || (PostConditionType = {}));
exports.PostConditionType = PostConditionType;
var AuthType;
(function (AuthType) {
    AuthType[AuthType["Standard"] = 4] = "Standard";
    AuthType[AuthType["Sponsored"] = 5] = "Sponsored";
})(AuthType || (AuthType = {}));
exports.AuthType = AuthType;
var AddressHashMode;
(function (AddressHashMode) {
    AddressHashMode[AddressHashMode["SerializeP2PKH"] = 0] = "SerializeP2PKH";
    AddressHashMode[AddressHashMode["SerializeP2SH"] = 1] = "SerializeP2SH";
    AddressHashMode[AddressHashMode["SerializeP2WPKH"] = 2] = "SerializeP2WPKH";
    AddressHashMode[AddressHashMode["SerializeP2WSH"] = 3] = "SerializeP2WSH";
})(AddressHashMode || (AddressHashMode = {}));
exports.AddressHashMode = AddressHashMode;
var AddressVersion;
(function (AddressVersion) {
    AddressVersion[AddressVersion["MainnetSingleSig"] = 22] = "MainnetSingleSig";
    AddressVersion[AddressVersion["MainnetMultiSig"] = 20] = "MainnetMultiSig";
    AddressVersion[AddressVersion["TestnetSingleSig"] = 26] = "TestnetSingleSig";
    AddressVersion[AddressVersion["TestnetMultiSig"] = 21] = "TestnetMultiSig";
})(AddressVersion || (AddressVersion = {}));
exports.AddressVersion = AddressVersion;
var PubKeyEncoding;
(function (PubKeyEncoding) {
    PubKeyEncoding[PubKeyEncoding["Compressed"] = 0] = "Compressed";
    PubKeyEncoding[PubKeyEncoding["Uncompressed"] = 1] = "Uncompressed";
})(PubKeyEncoding || (PubKeyEncoding = {}));
exports.PubKeyEncoding = PubKeyEncoding;
var FungibleConditionCode;
(function (FungibleConditionCode) {
    FungibleConditionCode[FungibleConditionCode["Equal"] = 1] = "Equal";
    FungibleConditionCode[FungibleConditionCode["Greater"] = 2] = "Greater";
    FungibleConditionCode[FungibleConditionCode["GreaterEqual"] = 3] = "GreaterEqual";
    FungibleConditionCode[FungibleConditionCode["Less"] = 4] = "Less";
    FungibleConditionCode[FungibleConditionCode["LessEqual"] = 5] = "LessEqual";
})(FungibleConditionCode || (FungibleConditionCode = {}));
exports.FungibleConditionCode = FungibleConditionCode;
var NonFungibleConditionCode;
(function (NonFungibleConditionCode) {
    NonFungibleConditionCode[NonFungibleConditionCode["Sends"] = 16] = "Sends";
    NonFungibleConditionCode[NonFungibleConditionCode["DoesNotSend"] = 17] = "DoesNotSend";
})(NonFungibleConditionCode || (NonFungibleConditionCode = {}));
exports.NonFungibleConditionCode = NonFungibleConditionCode;
var PostConditionPrincipalID;
(function (PostConditionPrincipalID) {
    PostConditionPrincipalID[PostConditionPrincipalID["Origin"] = 1] = "Origin";
    PostConditionPrincipalID[PostConditionPrincipalID["Standard"] = 2] = "Standard";
    PostConditionPrincipalID[PostConditionPrincipalID["Contract"] = 3] = "Contract";
})(PostConditionPrincipalID || (PostConditionPrincipalID = {}));
exports.PostConditionPrincipalID = PostConditionPrincipalID;
var AssetType;
(function (AssetType) {
    AssetType[AssetType["STX"] = 0] = "STX";
    AssetType[AssetType["Fungible"] = 1] = "Fungible";
    AssetType[AssetType["NonFungible"] = 2] = "NonFungible";
})(AssetType || (AssetType = {}));
exports.AssetType = AssetType;
var TxRejectedReason;
(function (TxRejectedReason) {
    TxRejectedReason["Serialization"] = "Serialization";
    TxRejectedReason["Deserialization"] = "Deserialization";
    TxRejectedReason["SignatureValidation"] = "SignatureValidation";
    TxRejectedReason["FeeTooLow"] = "FeeTooLow";
    TxRejectedReason["BadNonce"] = "BadNonce";
    TxRejectedReason["NotEnoughFunds"] = "NotEnoughFunds";
    TxRejectedReason["NoSuchContract"] = "NoSuchContract";
    TxRejectedReason["NoSuchPublicFunction"] = "NoSuchPublicFunction";
    TxRejectedReason["BadFunctionArgument"] = "BadFunctionArgument";
    TxRejectedReason["ContractAlreadyExists"] = "ContractAlreadyExists";
    TxRejectedReason["PoisonMicroblocksDoNotConflict"] = "PoisonMicroblocksDoNotConflict";
    TxRejectedReason["PoisonMicroblockHasUnknownPubKeyHash"] = "PoisonMicroblockHasUnknownPubKeyHash";
    TxRejectedReason["PoisonMicroblockIsInvalid"] = "PoisonMicroblockIsInvalid";
    TxRejectedReason["BadAddressVersionByte"] = "BadAddressVersionByte";
    TxRejectedReason["NoCoinbaseViaMempool"] = "NoCoinbaseViaMempool";
    TxRejectedReason["ServerFailureNoSuchChainTip"] = "ServerFailureNoSuchChainTip";
    TxRejectedReason["ServerFailureDatabase"] = "ServerFailureDatabase";
    TxRejectedReason["ServerFailureOther"] = "ServerFailureOther";
})(TxRejectedReason || (TxRejectedReason = {}));
exports.TxRejectedReason = TxRejectedReason;

},{}],91:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseToCV = exports.validateContractCall = exports.abiFunctionToString = exports.getTypeString = exports.encodeClarityValue = exports.getTypeUnion = exports.isClarityAbiList = exports.isClarityAbiTuple = exports.isClarityAbiOptional = exports.isClarityAbiResponse = exports.isClarityAbiStringUtf8 = exports.isClarityAbiStringAscii = exports.isClarityAbiBuffer = exports.isClarityAbiPrimitive = exports.ClarityAbiTypeId = void 0;
const utils_1 = require("./utils");
const clarity_1 = require("./clarity");
const errors_1 = require("./errors");
const stringCV_1 = require("./clarity/types/stringCV");
const common_1 = require("@stacks/common");
var ClarityAbiTypeId;
(function (ClarityAbiTypeId) {
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeUInt128"] = 1] = "ClarityAbiTypeUInt128";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeInt128"] = 2] = "ClarityAbiTypeInt128";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeBool"] = 3] = "ClarityAbiTypeBool";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypePrincipal"] = 4] = "ClarityAbiTypePrincipal";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeNone"] = 5] = "ClarityAbiTypeNone";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeBuffer"] = 6] = "ClarityAbiTypeBuffer";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeResponse"] = 7] = "ClarityAbiTypeResponse";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeOptional"] = 8] = "ClarityAbiTypeOptional";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeTuple"] = 9] = "ClarityAbiTypeTuple";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeList"] = 10] = "ClarityAbiTypeList";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeStringAscii"] = 11] = "ClarityAbiTypeStringAscii";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeStringUtf8"] = 12] = "ClarityAbiTypeStringUtf8";
    ClarityAbiTypeId[ClarityAbiTypeId["ClarityAbiTypeTraitReference"] = 13] = "ClarityAbiTypeTraitReference";
})(ClarityAbiTypeId = exports.ClarityAbiTypeId || (exports.ClarityAbiTypeId = {}));
const isClarityAbiPrimitive = (val) => typeof val === 'string';
exports.isClarityAbiPrimitive = isClarityAbiPrimitive;
const isClarityAbiBuffer = (val) => val.buffer !== undefined;
exports.isClarityAbiBuffer = isClarityAbiBuffer;
const isClarityAbiStringAscii = (val) => val['string-ascii'] !== undefined;
exports.isClarityAbiStringAscii = isClarityAbiStringAscii;
const isClarityAbiStringUtf8 = (val) => val['string-utf8'] !== undefined;
exports.isClarityAbiStringUtf8 = isClarityAbiStringUtf8;
const isClarityAbiResponse = (val) => val.response !== undefined;
exports.isClarityAbiResponse = isClarityAbiResponse;
const isClarityAbiOptional = (val) => val.optional !== undefined;
exports.isClarityAbiOptional = isClarityAbiOptional;
const isClarityAbiTuple = (val) => val.tuple !== undefined;
exports.isClarityAbiTuple = isClarityAbiTuple;
const isClarityAbiList = (val) => val.list !== undefined;
exports.isClarityAbiList = isClarityAbiList;
function getTypeUnion(val) {
    if ((0, exports.isClarityAbiPrimitive)(val)) {
        if (val === 'uint128') {
            return { id: ClarityAbiTypeId.ClarityAbiTypeUInt128, type: val };
        }
        else if (val === 'int128') {
            return { id: ClarityAbiTypeId.ClarityAbiTypeInt128, type: val };
        }
        else if (val === 'bool') {
            return { id: ClarityAbiTypeId.ClarityAbiTypeBool, type: val };
        }
        else if (val === 'principal') {
            return { id: ClarityAbiTypeId.ClarityAbiTypePrincipal, type: val };
        }
        else if (val === 'trait_reference') {
            return { id: ClarityAbiTypeId.ClarityAbiTypeTraitReference, type: val };
        }
        else if (val === 'none') {
            return { id: ClarityAbiTypeId.ClarityAbiTypeNone, type: val };
        }
        else {
            throw new Error(`Unexpected Clarity ABI type primitive: ${JSON.stringify(val)}`);
        }
    }
    else if ((0, exports.isClarityAbiBuffer)(val)) {
        return { id: ClarityAbiTypeId.ClarityAbiTypeBuffer, type: val };
    }
    else if ((0, exports.isClarityAbiResponse)(val)) {
        return { id: ClarityAbiTypeId.ClarityAbiTypeResponse, type: val };
    }
    else if ((0, exports.isClarityAbiOptional)(val)) {
        return { id: ClarityAbiTypeId.ClarityAbiTypeOptional, type: val };
    }
    else if ((0, exports.isClarityAbiTuple)(val)) {
        return { id: ClarityAbiTypeId.ClarityAbiTypeTuple, type: val };
    }
    else if ((0, exports.isClarityAbiList)(val)) {
        return { id: ClarityAbiTypeId.ClarityAbiTypeList, type: val };
    }
    else if ((0, exports.isClarityAbiStringAscii)(val)) {
        return { id: ClarityAbiTypeId.ClarityAbiTypeStringAscii, type: val };
    }
    else if ((0, exports.isClarityAbiStringUtf8)(val)) {
        return { id: ClarityAbiTypeId.ClarityAbiTypeStringUtf8, type: val };
    }
    else {
        throw new Error(`Unexpected Clarity ABI type: ${JSON.stringify(val)}`);
    }
}
exports.getTypeUnion = getTypeUnion;
function encodeClarityValue(input, val) {
    let union;
    if (input.id !== undefined) {
        union = input;
    }
    else {
        union = getTypeUnion(input);
    }
    switch (union.id) {
        case ClarityAbiTypeId.ClarityAbiTypeUInt128:
            return (0, clarity_1.uintCV)(val);
        case ClarityAbiTypeId.ClarityAbiTypeInt128:
            return (0, clarity_1.intCV)(val);
        case ClarityAbiTypeId.ClarityAbiTypeBool:
            if (val === 'false' || val === '0')
                return (0, clarity_1.falseCV)();
            else if (val === 'true' || val === '1')
                return (0, clarity_1.trueCV)();
            else
                throw new Error(`Unexpected Clarity bool value: ${JSON.stringify(val)}`);
        case ClarityAbiTypeId.ClarityAbiTypePrincipal:
            if (val.includes('.')) {
                const [addr, name] = val.split('.');
                return (0, clarity_1.contractPrincipalCV)(addr, name);
            }
            else {
                return (0, clarity_1.standardPrincipalCV)(val);
            }
        case ClarityAbiTypeId.ClarityAbiTypeTraitReference:
            const [addr, name] = val.split('.');
            return (0, clarity_1.contractPrincipalCV)(addr, name);
        case ClarityAbiTypeId.ClarityAbiTypeNone:
            return (0, clarity_1.noneCV)();
        case ClarityAbiTypeId.ClarityAbiTypeBuffer:
            return (0, clarity_1.bufferCV)((0, common_1.utf8ToBytes)(val));
        case ClarityAbiTypeId.ClarityAbiTypeStringAscii:
            return (0, stringCV_1.stringAsciiCV)(val);
        case ClarityAbiTypeId.ClarityAbiTypeStringUtf8:
            return (0, stringCV_1.stringUtf8CV)(val);
        case ClarityAbiTypeId.ClarityAbiTypeResponse:
            throw new errors_1.NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);
        case ClarityAbiTypeId.ClarityAbiTypeOptional:
            throw new errors_1.NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);
        case ClarityAbiTypeId.ClarityAbiTypeTuple:
            throw new errors_1.NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);
        case ClarityAbiTypeId.ClarityAbiTypeList:
            throw new errors_1.NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);
        default:
            throw new Error(`Unexpected Clarity type ID: ${JSON.stringify(union)}`);
    }
}
exports.encodeClarityValue = encodeClarityValue;
function getTypeString(val) {
    if ((0, exports.isClarityAbiPrimitive)(val)) {
        if (val === 'int128') {
            return 'int';
        }
        else if (val === 'uint128') {
            return 'uint';
        }
        return val;
    }
    else if ((0, exports.isClarityAbiBuffer)(val)) {
        return `(buff ${val.buffer.length})`;
    }
    else if ((0, exports.isClarityAbiStringAscii)(val)) {
        return `(string-ascii ${val['string-ascii'].length})`;
    }
    else if ((0, exports.isClarityAbiStringUtf8)(val)) {
        return `(string-utf8 ${val['string-utf8'].length})`;
    }
    else if ((0, exports.isClarityAbiResponse)(val)) {
        return `(response ${getTypeString(val.response.ok)} ${getTypeString(val.response.error)})`;
    }
    else if ((0, exports.isClarityAbiOptional)(val)) {
        return `(optional ${getTypeString(val.optional)})`;
    }
    else if ((0, exports.isClarityAbiTuple)(val)) {
        return `(tuple ${val.tuple.map(t => `(${t.name} ${getTypeString(t.type)})`).join(' ')})`;
    }
    else if ((0, exports.isClarityAbiList)(val)) {
        return `(list ${val.list.length} ${getTypeString(val.list.type)})`;
    }
    else {
        throw new Error(`Type string unsupported for Clarity type: ${JSON.stringify(val)}`);
    }
}
exports.getTypeString = getTypeString;
function abiFunctionToString(func) {
    const access = func.access === 'read_only' ? 'read-only' : func.access;
    return `(define-${access} (${func.name} ${func.args
        .map(arg => `(${arg.name} ${getTypeString(arg.type)})`)
        .join(' ')}))`;
}
exports.abiFunctionToString = abiFunctionToString;
function matchType(cv, abiType) {
    const union = getTypeUnion(abiType);
    switch (cv.type) {
        case clarity_1.ClarityType.BoolTrue:
        case clarity_1.ClarityType.BoolFalse:
            return union.id === ClarityAbiTypeId.ClarityAbiTypeBool;
        case clarity_1.ClarityType.Int:
            return union.id === ClarityAbiTypeId.ClarityAbiTypeInt128;
        case clarity_1.ClarityType.UInt:
            return union.id === ClarityAbiTypeId.ClarityAbiTypeUInt128;
        case clarity_1.ClarityType.Buffer:
            return (union.id === ClarityAbiTypeId.ClarityAbiTypeBuffer &&
                union.type.buffer.length >= cv.buffer.length);
        case clarity_1.ClarityType.StringASCII:
            return (union.id === ClarityAbiTypeId.ClarityAbiTypeStringAscii &&
                union.type['string-ascii'].length >= cv.data.length);
        case clarity_1.ClarityType.StringUTF8:
            return (union.id === ClarityAbiTypeId.ClarityAbiTypeStringUtf8 &&
                union.type['string-utf8'].length >= cv.data.length);
        case clarity_1.ClarityType.OptionalNone:
            return (union.id === ClarityAbiTypeId.ClarityAbiTypeNone ||
                union.id === ClarityAbiTypeId.ClarityAbiTypeOptional);
        case clarity_1.ClarityType.OptionalSome:
            return (union.id === ClarityAbiTypeId.ClarityAbiTypeOptional &&
                matchType(cv.value, union.type.optional));
        case clarity_1.ClarityType.ResponseErr:
            return (union.id === ClarityAbiTypeId.ClarityAbiTypeResponse &&
                matchType(cv.value, union.type.response.error));
        case clarity_1.ClarityType.ResponseOk:
            return (union.id === ClarityAbiTypeId.ClarityAbiTypeResponse &&
                matchType(cv.value, union.type.response.ok));
        case clarity_1.ClarityType.PrincipalContract:
            return (union.id === ClarityAbiTypeId.ClarityAbiTypePrincipal ||
                union.id === ClarityAbiTypeId.ClarityAbiTypeTraitReference);
        case clarity_1.ClarityType.PrincipalStandard:
            return union.id === ClarityAbiTypeId.ClarityAbiTypePrincipal;
        case clarity_1.ClarityType.List:
            return (union.id == ClarityAbiTypeId.ClarityAbiTypeList &&
                union.type.list.length >= cv.list.length &&
                cv.list.every(val => matchType(val, union.type.list.type)));
        case clarity_1.ClarityType.Tuple:
            if (union.id == ClarityAbiTypeId.ClarityAbiTypeTuple) {
                const tuple = (0, utils_1.cloneDeep)(cv.data);
                for (let i = 0; i < union.type.tuple.length; i++) {
                    const abiTupleEntry = union.type.tuple[i];
                    const key = abiTupleEntry.name;
                    const val = tuple[key];
                    if (val) {
                        if (!matchType(val, abiTupleEntry.type)) {
                            return false;
                        }
                        delete tuple[key];
                    }
                    else {
                        return false;
                    }
                }
                return true;
            }
            else {
                return false;
            }
        default:
            return false;
    }
}
function validateContractCall(payload, abi) {
    const filtered = abi.functions.filter(fn => fn.name === payload.functionName.content);
    if (filtered.length === 1) {
        const abiFunc = filtered[0];
        const abiArgs = abiFunc.args;
        if (payload.functionArgs.length !== abiArgs.length) {
            throw new Error(`Clarity function expects ${abiArgs.length} argument(s) but received ${payload.functionArgs.length}`);
        }
        for (let i = 0; i < payload.functionArgs.length; i++) {
            const payloadArg = payload.functionArgs[i];
            const abiArg = abiArgs[i];
            if (!matchType(payloadArg, abiArg.type)) {
                const argNum = i + 1;
                throw new Error(`Clarity function \`${payload.functionName.content}\` expects argument ${argNum} to be of type ${getTypeString(abiArg.type)}, not ${(0, clarity_1.getCVTypeString)(payloadArg)}`);
            }
        }
        return true;
    }
    else if (filtered.length === 0) {
        throw new Error(`ABI doesn't contain a function with the name ${payload.functionName.content}`);
    }
    else {
        throw new Error(`Malformed ABI. Contains multiple functions with the name ${payload.functionName.content}`);
    }
}
exports.validateContractCall = validateContractCall;
function parseToCV(input, type) {
    const typeString = getTypeString(type);
    if ((0, exports.isClarityAbiPrimitive)(type)) {
        if (type === 'uint128') {
            return (0, clarity_1.uintCV)(input);
        }
        else if (type === 'int128') {
            return (0, clarity_1.intCV)(input);
        }
        else if (type === 'bool') {
            if (input.toLowerCase() === 'true') {
                return (0, clarity_1.trueCV)();
            }
            else if (input.toLowerCase() === 'false') {
                return (0, clarity_1.falseCV)();
            }
            else {
                throw new Error(`Invalid bool value: ${input}`);
            }
        }
        else if (type === 'principal') {
            if (input.includes('.')) {
                const [address, contractName] = input.split('.');
                return (0, clarity_1.contractPrincipalCV)(address, contractName);
            }
            else {
                return (0, clarity_1.standardPrincipalCV)(input);
            }
        }
        else {
            throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);
        }
    }
    else if ((0, exports.isClarityAbiBuffer)(type)) {
        const inputLength = (0, common_1.utf8ToBytes)(input).byteLength;
        if (inputLength > type.buffer.length) {
            throw new Error(`Input exceeds specified buffer length limit of ${type.buffer.length}`);
        }
        return (0, clarity_1.bufferCVFromString)(input);
    }
    else if ((0, exports.isClarityAbiResponse)(type)) {
        throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);
    }
    else if ((0, exports.isClarityAbiOptional)(type)) {
        throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);
    }
    else if ((0, exports.isClarityAbiTuple)(type)) {
        throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);
    }
    else if ((0, exports.isClarityAbiList)(type)) {
        throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);
    }
    else {
        throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);
    }
}
exports.parseToCV = parseToCV;

},{"./clarity":78,"./clarity/types/stringCV":87,"./errors":92,"./utils":103,"@stacks/common":36}],92:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VerificationError = exports.SigningError = exports.NotImplementedError = exports.NoEstimateAvailableError = exports.DeserializationError = exports.SerializationError = void 0;
class TransactionError extends Error {
    constructor(message) {
        super(message);
        this.message = message;
        this.name = this.constructor.name;
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        }
    }
}
class SerializationError extends TransactionError {
    constructor(message) {
        super(message);
    }
}
exports.SerializationError = SerializationError;
class DeserializationError extends TransactionError {
    constructor(message) {
        super(message);
    }
}
exports.DeserializationError = DeserializationError;
class NoEstimateAvailableError extends TransactionError {
    constructor(message) {
        super(message);
    }
}
exports.NoEstimateAvailableError = NoEstimateAvailableError;
class NotImplementedError extends TransactionError {
    constructor(message) {
        super(message);
    }
}
exports.NotImplementedError = NotImplementedError;
class SigningError extends TransactionError {
    constructor(message) {
        super(message);
    }
}
exports.SigningError = SigningError;
class VerificationError extends TransactionError {
    constructor(message) {
        super(message);
    }
}
exports.VerificationError = VerificationError;

},{}],93:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createSTXPostCondition = exports.createNonFungiblePostCondition = exports.createFungiblePostCondition = exports.isCoinbasePayload = exports.isPoisonPayload = exports.isSmartContractPayload = exports.isContractCallPayload = exports.isTokenTransferPayload = exports.serializePayload = exports.isSingleSig = exports.emptyMessageSignature = exports.BytesReader = exports.deserializeTransaction = exports.StacksTransaction = void 0;
var transaction_1 = require("./transaction");
Object.defineProperty(exports, "StacksTransaction", { enumerable: true, get: function () { return transaction_1.StacksTransaction; } });
Object.defineProperty(exports, "deserializeTransaction", { enumerable: true, get: function () { return transaction_1.deserializeTransaction; } });
var bytesReader_1 = require("./bytesReader");
Object.defineProperty(exports, "BytesReader", { enumerable: true, get: function () { return bytesReader_1.BytesReader; } });
var authorization_1 = require("./authorization");
Object.defineProperty(exports, "emptyMessageSignature", { enumerable: true, get: function () { return authorization_1.emptyMessageSignature; } });
Object.defineProperty(exports, "isSingleSig", { enumerable: true, get: function () { return authorization_1.isSingleSig; } });
var payload_1 = require("./payload");
Object.defineProperty(exports, "serializePayload", { enumerable: true, get: function () { return payload_1.serializePayload; } });
Object.defineProperty(exports, "isTokenTransferPayload", { enumerable: true, get: function () { return payload_1.isTokenTransferPayload; } });
Object.defineProperty(exports, "isContractCallPayload", { enumerable: true, get: function () { return payload_1.isContractCallPayload; } });
Object.defineProperty(exports, "isSmartContractPayload", { enumerable: true, get: function () { return payload_1.isSmartContractPayload; } });
Object.defineProperty(exports, "isPoisonPayload", { enumerable: true, get: function () { return payload_1.isPoisonPayload; } });
Object.defineProperty(exports, "isCoinbasePayload", { enumerable: true, get: function () { return payload_1.isCoinbasePayload; } });
var postcondition_1 = require("./postcondition");
Object.defineProperty(exports, "createFungiblePostCondition", { enumerable: true, get: function () { return postcondition_1.createFungiblePostCondition; } });
Object.defineProperty(exports, "createNonFungiblePostCondition", { enumerable: true, get: function () { return postcondition_1.createNonFungiblePostCondition; } });
Object.defineProperty(exports, "createSTXPostCondition", { enumerable: true, get: function () { return postcondition_1.createSTXPostCondition; } });
__exportStar(require("./clarity"), exports);
__exportStar(require("./keys"), exports);
__exportStar(require("./builders"), exports);
__exportStar(require("./types"), exports);
__exportStar(require("./constants"), exports);
__exportStar(require("./contract-abi"), exports);
__exportStar(require("./signer"), exports);
__exportStar(require("./authorization"), exports);
__exportStar(require("./utils"), exports);
__exportStar(require("./common"), exports);
__exportStar(require("./signature"), exports);
__exportStar(require("./structuredDataSignature"), exports);
__exportStar(require("./postcondition-types"), exports);

},{"./authorization":72,"./builders":73,"./bytesReader":74,"./clarity":78,"./common":89,"./constants":90,"./contract-abi":91,"./keys":94,"./payload":95,"./postcondition":97,"./postcondition-types":96,"./signature":98,"./signer":99,"./structuredDataSignature":100,"./transaction":101,"./types":102,"./utils":103}],94:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.publicKeyToAddress = exports.privateKeyToString = exports.getPublicKey = exports.signMessageHashRsv = exports.signWithKey = exports.makeRandomPrivKey = exports.createStacksPrivateKey = exports.deserializePublicKey = exports.compressPublicKey = exports.pubKeyfromPrivKey = exports.serializePublicKey = exports.publicKeyToString = exports.isCompressed = exports.publicKeyFromBytes = exports.publicKeyFromSignatureRsv = exports.publicKeyFromSignatureVrs = exports.createStacksPublicKey = exports.getAddressFromPublicKey = exports.getAddressFromPrivateKey = void 0;
const hmac_1 = require("@noble/hashes/hmac");
const sha256_1 = require("@noble/hashes/sha256");
const secp256k1_1 = require("@noble/secp256k1");
const common_1 = require("@stacks/common");
const c32check_1 = require("c32check");
const common_2 = require("./common");
const constants_1 = require("./constants");
const utils_1 = require("./utils");
secp256k1_1.utils.hmacSha256Sync = (key, ...msgs) => {
    const h = hmac_1.hmac.create(sha256_1.sha256, key);
    msgs.forEach(msg => h.update(msg));
    return h.digest();
};
function getAddressFromPrivateKey(privateKey, transactionVersion = constants_1.TransactionVersion.Mainnet) {
    const pubKey = pubKeyfromPrivKey(privateKey);
    return getAddressFromPublicKey(pubKey.data, transactionVersion);
}
exports.getAddressFromPrivateKey = getAddressFromPrivateKey;
function getAddressFromPublicKey(publicKey, transactionVersion = constants_1.TransactionVersion.Mainnet) {
    publicKey = typeof publicKey === 'string' ? publicKey : (0, common_1.bytesToHex)(publicKey);
    const addrVer = (0, common_2.addressHashModeToVersion)(constants_1.AddressHashMode.SerializeP2PKH, transactionVersion);
    const addr = (0, common_2.addressFromVersionHash)(addrVer, (0, utils_1.hashP2PKH)((0, common_1.hexToBytes)(publicKey)));
    const addrString = (0, common_2.addressToString)(addr);
    return addrString;
}
exports.getAddressFromPublicKey = getAddressFromPublicKey;
function createStacksPublicKey(key) {
    return {
        type: constants_1.StacksMessageType.PublicKey,
        data: (0, common_1.hexToBytes)(key),
    };
}
exports.createStacksPublicKey = createStacksPublicKey;
function publicKeyFromSignatureVrs(messageHash, messageSignature, pubKeyEncoding = constants_1.PubKeyEncoding.Compressed) {
    const parsedSignature = (0, common_1.parseRecoverableSignatureVrs)(messageSignature.data);
    const signature = new secp256k1_1.Signature((0, common_1.hexToBigInt)(parsedSignature.r), (0, common_1.hexToBigInt)(parsedSignature.s));
    const point = secp256k1_1.Point.fromSignature(messageHash, signature, parsedSignature.recoveryId);
    const compressed = pubKeyEncoding === constants_1.PubKeyEncoding.Compressed;
    return point.toHex(compressed);
}
exports.publicKeyFromSignatureVrs = publicKeyFromSignatureVrs;
function publicKeyFromSignatureRsv(messageHash, messageSignature, pubKeyEncoding = constants_1.PubKeyEncoding.Compressed) {
    return publicKeyFromSignatureVrs(messageHash, { ...messageSignature, data: (0, common_1.signatureRsvToVrs)(messageSignature.data) }, pubKeyEncoding);
}
exports.publicKeyFromSignatureRsv = publicKeyFromSignatureRsv;
function publicKeyFromBytes(data) {
    return { type: constants_1.StacksMessageType.PublicKey, data };
}
exports.publicKeyFromBytes = publicKeyFromBytes;
function isCompressed(key) {
    return !(0, common_1.bytesToHex)(key.data).startsWith('04');
}
exports.isCompressed = isCompressed;
function publicKeyToString(key) {
    return (0, common_1.bytesToHex)(key.data);
}
exports.publicKeyToString = publicKeyToString;
function serializePublicKey(key) {
    return key.data.slice();
}
exports.serializePublicKey = serializePublicKey;
function pubKeyfromPrivKey(privateKey) {
    const privKey = createStacksPrivateKey(privateKey);
    const publicKey = (0, secp256k1_1.getPublicKey)(privKey.data.slice(0, 32), privKey.compressed);
    return createStacksPublicKey((0, common_1.bytesToHex)(publicKey));
}
exports.pubKeyfromPrivKey = pubKeyfromPrivKey;
function compressPublicKey(publicKey) {
    const hex = typeof publicKey === 'string' ? publicKey : (0, common_1.bytesToHex)(publicKey);
    const compressed = secp256k1_1.Point.fromHex(hex).toHex(true);
    return createStacksPublicKey(compressed);
}
exports.compressPublicKey = compressPublicKey;
function deserializePublicKey(bytesReader) {
    const fieldId = bytesReader.readUInt8();
    const keyLength = fieldId !== 4 ? constants_1.COMPRESSED_PUBKEY_LENGTH_BYTES : constants_1.UNCOMPRESSED_PUBKEY_LENGTH_BYTES;
    return publicKeyFromBytes((0, common_1.concatArray)([fieldId, bytesReader.readBytes(keyLength)]));
}
exports.deserializePublicKey = deserializePublicKey;
function createStacksPrivateKey(key) {
    const data = (0, common_1.privateKeyToBytes)(key);
    const compressed = data.length == common_1.PRIVATE_KEY_COMPRESSED_LENGTH;
    return { data, compressed };
}
exports.createStacksPrivateKey = createStacksPrivateKey;
function makeRandomPrivKey() {
    return createStacksPrivateKey(secp256k1_1.utils.randomPrivateKey());
}
exports.makeRandomPrivKey = makeRandomPrivKey;
function signWithKey(privateKey, messageHash) {
    const [rawSignature, recoveryId] = (0, secp256k1_1.signSync)(messageHash, privateKey.data.slice(0, 32), {
        canonical: true,
        recovered: true,
    });
    if (recoveryId == null) {
        throw new Error('No signature recoveryId received');
    }
    const recoveryIdHex = (0, common_1.intToHex)(recoveryId, 1);
    const recoverableSignatureString = recoveryIdHex + secp256k1_1.Signature.fromHex(rawSignature).toCompactHex();
    return (0, common_2.createMessageSignature)(recoverableSignatureString);
}
exports.signWithKey = signWithKey;
function signMessageHashRsv({ messageHash, privateKey, }) {
    const messageSignature = signWithKey(privateKey, messageHash);
    return { ...messageSignature, data: (0, common_1.signatureVrsToRsv)(messageSignature.data) };
}
exports.signMessageHashRsv = signMessageHashRsv;
function getPublicKey(privateKey) {
    return pubKeyfromPrivKey(privateKey.data);
}
exports.getPublicKey = getPublicKey;
function privateKeyToString(privateKey) {
    return (0, common_1.bytesToHex)(privateKey.data);
}
exports.privateKeyToString = privateKeyToString;
function publicKeyToAddress(version, publicKey) {
    return (0, c32check_1.c32address)(version, (0, common_1.bytesToHex)((0, utils_1.hash160)(publicKey.data)));
}
exports.publicKeyToAddress = publicKeyToAddress;

},{"./common":89,"./constants":90,"./utils":103,"@noble/hashes/hmac":9,"@noble/hashes/sha256":12,"@noble/secp256k1":15,"@stacks/common":36,"c32check":112}],95:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deserializePayload = exports.serializePayload = exports.createCoinbasePayload = exports.createPoisonPayload = exports.createSmartContractPayload = exports.createContractCallPayload = exports.createTokenTransferPayload = exports.isCoinbasePayload = exports.isPoisonPayload = exports.isSmartContractPayload = exports.isContractCallPayload = exports.isTokenTransferPayload = void 0;
const common_1 = require("@stacks/common");
const constants_1 = require("./constants");
const clarity_1 = require("./clarity/");
const principalCV_1 = require("./clarity/types/principalCV");
const postcondition_types_1 = require("./postcondition-types");
const types_1 = require("./types");
function isTokenTransferPayload(p) {
    return p.payloadType === constants_1.PayloadType.TokenTransfer;
}
exports.isTokenTransferPayload = isTokenTransferPayload;
function isContractCallPayload(p) {
    return p.payloadType === constants_1.PayloadType.ContractCall;
}
exports.isContractCallPayload = isContractCallPayload;
function isSmartContractPayload(p) {
    return p.payloadType === constants_1.PayloadType.SmartContract;
}
exports.isSmartContractPayload = isSmartContractPayload;
function isPoisonPayload(p) {
    return p.payloadType === constants_1.PayloadType.PoisonMicroblock;
}
exports.isPoisonPayload = isPoisonPayload;
function isCoinbasePayload(p) {
    return p.payloadType === constants_1.PayloadType.Coinbase;
}
exports.isCoinbasePayload = isCoinbasePayload;
function createTokenTransferPayload(recipient, amount, memo) {
    if (typeof recipient === 'string') {
        recipient = (0, principalCV_1.principalCV)(recipient);
    }
    if (typeof memo === 'string') {
        memo = (0, types_1.createMemoString)(memo);
    }
    return {
        type: constants_1.StacksMessageType.Payload,
        payloadType: constants_1.PayloadType.TokenTransfer,
        recipient,
        amount: (0, common_1.intToBigInt)(amount, false),
        memo: memo ?? (0, types_1.createMemoString)(''),
    };
}
exports.createTokenTransferPayload = createTokenTransferPayload;
function createContractCallPayload(contractAddress, contractName, functionName, functionArgs) {
    if (typeof contractAddress === 'string') {
        contractAddress = (0, postcondition_types_1.createAddress)(contractAddress);
    }
    if (typeof contractName === 'string') {
        contractName = (0, postcondition_types_1.createLPString)(contractName);
    }
    if (typeof functionName === 'string') {
        functionName = (0, postcondition_types_1.createLPString)(functionName);
    }
    return {
        type: constants_1.StacksMessageType.Payload,
        payloadType: constants_1.PayloadType.ContractCall,
        contractAddress,
        contractName,
        functionName,
        functionArgs,
    };
}
exports.createContractCallPayload = createContractCallPayload;
function createSmartContractPayload(contractName, codeBody, clarityVersion) {
    if (typeof contractName === 'string') {
        contractName = (0, postcondition_types_1.createLPString)(contractName);
    }
    if (typeof codeBody === 'string') {
        codeBody = (0, types_1.codeBodyString)(codeBody);
    }
    if (typeof clarityVersion === 'number') {
        return {
            type: constants_1.StacksMessageType.Payload,
            payloadType: constants_1.PayloadType.VersionedSmartContract,
            clarityVersion,
            contractName,
            codeBody,
        };
    }
    return {
        type: constants_1.StacksMessageType.Payload,
        payloadType: constants_1.PayloadType.SmartContract,
        contractName,
        codeBody,
    };
}
exports.createSmartContractPayload = createSmartContractPayload;
function createPoisonPayload() {
    return { type: constants_1.StacksMessageType.Payload, payloadType: constants_1.PayloadType.PoisonMicroblock };
}
exports.createPoisonPayload = createPoisonPayload;
function createCoinbasePayload(coinbaseBytes, altRecipient) {
    if (coinbaseBytes.byteLength != constants_1.COINBASE_BYTES_LENGTH) {
        throw Error(`Coinbase buffer size must be ${constants_1.COINBASE_BYTES_LENGTH} bytes`);
    }
    if (altRecipient != undefined) {
        return {
            type: constants_1.StacksMessageType.Payload,
            payloadType: constants_1.PayloadType.CoinbaseToAltRecipient,
            coinbaseBytes,
            recipient: altRecipient,
        };
    }
    return {
        type: constants_1.StacksMessageType.Payload,
        payloadType: constants_1.PayloadType.Coinbase,
        coinbaseBytes,
    };
}
exports.createCoinbasePayload = createCoinbasePayload;
function serializePayload(payload) {
    const bytesArray = [];
    bytesArray.push(payload.payloadType);
    switch (payload.payloadType) {
        case constants_1.PayloadType.TokenTransfer:
            bytesArray.push((0, clarity_1.serializeCV)(payload.recipient));
            bytesArray.push((0, common_1.intToBytes)(payload.amount, false, 8));
            bytesArray.push((0, types_1.serializeStacksMessage)(payload.memo));
            break;
        case constants_1.PayloadType.ContractCall:
            bytesArray.push((0, types_1.serializeStacksMessage)(payload.contractAddress));
            bytesArray.push((0, types_1.serializeStacksMessage)(payload.contractName));
            bytesArray.push((0, types_1.serializeStacksMessage)(payload.functionName));
            const numArgs = new Uint8Array(4);
            (0, common_1.writeUInt32BE)(numArgs, payload.functionArgs.length, 0);
            bytesArray.push(numArgs);
            payload.functionArgs.forEach(arg => {
                bytesArray.push((0, clarity_1.serializeCV)(arg));
            });
            break;
        case constants_1.PayloadType.SmartContract:
            bytesArray.push((0, types_1.serializeStacksMessage)(payload.contractName));
            bytesArray.push((0, types_1.serializeStacksMessage)(payload.codeBody));
            break;
        case constants_1.PayloadType.VersionedSmartContract:
            bytesArray.push(payload.clarityVersion);
            bytesArray.push((0, types_1.serializeStacksMessage)(payload.contractName));
            bytesArray.push((0, types_1.serializeStacksMessage)(payload.codeBody));
            break;
        case constants_1.PayloadType.PoisonMicroblock:
            break;
        case constants_1.PayloadType.Coinbase:
            bytesArray.push(payload.coinbaseBytes);
            break;
        case constants_1.PayloadType.CoinbaseToAltRecipient:
            bytesArray.push(payload.coinbaseBytes);
            bytesArray.push((0, clarity_1.serializeCV)(payload.recipient));
            break;
    }
    return (0, common_1.concatArray)(bytesArray);
}
exports.serializePayload = serializePayload;
function deserializePayload(bytesReader) {
    const payloadType = bytesReader.readUInt8Enum(constants_1.PayloadType, n => {
        throw new Error(`Cannot recognize PayloadType: ${n}`);
    });
    switch (payloadType) {
        case constants_1.PayloadType.TokenTransfer:
            const recipient = (0, clarity_1.deserializeCV)(bytesReader);
            const amount = (0, common_1.intToBigInt)(bytesReader.readBytes(8), false);
            const memo = (0, types_1.deserializeMemoString)(bytesReader);
            return createTokenTransferPayload(recipient, amount, memo);
        case constants_1.PayloadType.ContractCall:
            const contractAddress = (0, types_1.deserializeAddress)(bytesReader);
            const contractCallName = (0, types_1.deserializeLPString)(bytesReader);
            const functionName = (0, types_1.deserializeLPString)(bytesReader);
            const functionArgs = [];
            const numberOfArgs = bytesReader.readUInt32BE();
            for (let i = 0; i < numberOfArgs; i++) {
                const clarityValue = (0, clarity_1.deserializeCV)(bytesReader);
                functionArgs.push(clarityValue);
            }
            return createContractCallPayload(contractAddress, contractCallName, functionName, functionArgs);
        case constants_1.PayloadType.SmartContract:
            const smartContractName = (0, types_1.deserializeLPString)(bytesReader);
            const codeBody = (0, types_1.deserializeLPString)(bytesReader, 4, 100000);
            return createSmartContractPayload(smartContractName, codeBody);
        case constants_1.PayloadType.VersionedSmartContract: {
            const clarityVersion = bytesReader.readUInt8Enum(constants_1.ClarityVersion, n => {
                throw new Error(`Cannot recognize ClarityVersion: ${n}`);
            });
            const smartContractName = (0, types_1.deserializeLPString)(bytesReader);
            const codeBody = (0, types_1.deserializeLPString)(bytesReader, 4, 100000);
            return createSmartContractPayload(smartContractName, codeBody, clarityVersion);
        }
        case constants_1.PayloadType.PoisonMicroblock:
            return createPoisonPayload();
        case constants_1.PayloadType.Coinbase:
            const coinbaseBytes = bytesReader.readBytes(constants_1.COINBASE_BYTES_LENGTH);
            return createCoinbasePayload(coinbaseBytes);
        case constants_1.PayloadType.CoinbaseToAltRecipient:
            const coinbaseToAltRecipientBuffer = bytesReader.readBytes(constants_1.COINBASE_BYTES_LENGTH);
            const altRecipient = (0, clarity_1.deserializeCV)(bytesReader);
            return createCoinbasePayload(coinbaseToAltRecipientBuffer, altRecipient);
    }
}
exports.deserializePayload = deserializePayload;

},{"./clarity/":78,"./clarity/types/principalCV":85,"./constants":90,"./postcondition-types":96,"./types":102,"@stacks/common":36}],96:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createStandardPrincipal = exports.createContractPrincipal = exports.parsePrincipalString = exports.createAddress = exports.createAssetInfo = exports.createLPString = exports.parseAssetInfoString = void 0;
const constants_1 = require("./constants");
const c32check_1 = require("c32check");
const utils_1 = require("./utils");
function parseAssetInfoString(id) {
    const [assetAddress, assetContractName, assetTokenName] = id.split(/\.|::/);
    const assetInfo = createAssetInfo(assetAddress, assetContractName, assetTokenName);
    return assetInfo;
}
exports.parseAssetInfoString = parseAssetInfoString;
function createLPString(content, lengthPrefixBytes, maxLengthBytes) {
    const prefixLength = lengthPrefixBytes || 1;
    const maxLength = maxLengthBytes || constants_1.MAX_STRING_LENGTH_BYTES;
    if ((0, utils_1.exceedsMaxLengthBytes)(content, maxLength)) {
        throw new Error(`String length exceeds maximum bytes ${maxLength}`);
    }
    return {
        type: constants_1.StacksMessageType.LengthPrefixedString,
        content,
        lengthPrefixBytes: prefixLength,
        maxLengthBytes: maxLength,
    };
}
exports.createLPString = createLPString;
function createAssetInfo(addressString, contractName, assetName) {
    return {
        type: constants_1.StacksMessageType.AssetInfo,
        address: createAddress(addressString),
        contractName: createLPString(contractName),
        assetName: createLPString(assetName),
    };
}
exports.createAssetInfo = createAssetInfo;
function createAddress(c32AddressString) {
    const addressData = (0, c32check_1.c32addressDecode)(c32AddressString);
    return {
        type: constants_1.StacksMessageType.Address,
        version: addressData[0],
        hash160: addressData[1],
    };
}
exports.createAddress = createAddress;
function parsePrincipalString(principalString) {
    if (principalString.includes('.')) {
        const [address, contractName] = principalString.split('.');
        return createContractPrincipal(address, contractName);
    }
    else {
        return createStandardPrincipal(principalString);
    }
}
exports.parsePrincipalString = parsePrincipalString;
function createContractPrincipal(addressString, contractName) {
    const addr = createAddress(addressString);
    const name = createLPString(contractName);
    return {
        type: constants_1.StacksMessageType.Principal,
        prefix: constants_1.PostConditionPrincipalID.Contract,
        address: addr,
        contractName: name,
    };
}
exports.createContractPrincipal = createContractPrincipal;
function createStandardPrincipal(addressString) {
    const addr = createAddress(addressString);
    return {
        type: constants_1.StacksMessageType.Principal,
        prefix: constants_1.PostConditionPrincipalID.Standard,
        address: addr,
    };
}
exports.createStandardPrincipal = createStandardPrincipal;

},{"./constants":90,"./utils":103,"c32check":112}],97:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createNonFungiblePostCondition = exports.createFungiblePostCondition = exports.createSTXPostCondition = void 0;
const common_1 = require("@stacks/common");
const constants_1 = require("./constants");
const postcondition_types_1 = require("./postcondition-types");
function createSTXPostCondition(principal, conditionCode, amount) {
    if (typeof principal === 'string') {
        principal = (0, postcondition_types_1.parsePrincipalString)(principal);
    }
    return {
        type: constants_1.StacksMessageType.PostCondition,
        conditionType: constants_1.PostConditionType.STX,
        principal,
        conditionCode,
        amount: (0, common_1.intToBigInt)(amount, false),
    };
}
exports.createSTXPostCondition = createSTXPostCondition;
function createFungiblePostCondition(principal, conditionCode, amount, assetInfo) {
    if (typeof principal === 'string') {
        principal = (0, postcondition_types_1.parsePrincipalString)(principal);
    }
    if (typeof assetInfo === 'string') {
        assetInfo = (0, postcondition_types_1.parseAssetInfoString)(assetInfo);
    }
    return {
        type: constants_1.StacksMessageType.PostCondition,
        conditionType: constants_1.PostConditionType.Fungible,
        principal,
        conditionCode,
        amount: (0, common_1.intToBigInt)(amount, false),
        assetInfo,
    };
}
exports.createFungiblePostCondition = createFungiblePostCondition;
function createNonFungiblePostCondition(principal, conditionCode, assetInfo, assetName) {
    if (typeof principal === 'string') {
        principal = (0, postcondition_types_1.parsePrincipalString)(principal);
    }
    if (typeof assetInfo === 'string') {
        assetInfo = (0, postcondition_types_1.parseAssetInfoString)(assetInfo);
    }
    return {
        type: constants_1.StacksMessageType.PostCondition,
        conditionType: constants_1.PostConditionType.NonFungible,
        principal,
        conditionCode,
        assetInfo,
        assetName,
    };
}
exports.createNonFungiblePostCondition = createNonFungiblePostCondition;

},{"./constants":90,"./postcondition-types":96,"@stacks/common":36}],98:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.serializeTransactionAuthField = exports.serializeMessageSignature = exports.deserializeTransactionAuthField = exports.createTransactionAuthField = exports.deserializeMessageSignature = exports.AuthFieldType = void 0;
const errors_1 = require("./errors");
const constants_1 = require("./constants");
const keys_1 = require("./keys");
const common_1 = require("./common");
const common_2 = require("@stacks/common");
var AuthFieldType;
(function (AuthFieldType) {
    AuthFieldType[AuthFieldType["PublicKeyCompressed"] = 0] = "PublicKeyCompressed";
    AuthFieldType[AuthFieldType["PublicKeyUncompressed"] = 1] = "PublicKeyUncompressed";
    AuthFieldType[AuthFieldType["SignatureCompressed"] = 2] = "SignatureCompressed";
    AuthFieldType[AuthFieldType["SignatureUncompressed"] = 3] = "SignatureUncompressed";
})(AuthFieldType = exports.AuthFieldType || (exports.AuthFieldType = {}));
function deserializeMessageSignature(bytesReader) {
    return (0, common_1.createMessageSignature)((0, common_2.bytesToHex)(bytesReader.readBytes(constants_1.RECOVERABLE_ECDSA_SIG_LENGTH_BYTES)));
}
exports.deserializeMessageSignature = deserializeMessageSignature;
function createTransactionAuthField(pubKeyEncoding, contents) {
    return {
        pubKeyEncoding,
        type: constants_1.StacksMessageType.TransactionAuthField,
        contents,
    };
}
exports.createTransactionAuthField = createTransactionAuthField;
function deserializeTransactionAuthField(bytesReader) {
    const authFieldType = bytesReader.readUInt8Enum(AuthFieldType, n => {
        throw new errors_1.DeserializationError(`Could not read ${n} as AuthFieldType`);
    });
    switch (authFieldType) {
        case AuthFieldType.PublicKeyCompressed:
            return createTransactionAuthField(constants_1.PubKeyEncoding.Compressed, (0, keys_1.deserializePublicKey)(bytesReader));
        case AuthFieldType.PublicKeyUncompressed:
            return createTransactionAuthField(constants_1.PubKeyEncoding.Uncompressed, (0, keys_1.deserializePublicKey)(bytesReader));
        case AuthFieldType.SignatureCompressed:
            return createTransactionAuthField(constants_1.PubKeyEncoding.Compressed, deserializeMessageSignature(bytesReader));
        case AuthFieldType.SignatureUncompressed:
            return createTransactionAuthField(constants_1.PubKeyEncoding.Uncompressed, deserializeMessageSignature(bytesReader));
        default:
            throw new Error(`Unknown auth field type: ${JSON.stringify(authFieldType)}`);
    }
}
exports.deserializeTransactionAuthField = deserializeTransactionAuthField;
function serializeMessageSignature(messageSignature) {
    return (0, common_2.hexToBytes)(messageSignature.data);
}
exports.serializeMessageSignature = serializeMessageSignature;
function serializeTransactionAuthField(field) {
    const bytesArray = [];
    switch (field.contents.type) {
        case constants_1.StacksMessageType.PublicKey:
            if (field.pubKeyEncoding == constants_1.PubKeyEncoding.Compressed) {
                bytesArray.push(AuthFieldType.PublicKeyCompressed);
                bytesArray.push((0, keys_1.serializePublicKey)(field.contents));
            }
            else {
                bytesArray.push(AuthFieldType.PublicKeyUncompressed);
                bytesArray.push((0, keys_1.serializePublicKey)((0, keys_1.compressPublicKey)(field.contents.data)));
            }
            break;
        case constants_1.StacksMessageType.MessageSignature:
            if (field.pubKeyEncoding == constants_1.PubKeyEncoding.Compressed) {
                bytesArray.push(AuthFieldType.SignatureCompressed);
            }
            else {
                bytesArray.push(AuthFieldType.SignatureUncompressed);
            }
            bytesArray.push(serializeMessageSignature(field.contents));
            break;
    }
    return (0, common_2.concatArray)(bytesArray);
}
exports.serializeTransactionAuthField = serializeTransactionAuthField;

},{"./common":89,"./constants":90,"./errors":92,"./keys":94,"@stacks/common":36}],99:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionSigner = void 0;
const authorization_1 = require("./authorization");
const utils_1 = require("./utils");
const constants_1 = require("./constants");
const errors_1 = require("./errors");
class TransactionSigner {
    constructor(transaction) {
        this.transaction = transaction;
        this.sigHash = transaction.signBegin();
        this.originDone = false;
        this.checkOversign = true;
        this.checkOverlap = true;
        const spendingCondition = transaction.auth.spendingCondition;
        if (spendingCondition && !(0, authorization_1.isSingleSig)(spendingCondition)) {
            if (spendingCondition.fields.filter(field => field.contents.type === constants_1.StacksMessageType.MessageSignature).length >= spendingCondition.signaturesRequired) {
                throw new Error('SpendingCondition has more signatures than are expected');
            }
            spendingCondition.fields.forEach(field => {
                if (field.contents.type === constants_1.StacksMessageType.MessageSignature) {
                    const signature = field.contents;
                    const nextVerify = (0, authorization_1.nextVerification)(this.sigHash, transaction.auth.authType, spendingCondition.fee, spendingCondition.nonce, constants_1.PubKeyEncoding.Compressed, signature);
                    this.sigHash = nextVerify.nextSigHash;
                }
            });
        }
    }
    static createSponsorSigner(transaction, spendingCondition) {
        if (transaction.auth.authType != constants_1.AuthType.Sponsored) {
            throw new errors_1.SigningError('Cannot add sponsor to non-sponsored transaction');
        }
        const tx = (0, utils_1.cloneDeep)(transaction);
        tx.setSponsor(spendingCondition);
        const originSigHash = tx.verifyOrigin();
        const signer = new this(tx);
        signer.originDone = true;
        signer.sigHash = originSigHash;
        signer.checkOversign = true;
        signer.checkOverlap = true;
        return signer;
    }
    signOrigin(privateKey) {
        if (this.checkOverlap && this.originDone) {
            throw new errors_1.SigningError('Cannot sign origin after sponsor key');
        }
        if (this.transaction.auth === undefined) {
            throw new errors_1.SigningError('"transaction.auth" is undefined');
        }
        if (this.transaction.auth.spendingCondition === undefined) {
            throw new errors_1.SigningError('"transaction.auth.spendingCondition" is undefined');
        }
        if (!(0, authorization_1.isSingleSig)(this.transaction.auth.spendingCondition)) {
            const spendingCondition = this.transaction.auth.spendingCondition;
            if (this.checkOversign &&
                spendingCondition.fields.filter(field => field.contents.type === constants_1.StacksMessageType.MessageSignature).length >= spendingCondition.signaturesRequired) {
                throw new Error('Origin would have too many signatures');
            }
        }
        const nextSighash = this.transaction.signNextOrigin(this.sigHash, privateKey);
        this.sigHash = nextSighash;
    }
    appendOrigin(publicKey) {
        if (this.checkOverlap && this.originDone) {
            throw Error('Cannot append public key to origin after sponsor key');
        }
        if (this.transaction.auth === undefined) {
            throw new Error('"transaction.auth" is undefined');
        }
        if (this.transaction.auth.spendingCondition === undefined) {
            throw new Error('"transaction.auth.spendingCondition" is undefined');
        }
        this.transaction.appendPubkey(publicKey);
    }
    signSponsor(privateKey) {
        if (this.transaction.auth === undefined) {
            throw new errors_1.SigningError('"transaction.auth" is undefined');
        }
        if (this.transaction.auth.authType !== constants_1.AuthType.Sponsored) {
            throw new errors_1.SigningError('"transaction.auth.authType" is not AuthType.Sponsored');
        }
        const nextSighash = this.transaction.signNextSponsor(this.sigHash, privateKey);
        this.sigHash = nextSighash;
        this.originDone = true;
    }
    getTxInComplete() {
        return (0, utils_1.cloneDeep)(this.transaction);
    }
    resume(transaction) {
        this.transaction = (0, utils_1.cloneDeep)(transaction);
        this.sigHash = transaction.signBegin();
    }
}
exports.TransactionSigner = TransactionSigner;

},{"./authorization":72,"./constants":90,"./errors":92,"./utils":103}],100:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.signStructuredData = exports.decodeStructuredDataSignature = exports.encodeStructuredData = exports.hashStructuredData = exports.STRUCTURED_DATA_PREFIX = void 0;
const sha256_1 = require("@noble/hashes/sha256");
const common_1 = require("@stacks/common");
const clarity_1 = require("./clarity");
const constants_1 = require("./constants");
const keys_1 = require("./keys");
exports.STRUCTURED_DATA_PREFIX = new Uint8Array([0x53, 0x49, 0x50, 0x30, 0x31, 0x38]);
function hashStructuredData(structuredData) {
    return (0, sha256_1.sha256)((0, clarity_1.serializeCV)(structuredData));
}
exports.hashStructuredData = hashStructuredData;
const hash256BytesLength = 32;
function isDomain(value) {
    if (value.type !== clarity_1.ClarityType.Tuple)
        return false;
    if (!['name', 'version', 'chain-id'].every(key => key in value.data))
        return false;
    if (!['name', 'version'].every(key => value.data[key].type === clarity_1.ClarityType.StringASCII))
        return false;
    if (value.data['chain-id'].type !== clarity_1.ClarityType.UInt)
        return false;
    return true;
}
function encodeStructuredData({ message, domain, }) {
    const structuredDataHash = hashStructuredData(message);
    if (!isDomain(domain)) {
        throw new Error("domain parameter must be a valid domain of type TupleCV with keys 'name', 'version', 'chain-id' with respective types StringASCII, StringASCII, UInt");
    }
    const domainHash = hashStructuredData(domain);
    return (0, common_1.concatBytes)(exports.STRUCTURED_DATA_PREFIX, domainHash, structuredDataHash);
}
exports.encodeStructuredData = encodeStructuredData;
function decodeStructuredDataSignature(signature) {
    const encodedMessageBytes = typeof signature === 'string' ? (0, common_1.utf8ToBytes)(signature) : signature;
    const domainHash = encodedMessageBytes.slice(exports.STRUCTURED_DATA_PREFIX.length, exports.STRUCTURED_DATA_PREFIX.length + hash256BytesLength);
    const messageHash = encodedMessageBytes.slice(exports.STRUCTURED_DATA_PREFIX.length + hash256BytesLength);
    return {
        domainHash,
        messageHash,
    };
}
exports.decodeStructuredDataSignature = decodeStructuredDataSignature;
function signStructuredData({ message, domain, privateKey, }) {
    const structuredDataHash = (0, common_1.bytesToHex)((0, sha256_1.sha256)(encodeStructuredData({ message, domain })));
    const { data } = (0, keys_1.signMessageHashRsv)({
        messageHash: structuredDataHash,
        privateKey,
    });
    return {
        data,
        type: constants_1.StacksMessageType.StructuredDataSignature,
    };
}
exports.signStructuredData = signStructuredData;

},{"./clarity":78,"./constants":90,"./keys":94,"@noble/hashes/sha256":12,"@stacks/common":36}],101:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deserializeTransaction = exports.StacksTransaction = void 0;
const common_1 = require("@stacks/common");
const constants_1 = require("./constants");
const authorization_1 = require("./authorization");
const signature_1 = require("./signature");
const utils_1 = require("./utils");
const payload_1 = require("./payload");
const types_1 = require("./types");
const keys_1 = require("./keys");
const bytesReader_1 = require("./bytesReader");
const errors_1 = require("./errors");
class StacksTransaction {
    constructor(version, auth, payload, postConditions, postConditionMode, anchorMode, chainId) {
        this.version = version;
        this.auth = auth;
        if ('amount' in payload) {
            this.payload = {
                ...payload,
                amount: (0, common_1.intToBigInt)(payload.amount, false),
            };
        }
        else {
            this.payload = payload;
        }
        this.chainId = chainId ?? constants_1.DEFAULT_CHAIN_ID;
        this.postConditionMode = postConditionMode ?? constants_1.PostConditionMode.Deny;
        this.postConditions = postConditions ?? (0, types_1.createLPList)([]);
        if (anchorMode) {
            this.anchorMode = (0, constants_1.anchorModeFromNameOrValue)(anchorMode);
        }
        else {
            switch (payload.payloadType) {
                case constants_1.PayloadType.Coinbase:
                case constants_1.PayloadType.CoinbaseToAltRecipient:
                case constants_1.PayloadType.PoisonMicroblock: {
                    this.anchorMode = constants_1.AnchorMode.OnChainOnly;
                    break;
                }
                case constants_1.PayloadType.ContractCall:
                case constants_1.PayloadType.SmartContract:
                case constants_1.PayloadType.VersionedSmartContract:
                case constants_1.PayloadType.TokenTransfer: {
                    this.anchorMode = constants_1.AnchorMode.Any;
                    break;
                }
            }
        }
    }
    signBegin() {
        const tx = (0, utils_1.cloneDeep)(this);
        tx.auth = (0, authorization_1.intoInitialSighashAuth)(tx.auth);
        return tx.txid();
    }
    verifyBegin() {
        const tx = (0, utils_1.cloneDeep)(this);
        tx.auth = (0, authorization_1.intoInitialSighashAuth)(tx.auth);
        return tx.txid();
    }
    verifyOrigin() {
        return (0, authorization_1.verifyOrigin)(this.auth, this.verifyBegin());
    }
    signNextOrigin(sigHash, privateKey) {
        if (this.auth.spendingCondition === undefined) {
            throw new Error('"auth.spendingCondition" is undefined');
        }
        if (this.auth.authType === undefined) {
            throw new Error('"auth.authType" is undefined');
        }
        return this.signAndAppend(this.auth.spendingCondition, sigHash, constants_1.AuthType.Standard, privateKey);
    }
    signNextSponsor(sigHash, privateKey) {
        if (this.auth.authType === constants_1.AuthType.Sponsored) {
            return this.signAndAppend(this.auth.sponsorSpendingCondition, sigHash, constants_1.AuthType.Sponsored, privateKey);
        }
        else {
            throw new Error('"auth.sponsorSpendingCondition" is undefined');
        }
    }
    appendPubkey(publicKey) {
        const cond = this.auth.spendingCondition;
        if (cond && !(0, authorization_1.isSingleSig)(cond)) {
            const compressed = (0, keys_1.isCompressed)(publicKey);
            cond.fields.push((0, signature_1.createTransactionAuthField)(compressed ? constants_1.PubKeyEncoding.Compressed : constants_1.PubKeyEncoding.Uncompressed, publicKey));
        }
        else {
            throw new Error(`Can't append public key to a singlesig condition`);
        }
    }
    signAndAppend(condition, curSigHash, authType, privateKey) {
        const { nextSig, nextSigHash } = (0, authorization_1.nextSignature)(curSigHash, authType, condition.fee, condition.nonce, privateKey);
        if ((0, authorization_1.isSingleSig)(condition)) {
            condition.signature = nextSig;
        }
        else {
            const compressed = (0, common_1.bytesToHex)(privateKey.data).endsWith('01');
            condition.fields.push((0, signature_1.createTransactionAuthField)(compressed ? constants_1.PubKeyEncoding.Compressed : constants_1.PubKeyEncoding.Uncompressed, nextSig));
        }
        return nextSigHash;
    }
    txid() {
        const serialized = this.serialize();
        return (0, utils_1.txidFromData)(serialized);
    }
    setSponsor(sponsorSpendingCondition) {
        if (this.auth.authType != constants_1.AuthType.Sponsored) {
            throw new errors_1.SigningError('Cannot sponsor sign a non-sponsored transaction');
        }
        this.auth = (0, authorization_1.setSponsor)(this.auth, sponsorSpendingCondition);
    }
    setFee(amount) {
        this.auth = (0, authorization_1.setFee)(this.auth, amount);
    }
    setNonce(nonce) {
        this.auth = (0, authorization_1.setNonce)(this.auth, nonce);
    }
    setSponsorNonce(nonce) {
        if (this.auth.authType != constants_1.AuthType.Sponsored) {
            throw new errors_1.SigningError('Cannot sponsor sign a non-sponsored transaction');
        }
        this.auth = (0, authorization_1.setSponsorNonce)(this.auth, nonce);
    }
    serialize() {
        if (this.version === undefined) {
            throw new errors_1.SerializationError('"version" is undefined');
        }
        if (this.chainId === undefined) {
            throw new errors_1.SerializationError('"chainId" is undefined');
        }
        if (this.auth === undefined) {
            throw new errors_1.SerializationError('"auth" is undefined');
        }
        if (this.anchorMode === undefined) {
            throw new errors_1.SerializationError('"anchorMode" is undefined');
        }
        if (this.payload === undefined) {
            throw new errors_1.SerializationError('"payload" is undefined');
        }
        const bytesArray = [];
        bytesArray.push(this.version);
        const chainIdBytes = new Uint8Array(4);
        (0, common_1.writeUInt32BE)(chainIdBytes, this.chainId, 0);
        bytesArray.push(chainIdBytes);
        bytesArray.push((0, authorization_1.serializeAuthorization)(this.auth));
        bytesArray.push(this.anchorMode);
        bytesArray.push(this.postConditionMode);
        bytesArray.push((0, types_1.serializeLPList)(this.postConditions));
        bytesArray.push((0, payload_1.serializePayload)(this.payload));
        return (0, common_1.concatArray)(bytesArray);
    }
}
exports.StacksTransaction = StacksTransaction;
function deserializeTransaction(data) {
    let bytesReader;
    if (typeof data === 'string') {
        if (data.slice(0, 2).toLowerCase() === '0x') {
            bytesReader = new bytesReader_1.BytesReader((0, common_1.hexToBytes)(data.slice(2)));
        }
        else {
            bytesReader = new bytesReader_1.BytesReader((0, common_1.hexToBytes)(data));
        }
    }
    else if (data instanceof Uint8Array) {
        bytesReader = new bytesReader_1.BytesReader(data);
    }
    else {
        bytesReader = data;
    }
    const version = bytesReader.readUInt8Enum(constants_1.TransactionVersion, n => {
        throw new Error(`Could not parse ${n} as TransactionVersion`);
    });
    const chainId = bytesReader.readUInt32BE();
    const auth = (0, authorization_1.deserializeAuthorization)(bytesReader);
    const anchorMode = bytesReader.readUInt8Enum(constants_1.AnchorMode, n => {
        throw new Error(`Could not parse ${n} as AnchorMode`);
    });
    const postConditionMode = bytesReader.readUInt8Enum(constants_1.PostConditionMode, n => {
        throw new Error(`Could not parse ${n} as PostConditionMode`);
    });
    const postConditions = (0, types_1.deserializeLPList)(bytesReader, constants_1.StacksMessageType.PostCondition);
    const payload = (0, payload_1.deserializePayload)(bytesReader);
    return new StacksTransaction(version, auth, payload, postConditions, postConditionMode, anchorMode, chainId);
}
exports.deserializeTransaction = deserializeTransaction;

},{"./authorization":72,"./bytesReader":74,"./constants":90,"./errors":92,"./keys":94,"./payload":95,"./signature":98,"./types":102,"./utils":103,"@stacks/common":36}],102:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deserializePostCondition = exports.serializePostCondition = exports.deserializeLPList = exports.serializeLPList = exports.createLPList = exports.deserializeAssetInfo = exports.serializeAssetInfo = exports.deserializeMemoString = exports.serializeMemoString = exports.createMemoString = exports.codeBodyString = exports.deserializeLPString = exports.serializeLPString = exports.deserializePrincipal = exports.serializePrincipal = exports.deserializeAddress = exports.serializeAddress = exports.addressFromPublicKeys = exports.addressFromHashMode = exports.createEmptyAddress = exports.deserializeStacksMessage = exports.serializeStacksMessage = void 0;
const common_1 = require("@stacks/common");
const constants_1 = require("./constants");
const keys_1 = require("./keys");
const utils_1 = require("./utils");
const postcondition_types_1 = require("./postcondition-types");
const payload_1 = require("./payload");
const errors_1 = require("./errors");
const signature_1 = require("./signature");
const common_2 = require("./common");
const clarity_1 = require("./clarity");
function serializeStacksMessage(message) {
    switch (message.type) {
        case constants_1.StacksMessageType.Address:
            return serializeAddress(message);
        case constants_1.StacksMessageType.Principal:
            return serializePrincipal(message);
        case constants_1.StacksMessageType.LengthPrefixedString:
            return serializeLPString(message);
        case constants_1.StacksMessageType.MemoString:
            return serializeMemoString(message);
        case constants_1.StacksMessageType.AssetInfo:
            return serializeAssetInfo(message);
        case constants_1.StacksMessageType.PostCondition:
            return serializePostCondition(message);
        case constants_1.StacksMessageType.PublicKey:
            return (0, keys_1.serializePublicKey)(message);
        case constants_1.StacksMessageType.LengthPrefixedList:
            return serializeLPList(message);
        case constants_1.StacksMessageType.Payload:
            return (0, payload_1.serializePayload)(message);
        case constants_1.StacksMessageType.TransactionAuthField:
            return (0, signature_1.serializeTransactionAuthField)(message);
        case constants_1.StacksMessageType.MessageSignature:
            return (0, signature_1.serializeMessageSignature)(message);
    }
}
exports.serializeStacksMessage = serializeStacksMessage;
function deserializeStacksMessage(bytesReader, type, listType) {
    switch (type) {
        case constants_1.StacksMessageType.Address:
            return deserializeAddress(bytesReader);
        case constants_1.StacksMessageType.Principal:
            return deserializePrincipal(bytesReader);
        case constants_1.StacksMessageType.LengthPrefixedString:
            return deserializeLPString(bytesReader);
        case constants_1.StacksMessageType.MemoString:
            return deserializeMemoString(bytesReader);
        case constants_1.StacksMessageType.AssetInfo:
            return deserializeAssetInfo(bytesReader);
        case constants_1.StacksMessageType.PostCondition:
            return deserializePostCondition(bytesReader);
        case constants_1.StacksMessageType.PublicKey:
            return (0, keys_1.deserializePublicKey)(bytesReader);
        case constants_1.StacksMessageType.Payload:
            return (0, payload_1.deserializePayload)(bytesReader);
        case constants_1.StacksMessageType.LengthPrefixedList:
            if (!listType) {
                throw new errors_1.DeserializationError('No List Type specified');
            }
            return deserializeLPList(bytesReader, listType);
        case constants_1.StacksMessageType.MessageSignature:
            return (0, signature_1.deserializeMessageSignature)(bytesReader);
        default:
            throw new Error('Could not recognize StacksMessageType');
    }
}
exports.deserializeStacksMessage = deserializeStacksMessage;
function createEmptyAddress() {
    return {
        type: constants_1.StacksMessageType.Address,
        version: constants_1.AddressVersion.MainnetSingleSig,
        hash160: '0'.repeat(40),
    };
}
exports.createEmptyAddress = createEmptyAddress;
function addressFromHashMode(hashMode, txVersion, data) {
    const version = (0, common_2.addressHashModeToVersion)(hashMode, txVersion);
    return (0, common_2.addressFromVersionHash)(version, data);
}
exports.addressFromHashMode = addressFromHashMode;
function addressFromPublicKeys(version, hashMode, numSigs, publicKeys) {
    if (publicKeys.length === 0) {
        throw Error('Invalid number of public keys');
    }
    if (hashMode === constants_1.AddressHashMode.SerializeP2PKH || hashMode === constants_1.AddressHashMode.SerializeP2WPKH) {
        if (publicKeys.length !== 1 || numSigs !== 1) {
            throw Error('Invalid number of public keys or signatures');
        }
    }
    if (hashMode === constants_1.AddressHashMode.SerializeP2WPKH || hashMode === constants_1.AddressHashMode.SerializeP2WSH) {
        for (let i = 0; i < publicKeys.length; i++) {
            if (!(0, keys_1.isCompressed)(publicKeys[i])) {
                throw Error('Public keys must be compressed for segwit');
            }
        }
    }
    switch (hashMode) {
        case constants_1.AddressHashMode.SerializeP2PKH:
            return (0, common_2.addressFromVersionHash)(version, (0, utils_1.hashP2PKH)(publicKeys[0].data));
        case constants_1.AddressHashMode.SerializeP2WPKH:
            return (0, common_2.addressFromVersionHash)(version, (0, utils_1.hashP2WPKH)(publicKeys[0].data));
        case constants_1.AddressHashMode.SerializeP2SH:
            return (0, common_2.addressFromVersionHash)(version, (0, utils_1.hashP2SH)(numSigs, publicKeys.map(keys_1.serializePublicKey)));
        case constants_1.AddressHashMode.SerializeP2WSH:
            return (0, common_2.addressFromVersionHash)(version, (0, utils_1.hashP2WSH)(numSigs, publicKeys.map(keys_1.serializePublicKey)));
    }
}
exports.addressFromPublicKeys = addressFromPublicKeys;
function serializeAddress(address) {
    const bytesArray = [];
    bytesArray.push((0, common_1.hexToBytes)((0, common_1.intToHex)(address.version, 1)));
    bytesArray.push((0, common_1.hexToBytes)(address.hash160));
    return (0, common_1.concatArray)(bytesArray);
}
exports.serializeAddress = serializeAddress;
function deserializeAddress(bytesReader) {
    const version = (0, common_1.hexToInt)((0, common_1.bytesToHex)(bytesReader.readBytes(1)));
    const data = (0, common_1.bytesToHex)(bytesReader.readBytes(20));
    return { type: constants_1.StacksMessageType.Address, version, hash160: data };
}
exports.deserializeAddress = deserializeAddress;
function serializePrincipal(principal) {
    const bytesArray = [];
    bytesArray.push(principal.prefix);
    bytesArray.push(serializeAddress(principal.address));
    if (principal.prefix === constants_1.PostConditionPrincipalID.Contract) {
        bytesArray.push(serializeLPString(principal.contractName));
    }
    return (0, common_1.concatArray)(bytesArray);
}
exports.serializePrincipal = serializePrincipal;
function deserializePrincipal(bytesReader) {
    const prefix = bytesReader.readUInt8Enum(constants_1.PostConditionPrincipalID, n => {
        throw new errors_1.DeserializationError(`Unexpected Principal payload type: ${n}`);
    });
    const address = deserializeAddress(bytesReader);
    if (prefix === constants_1.PostConditionPrincipalID.Standard) {
        return { type: constants_1.StacksMessageType.Principal, prefix, address };
    }
    const contractName = deserializeLPString(bytesReader);
    return {
        type: constants_1.StacksMessageType.Principal,
        prefix,
        address,
        contractName,
    };
}
exports.deserializePrincipal = deserializePrincipal;
function serializeLPString(lps) {
    const bytesArray = [];
    const contentBytes = (0, common_1.utf8ToBytes)(lps.content);
    const length = contentBytes.byteLength;
    bytesArray.push((0, common_1.hexToBytes)((0, common_1.intToHex)(length, lps.lengthPrefixBytes)));
    bytesArray.push(contentBytes);
    return (0, common_1.concatArray)(bytesArray);
}
exports.serializeLPString = serializeLPString;
function deserializeLPString(bytesReader, prefixBytes, maxLength) {
    prefixBytes = prefixBytes ? prefixBytes : 1;
    const length = (0, common_1.hexToInt)((0, common_1.bytesToHex)(bytesReader.readBytes(prefixBytes)));
    const content = (0, common_1.bytesToUtf8)(bytesReader.readBytes(length));
    return (0, postcondition_types_1.createLPString)(content, prefixBytes, maxLength ?? 128);
}
exports.deserializeLPString = deserializeLPString;
function codeBodyString(content) {
    return (0, postcondition_types_1.createLPString)(content, 4, 100000);
}
exports.codeBodyString = codeBodyString;
function createMemoString(content) {
    if (content && (0, utils_1.exceedsMaxLengthBytes)(content, constants_1.MEMO_MAX_LENGTH_BYTES)) {
        throw new Error(`Memo exceeds maximum length of ${constants_1.MEMO_MAX_LENGTH_BYTES} bytes`);
    }
    return { type: constants_1.StacksMessageType.MemoString, content };
}
exports.createMemoString = createMemoString;
function serializeMemoString(memoString) {
    const bytesArray = [];
    const contentBytes = (0, common_1.utf8ToBytes)(memoString.content);
    const paddedContent = (0, utils_1.rightPadHexToLength)((0, common_1.bytesToHex)(contentBytes), constants_1.MEMO_MAX_LENGTH_BYTES * 2);
    bytesArray.push((0, common_1.hexToBytes)(paddedContent));
    return (0, common_1.concatArray)(bytesArray);
}
exports.serializeMemoString = serializeMemoString;
function deserializeMemoString(bytesReader) {
    const content = (0, common_1.bytesToUtf8)(bytesReader.readBytes(constants_1.MEMO_MAX_LENGTH_BYTES));
    return { type: constants_1.StacksMessageType.MemoString, content };
}
exports.deserializeMemoString = deserializeMemoString;
function serializeAssetInfo(info) {
    const bytesArray = [];
    bytesArray.push(serializeAddress(info.address));
    bytesArray.push(serializeLPString(info.contractName));
    bytesArray.push(serializeLPString(info.assetName));
    return (0, common_1.concatArray)(bytesArray);
}
exports.serializeAssetInfo = serializeAssetInfo;
function deserializeAssetInfo(bytesReader) {
    return {
        type: constants_1.StacksMessageType.AssetInfo,
        address: deserializeAddress(bytesReader),
        contractName: deserializeLPString(bytesReader),
        assetName: deserializeLPString(bytesReader),
    };
}
exports.deserializeAssetInfo = deserializeAssetInfo;
function createLPList(values, lengthPrefixBytes) {
    return {
        type: constants_1.StacksMessageType.LengthPrefixedList,
        lengthPrefixBytes: lengthPrefixBytes || 4,
        values,
    };
}
exports.createLPList = createLPList;
function serializeLPList(lpList) {
    const list = lpList.values;
    const bytesArray = [];
    bytesArray.push((0, common_1.hexToBytes)((0, common_1.intToHex)(list.length, lpList.lengthPrefixBytes)));
    for (const l of list) {
        bytesArray.push(serializeStacksMessage(l));
    }
    return (0, common_1.concatArray)(bytesArray);
}
exports.serializeLPList = serializeLPList;
function deserializeLPList(bytesReader, type, lengthPrefixBytes) {
    const length = (0, common_1.hexToInt)((0, common_1.bytesToHex)(bytesReader.readBytes(lengthPrefixBytes || 4)));
    const l = [];
    for (let index = 0; index < length; index++) {
        switch (type) {
            case constants_1.StacksMessageType.Address:
                l.push(deserializeAddress(bytesReader));
                break;
            case constants_1.StacksMessageType.LengthPrefixedString:
                l.push(deserializeLPString(bytesReader));
                break;
            case constants_1.StacksMessageType.MemoString:
                l.push(deserializeMemoString(bytesReader));
                break;
            case constants_1.StacksMessageType.AssetInfo:
                l.push(deserializeAssetInfo(bytesReader));
                break;
            case constants_1.StacksMessageType.PostCondition:
                l.push(deserializePostCondition(bytesReader));
                break;
            case constants_1.StacksMessageType.PublicKey:
                l.push((0, keys_1.deserializePublicKey)(bytesReader));
                break;
            case constants_1.StacksMessageType.TransactionAuthField:
                l.push((0, signature_1.deserializeTransactionAuthField)(bytesReader));
                break;
        }
    }
    return createLPList(l, lengthPrefixBytes);
}
exports.deserializeLPList = deserializeLPList;
function serializePostCondition(postCondition) {
    const bytesArray = [];
    bytesArray.push(postCondition.conditionType);
    bytesArray.push(serializePrincipal(postCondition.principal));
    if (postCondition.conditionType === constants_1.PostConditionType.Fungible ||
        postCondition.conditionType === constants_1.PostConditionType.NonFungible) {
        bytesArray.push(serializeAssetInfo(postCondition.assetInfo));
    }
    if (postCondition.conditionType === constants_1.PostConditionType.NonFungible) {
        bytesArray.push((0, clarity_1.serializeCV)(postCondition.assetName));
    }
    bytesArray.push(postCondition.conditionCode);
    if (postCondition.conditionType === constants_1.PostConditionType.STX ||
        postCondition.conditionType === constants_1.PostConditionType.Fungible) {
        bytesArray.push((0, common_1.intToBytes)(postCondition.amount, false, 8));
    }
    return (0, common_1.concatArray)(bytesArray);
}
exports.serializePostCondition = serializePostCondition;
function deserializePostCondition(bytesReader) {
    const postConditionType = bytesReader.readUInt8Enum(constants_1.PostConditionType, n => {
        throw new errors_1.DeserializationError(`Could not read ${n} as PostConditionType`);
    });
    const principal = deserializePrincipal(bytesReader);
    let conditionCode;
    let assetInfo;
    let amount;
    switch (postConditionType) {
        case constants_1.PostConditionType.STX:
            conditionCode = bytesReader.readUInt8Enum(constants_1.FungibleConditionCode, n => {
                throw new errors_1.DeserializationError(`Could not read ${n} as FungibleConditionCode`);
            });
            amount = BigInt(`0x${(0, common_1.bytesToHex)(bytesReader.readBytes(8))}`);
            return {
                type: constants_1.StacksMessageType.PostCondition,
                conditionType: constants_1.PostConditionType.STX,
                principal,
                conditionCode,
                amount,
            };
        case constants_1.PostConditionType.Fungible:
            assetInfo = deserializeAssetInfo(bytesReader);
            conditionCode = bytesReader.readUInt8Enum(constants_1.FungibleConditionCode, n => {
                throw new errors_1.DeserializationError(`Could not read ${n} as FungibleConditionCode`);
            });
            amount = BigInt(`0x${(0, common_1.bytesToHex)(bytesReader.readBytes(8))}`);
            return {
                type: constants_1.StacksMessageType.PostCondition,
                conditionType: constants_1.PostConditionType.Fungible,
                principal,
                conditionCode,
                amount,
                assetInfo,
            };
        case constants_1.PostConditionType.NonFungible:
            assetInfo = deserializeAssetInfo(bytesReader);
            const assetName = (0, clarity_1.deserializeCV)(bytesReader);
            conditionCode = bytesReader.readUInt8Enum(constants_1.NonFungibleConditionCode, n => {
                throw new errors_1.DeserializationError(`Could not read ${n} as FungibleConditionCode`);
            });
            return {
                type: constants_1.StacksMessageType.PostCondition,
                conditionType: constants_1.PostConditionType.NonFungible,
                principal,
                conditionCode,
                assetInfo,
                assetName,
            };
    }
}
exports.deserializePostCondition = deserializePostCondition;

},{"./clarity":78,"./common":89,"./constants":90,"./errors":92,"./keys":94,"./payload":95,"./postcondition-types":96,"./signature":98,"./utils":103,"@stacks/common":36}],103:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateTxId = exports.validateStacksAddress = exports.parseReadOnlyResponse = exports.hexToCV = exports.cvToHex = exports.isClarityName = exports.hashP2WSH = exports.hashP2SH = exports.hashP2WPKH = exports.hashP2PKH = exports.hash160 = exports.txidFromData = exports.omit = exports.cloneDeep = exports.exceedsMaxLengthBytes = exports.rightPadHexToLength = exports.leftPadHexToLength = exports.leftPadHex = exports.randomBytes = exports.verifySignature = void 0;
const ripemd160_1 = require("@noble/hashes/ripemd160");
const sha256_1 = require("@noble/hashes/sha256");
const sha512_1 = require("@noble/hashes/sha512");
const secp256k1_1 = require("@noble/secp256k1");
const common_1 = require("@stacks/common");
const c32check_1 = require("c32check");
const lodash_clonedeep_1 = __importDefault(require("lodash.clonedeep"));
const clarity_1 = require("./clarity");
var secp256k1_2 = require("@noble/secp256k1");
Object.defineProperty(exports, "verifySignature", { enumerable: true, get: function () { return secp256k1_2.verify; } });
const randomBytes = (bytesLength) => secp256k1_1.utils.randomBytes(bytesLength);
exports.randomBytes = randomBytes;
const leftPadHex = (hexString) => hexString.length % 2 == 0 ? hexString : `0${hexString}`;
exports.leftPadHex = leftPadHex;
const leftPadHexToLength = (hexString, length) => hexString.padStart(length, '0');
exports.leftPadHexToLength = leftPadHexToLength;
const rightPadHexToLength = (hexString, length) => hexString.padEnd(length, '0');
exports.rightPadHexToLength = rightPadHexToLength;
const exceedsMaxLengthBytes = (string, maxLengthBytes) => string ? (0, common_1.utf8ToBytes)(string).length > maxLengthBytes : false;
exports.exceedsMaxLengthBytes = exceedsMaxLengthBytes;
function cloneDeep(obj) {
    return (0, lodash_clonedeep_1.default)(obj);
}
exports.cloneDeep = cloneDeep;
function omit(obj, prop) {
    const clone = cloneDeep(obj);
    delete clone[prop];
    return clone;
}
exports.omit = omit;
const txidFromData = (data) => {
    return (0, common_1.bytesToHex)((0, sha512_1.sha512_256)(data));
};
exports.txidFromData = txidFromData;
const hash160 = (input) => {
    return (0, ripemd160_1.ripemd160)((0, sha256_1.sha256)(input));
};
exports.hash160 = hash160;
const hashP2PKH = (input) => {
    return (0, common_1.bytesToHex)((0, exports.hash160)(input));
};
exports.hashP2PKH = hashP2PKH;
const hashP2WPKH = (input) => {
    const keyHash = (0, exports.hash160)(input);
    const redeemScript = (0, common_1.concatBytes)(new Uint8Array([0]), new Uint8Array([keyHash.length]), keyHash);
    const redeemScriptHash = (0, exports.hash160)(redeemScript);
    return (0, common_1.bytesToHex)(redeemScriptHash);
};
exports.hashP2WPKH = hashP2WPKH;
const hashP2SH = (numSigs, pubKeys) => {
    if (numSigs > 15 || pubKeys.length > 15) {
        throw Error('P2SH multisig address can only contain up to 15 public keys');
    }
    const bytesArray = [];
    bytesArray.push(80 + numSigs);
    pubKeys.forEach(pubKey => {
        bytesArray.push(pubKey.length);
        bytesArray.push(pubKey);
    });
    bytesArray.push(80 + pubKeys.length);
    bytesArray.push(174);
    const redeemScript = (0, common_1.concatArray)(bytesArray);
    const redeemScriptHash = (0, exports.hash160)(redeemScript);
    return (0, common_1.bytesToHex)(redeemScriptHash);
};
exports.hashP2SH = hashP2SH;
const hashP2WSH = (numSigs, pubKeys) => {
    if (numSigs > 15 || pubKeys.length > 15) {
        throw Error('P2WSH multisig address can only contain up to 15 public keys');
    }
    const scriptArray = [];
    scriptArray.push(80 + numSigs);
    pubKeys.forEach(pubKey => {
        scriptArray.push(pubKey.length);
        scriptArray.push(pubKey);
    });
    scriptArray.push(80 + pubKeys.length);
    scriptArray.push(174);
    const script = (0, common_1.concatArray)(scriptArray);
    const digest = (0, sha256_1.sha256)(script);
    const bytesArray = [];
    bytesArray.push(0);
    bytesArray.push(digest.length);
    bytesArray.push(digest);
    const redeemScript = (0, common_1.concatArray)(bytesArray);
    const redeemScriptHash = (0, exports.hash160)(redeemScript);
    return (0, common_1.bytesToHex)(redeemScriptHash);
};
exports.hashP2WSH = hashP2WSH;
function isClarityName(name) {
    const regex = /^[a-zA-Z]([a-zA-Z0-9]|[-_!?+<>=/*])*$|^[-+=/*]$|^[<>]=?$/;
    return regex.test(name) && name.length < 128;
}
exports.isClarityName = isClarityName;
function cvToHex(cv) {
    const serialized = (0, clarity_1.serializeCV)(cv);
    return `0x${(0, common_1.bytesToHex)(serialized)}`;
}
exports.cvToHex = cvToHex;
function hexToCV(hex) {
    return (0, clarity_1.deserializeCV)(hex);
}
exports.hexToCV = hexToCV;
const parseReadOnlyResponse = (response) => {
    if (response.okay)
        return hexToCV(response.result);
    throw new Error(response.cause);
};
exports.parseReadOnlyResponse = parseReadOnlyResponse;
const validateStacksAddress = (stacksAddress) => {
    try {
        (0, c32check_1.c32addressDecode)(stacksAddress);
        return true;
    }
    catch (e) {
        return false;
    }
};
exports.validateStacksAddress = validateStacksAddress;
const validateTxId = (txid) => {
    if (txid === 'success')
        return true;
    const value = (0, common_1.with0x)(txid).toLowerCase();
    if (value.length !== 66)
        return false;
    return (0, common_1.with0x)(BigInt(value).toString(16).padStart(64, '0')) === value;
};
exports.validateTxId = validateTxId;

},{"./clarity":78,"@noble/hashes/ripemd160":11,"@noble/hashes/sha256":12,"@noble/hashes/sha512":13,"@noble/secp256k1":15,"@stacks/common":36,"c32check":112,"lodash.clonedeep":124}],104:[function(require,module,exports){
(function (process,global,setImmediate){(function (){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.async = global.async || {})));
}(this, (function (exports) { 'use strict';

function slice(arrayLike, start) {
    start = start|0;
    var newLen = Math.max(arrayLike.length - start, 0);
    var newArr = Array(newLen);
    for(var idx = 0; idx < newLen; idx++)  {
        newArr[idx] = arrayLike[start + idx];
    }
    return newArr;
}

/**
 * Creates a continuation function with some arguments already applied.
 *
 * Useful as a shorthand when combined with other control flow functions. Any
 * arguments passed to the returned function are added to the arguments
 * originally passed to apply.
 *
 * @name apply
 * @static
 * @memberOf module:Utils
 * @method
 * @category Util
 * @param {Function} fn - The function you want to eventually apply all
 * arguments to. Invokes with (arguments...).
 * @param {...*} arguments... - Any number of arguments to automatically apply
 * when the continuation is called.
 * @returns {Function} the partially-applied function
 * @example
 *
 * // using apply
 * async.parallel([
 *     async.apply(fs.writeFile, 'testfile1', 'test1'),
 *     async.apply(fs.writeFile, 'testfile2', 'test2')
 * ]);
 *
 *
 * // the same process without using apply
 * async.parallel([
 *     function(callback) {
 *         fs.writeFile('testfile1', 'test1', callback);
 *     },
 *     function(callback) {
 *         fs.writeFile('testfile2', 'test2', callback);
 *     }
 * ]);
 *
 * // It's possible to pass any number of additional arguments when calling the
 * // continuation:
 *
 * node> var fn = async.apply(sys.puts, 'one');
 * node> fn('two', 'three');
 * one
 * two
 * three
 */
var apply = function(fn/*, ...args*/) {
    var args = slice(arguments, 1);
    return function(/*callArgs*/) {
        var callArgs = slice(arguments);
        return fn.apply(null, args.concat(callArgs));
    };
};

var initialParams = function (fn) {
    return function (/*...args, callback*/) {
        var args = slice(arguments);
        var callback = args.pop();
        fn.call(this, args, callback);
    };
};

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

var hasSetImmediate = typeof setImmediate === 'function' && setImmediate;
var hasNextTick = typeof process === 'object' && typeof process.nextTick === 'function';

function fallback(fn) {
    setTimeout(fn, 0);
}

function wrap(defer) {
    return function (fn/*, ...args*/) {
        var args = slice(arguments, 1);
        defer(function () {
            fn.apply(null, args);
        });
    };
}

var _defer;

if (hasSetImmediate) {
    _defer = setImmediate;
} else if (hasNextTick) {
    _defer = process.nextTick;
} else {
    _defer = fallback;
}

var setImmediate$1 = wrap(_defer);

/**
 * Take a sync function and make it async, passing its return value to a
 * callback. This is useful for plugging sync functions into a waterfall,
 * series, or other async functions. Any arguments passed to the generated
 * function will be passed to the wrapped function (except for the final
 * callback argument). Errors thrown will be passed to the callback.
 *
 * If the function passed to `asyncify` returns a Promise, that promises's
 * resolved/rejected state will be used to call the callback, rather than simply
 * the synchronous return value.
 *
 * This also means you can asyncify ES2017 `async` functions.
 *
 * @name asyncify
 * @static
 * @memberOf module:Utils
 * @method
 * @alias wrapSync
 * @category Util
 * @param {Function} func - The synchronous function, or Promise-returning
 * function to convert to an {@link AsyncFunction}.
 * @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be
 * invoked with `(args..., callback)`.
 * @example
 *
 * // passing a regular synchronous function
 * async.waterfall([
 *     async.apply(fs.readFile, filename, "utf8"),
 *     async.asyncify(JSON.parse),
 *     function (data, next) {
 *         // data is the result of parsing the text.
 *         // If there was a parsing error, it would have been caught.
 *     }
 * ], callback);
 *
 * // passing a function returning a promise
 * async.waterfall([
 *     async.apply(fs.readFile, filename, "utf8"),
 *     async.asyncify(function (contents) {
 *         return db.model.create(contents);
 *     }),
 *     function (model, next) {
 *         // `model` is the instantiated model object.
 *         // If there was an error, this function would be skipped.
 *     }
 * ], callback);
 *
 * // es2017 example, though `asyncify` is not needed if your JS environment
 * // supports async functions out of the box
 * var q = async.queue(async.asyncify(async function(file) {
 *     var intermediateStep = await processFile(file);
 *     return await somePromise(intermediateStep)
 * }));
 *
 * q.push(files);
 */
function asyncify(func) {
    return initialParams(function (args, callback) {
        var result;
        try {
            result = func.apply(this, args);
        } catch (e) {
            return callback(e);
        }
        // if result is Promise object
        if (isObject(result) && typeof result.then === 'function') {
            result.then(function(value) {
                invokeCallback(callback, null, value);
            }, function(err) {
                invokeCallback(callback, err.message ? err : new Error(err));
            });
        } else {
            callback(null, result);
        }
    });
}

function invokeCallback(callback, error, value) {
    try {
        callback(error, value);
    } catch (e) {
        setImmediate$1(rethrow, e);
    }
}

function rethrow(error) {
    throw error;
}

var supportsSymbol = typeof Symbol === 'function';

function isAsync(fn) {
    return supportsSymbol && fn[Symbol.toStringTag] === 'AsyncFunction';
}

function wrapAsync(asyncFn) {
    return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;
}

function applyEach$1(eachfn) {
    return function(fns/*, ...args*/) {
        var args = slice(arguments, 1);
        var go = initialParams(function(args, callback) {
            var that = this;
            return eachfn(fns, function (fn, cb) {
                wrapAsync(fn).apply(that, args.concat(cb));
            }, callback);
        });
        if (args.length) {
            return go.apply(this, args);
        }
        else {
            return go;
        }
    };
}

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Built-in value references. */
var Symbol$1 = root.Symbol;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag$1),
      tag = value[symToStringTag$1];

  try {
    value[symToStringTag$1] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}

/** Used for built-in method references. */
var objectProto$1 = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString$1 = objectProto$1.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString$1.call(value);
}

/** `Object#toString` result references. */
var nullTag = '[object Null]';
var undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]';
var funcTag = '[object Function]';
var genTag = '[object GeneratorFunction]';
var proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

// A temporary value used to identify if the loop should be broken.
// See #1064, #1293
var breakLoop = {};

/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {
  // No operation performed.
}

function once(fn) {
    return function () {
        if (fn === null) return;
        var callFn = fn;
        fn = null;
        callFn.apply(this, arguments);
    };
}

var iteratorSymbol = typeof Symbol === 'function' && Symbol.iterator;

var getIterator = function (coll) {
    return iteratorSymbol && coll[iteratorSymbol] && coll[iteratorSymbol]();
};

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

/** Used for built-in method references. */
var objectProto$3 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$2 = objectProto$3.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty$2.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER$1 = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$1 : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

/** `Object#toString` result references. */
var argsTag$1 = '[object Arguments]';
var arrayTag = '[object Array]';
var boolTag = '[object Boolean]';
var dateTag = '[object Date]';
var errorTag = '[object Error]';
var funcTag$1 = '[object Function]';
var mapTag = '[object Map]';
var numberTag = '[object Number]';
var objectTag = '[object Object]';
var regexpTag = '[object RegExp]';
var setTag = '[object Set]';
var stringTag = '[object String]';
var weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]';
var dataViewTag = '[object DataView]';
var float32Tag = '[object Float32Array]';
var float64Tag = '[object Float64Array]';
var int8Tag = '[object Int8Array]';
var int16Tag = '[object Int16Array]';
var int32Tag = '[object Int32Array]';
var uint8Tag = '[object Uint8Array]';
var uint8ClampedTag = '[object Uint8ClampedArray]';
var uint16Tag = '[object Uint16Array]';
var uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag$1] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/** Detect free variable `exports`. */
var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports$1 && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule$1 && freeModule$1.require && freeModule$1.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/** Used for built-in method references. */
var objectProto$2 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$1 = objectProto$2.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty$1.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

/** Used for built-in method references. */
var objectProto$5 = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$5;

  return value === proto;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

/** Used for built-in method references. */
var objectProto$4 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$3 = objectProto$4.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$3.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

function createArrayIterator(coll) {
    var i = -1;
    var len = coll.length;
    return function next() {
        return ++i < len ? {value: coll[i], key: i} : null;
    }
}

function createES2015Iterator(iterator) {
    var i = -1;
    return function next() {
        var item = iterator.next();
        if (item.done)
            return null;
        i++;
        return {value: item.value, key: i};
    }
}

function createObjectIterator(obj) {
    var okeys = keys(obj);
    var i = -1;
    var len = okeys.length;
    return function next() {
        var key = okeys[++i];
        if (key === '__proto__') {
            return next();
        }
        return i < len ? {value: obj[key], key: key} : null;
    };
}

function iterator(coll) {
    if (isArrayLike(coll)) {
        return createArrayIterator(coll);
    }

    var iterator = getIterator(coll);
    return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
}

function onlyOnce(fn) {
    return function() {
        if (fn === null) throw new Error("Callback was already called.");
        var callFn = fn;
        fn = null;
        callFn.apply(this, arguments);
    };
}

function _eachOfLimit(limit) {
    return function (obj, iteratee, callback) {
        callback = once(callback || noop);
        if (limit <= 0 || !obj) {
            return callback(null);
        }
        var nextElem = iterator(obj);
        var done = false;
        var running = 0;
        var looping = false;

        function iterateeCallback(err, value) {
            running -= 1;
            if (err) {
                done = true;
                callback(err);
            }
            else if (value === breakLoop || (done && running <= 0)) {
                done = true;
                return callback(null);
            }
            else if (!looping) {
                replenish();
            }
        }

        function replenish () {
            looping = true;
            while (running < limit && !done) {
                var elem = nextElem();
                if (elem === null) {
                    done = true;
                    if (running <= 0) {
                        callback(null);
                    }
                    return;
                }
                running += 1;
                iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));
            }
            looping = false;
        }

        replenish();
    };
}

/**
 * The same as [`eachOf`]{@link module:Collections.eachOf} but runs a maximum of `limit` async operations at a
 * time.
 *
 * @name eachOfLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.eachOf]{@link module:Collections.eachOf}
 * @alias forEachOfLimit
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - An async function to apply to each
 * item in `coll`. The `key` is the item's key, or index in the case of an
 * array.
 * Invoked with (item, key, callback).
 * @param {Function} [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 */
function eachOfLimit(coll, limit, iteratee, callback) {
    _eachOfLimit(limit)(coll, wrapAsync(iteratee), callback);
}

function doLimit(fn, limit) {
    return function (iterable, iteratee, callback) {
        return fn(iterable, limit, iteratee, callback);
    };
}

// eachOf implementation optimized for array-likes
function eachOfArrayLike(coll, iteratee, callback) {
    callback = once(callback || noop);
    var index = 0,
        completed = 0,
        length = coll.length;
    if (length === 0) {
        callback(null);
    }

    function iteratorCallback(err, value) {
        if (err) {
            callback(err);
        } else if ((++completed === length) || value === breakLoop) {
            callback(null);
        }
    }

    for (; index < length; index++) {
        iteratee(coll[index], index, onlyOnce(iteratorCallback));
    }
}

// a generic version of eachOf which can handle array, object, and iterator cases.
var eachOfGeneric = doLimit(eachOfLimit, Infinity);

/**
 * Like [`each`]{@link module:Collections.each}, except that it passes the key (or index) as the second argument
 * to the iteratee.
 *
 * @name eachOf
 * @static
 * @memberOf module:Collections
 * @method
 * @alias forEachOf
 * @category Collection
 * @see [async.each]{@link module:Collections.each}
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - A function to apply to each
 * item in `coll`.
 * The `key` is the item's key, or index in the case of an array.
 * Invoked with (item, key, callback).
 * @param {Function} [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 * @example
 *
 * var obj = {dev: "/dev.json", test: "/test.json", prod: "/prod.json"};
 * var configs = {};
 *
 * async.forEachOf(obj, function (value, key, callback) {
 *     fs.readFile(__dirname + value, "utf8", function (err, data) {
 *         if (err) return callback(err);
 *         try {
 *             configs[key] = JSON.parse(data);
 *         } catch (e) {
 *             return callback(e);
 *         }
 *         callback();
 *     });
 * }, function (err) {
 *     if (err) console.error(err.message);
 *     // configs is now a map of JSON data
 *     doSomethingWith(configs);
 * });
 */
var eachOf = function(coll, iteratee, callback) {
    var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;
    eachOfImplementation(coll, wrapAsync(iteratee), callback);
};

function doParallel(fn) {
    return function (obj, iteratee, callback) {
        return fn(eachOf, obj, wrapAsync(iteratee), callback);
    };
}

function _asyncMap(eachfn, arr, iteratee, callback) {
    callback = callback || noop;
    arr = arr || [];
    var results = [];
    var counter = 0;
    var _iteratee = wrapAsync(iteratee);

    eachfn(arr, function (value, _, callback) {
        var index = counter++;
        _iteratee(value, function (err, v) {
            results[index] = v;
            callback(err);
        });
    }, function (err) {
        callback(err, results);
    });
}

/**
 * Produces a new collection of values by mapping each value in `coll` through
 * the `iteratee` function. The `iteratee` is called with an item from `coll`
 * and a callback for when it has finished processing. Each of these callback
 * takes 2 arguments: an `error`, and the transformed item from `coll`. If
 * `iteratee` passes an error to its callback, the main `callback` (for the
 * `map` function) is immediately called with the error.
 *
 * Note, that since this function applies the `iteratee` to each item in
 * parallel, there is no guarantee that the `iteratee` functions will complete
 * in order. However, the results array will be in the same order as the
 * original `coll`.
 *
 * If `map` is passed an Object, the results will be an Array.  The results
 * will roughly be in the order of the original Objects' keys (but this can
 * vary across JavaScript engines).
 *
 * @name map
 * @static
 * @memberOf module:Collections
 * @method
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * The iteratee should complete with the transformed item.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. Results is an Array of the
 * transformed items from the `coll`. Invoked with (err, results).
 * @example
 *
 * async.map(['file1','file2','file3'], fs.stat, function(err, results) {
 *     // results is now an array of stats for each file
 * });
 */
var map = doParallel(_asyncMap);

/**
 * Applies the provided arguments to each function in the array, calling
 * `callback` after all functions have completed. If you only provide the first
 * argument, `fns`, then it will return a function which lets you pass in the
 * arguments as if it were a single function call. If more arguments are
 * provided, `callback` is required while `args` is still optional.
 *
 * @name applyEach
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Array|Iterable|Object} fns - A collection of {@link AsyncFunction}s
 * to all call with the same arguments
 * @param {...*} [args] - any number of separate arguments to pass to the
 * function.
 * @param {Function} [callback] - the final argument should be the callback,
 * called when all functions have completed processing.
 * @returns {Function} - If only the first argument, `fns`, is provided, it will
 * return a function which lets you pass in the arguments as if it were a single
 * function call. The signature is `(..args, callback)`. If invoked with any
 * arguments, `callback` is required.
 * @example
 *
 * async.applyEach([enableSearch, updateSchema], 'bucket', callback);
 *
 * // partial application example:
 * async.each(
 *     buckets,
 *     async.applyEach([enableSearch, updateSchema]),
 *     callback
 * );
 */
var applyEach = applyEach$1(map);

function doParallelLimit(fn) {
    return function (obj, limit, iteratee, callback) {
        return fn(_eachOfLimit(limit), obj, wrapAsync(iteratee), callback);
    };
}

/**
 * The same as [`map`]{@link module:Collections.map} but runs a maximum of `limit` async operations at a time.
 *
 * @name mapLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.map]{@link module:Collections.map}
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * The iteratee should complete with the transformed item.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. Results is an array of the
 * transformed items from the `coll`. Invoked with (err, results).
 */
var mapLimit = doParallelLimit(_asyncMap);

/**
 * The same as [`map`]{@link module:Collections.map} but runs only a single async operation at a time.
 *
 * @name mapSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.map]{@link module:Collections.map}
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * The iteratee should complete with the transformed item.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. Results is an array of the
 * transformed items from the `coll`. Invoked with (err, results).
 */
var mapSeries = doLimit(mapLimit, 1);

/**
 * The same as [`applyEach`]{@link module:ControlFlow.applyEach} but runs only a single async operation at a time.
 *
 * @name applyEachSeries
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.applyEach]{@link module:ControlFlow.applyEach}
 * @category Control Flow
 * @param {Array|Iterable|Object} fns - A collection of {@link AsyncFunction}s to all
 * call with the same arguments
 * @param {...*} [args] - any number of separate arguments to pass to the
 * function.
 * @param {Function} [callback] - the final argument should be the callback,
 * called when all functions have completed processing.
 * @returns {Function} - If only the first argument is provided, it will return
 * a function which lets you pass in the arguments as if it were a single
 * function call.
 */
var applyEachSeries = applyEach$1(mapSeries);

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  return value === value
    ? strictIndexOf(array, value, fromIndex)
    : baseFindIndex(array, baseIsNaN, fromIndex);
}

/**
 * Determines the best order for running the {@link AsyncFunction}s in `tasks`, based on
 * their requirements. Each function can optionally depend on other functions
 * being completed first, and each function is run as soon as its requirements
 * are satisfied.
 *
 * If any of the {@link AsyncFunction}s pass an error to their callback, the `auto` sequence
 * will stop. Further tasks will not execute (so any other functions depending
 * on it will not run), and the main `callback` is immediately called with the
 * error.
 *
 * {@link AsyncFunction}s also receive an object containing the results of functions which
 * have completed so far as the first argument, if they have dependencies. If a
 * task function has no dependencies, it will only be passed a callback.
 *
 * @name auto
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Object} tasks - An object. Each of its properties is either a
 * function or an array of requirements, with the {@link AsyncFunction} itself the last item
 * in the array. The object's key of a property serves as the name of the task
 * defined by that property, i.e. can be used when specifying requirements for
 * other tasks. The function receives one or two arguments:
 * * a `results` object, containing the results of the previously executed
 *   functions, only passed if the task has any dependencies,
 * * a `callback(err, result)` function, which must be called when finished,
 *   passing an `error` (which can be `null`) and the result of the function's
 *   execution.
 * @param {number} [concurrency=Infinity] - An optional `integer` for
 * determining the maximum number of tasks that can be run in parallel. By
 * default, as many as possible.
 * @param {Function} [callback] - An optional callback which is called when all
 * the tasks have been completed. It receives the `err` argument if any `tasks`
 * pass an error to their callback. Results are always returned; however, if an
 * error occurs, no further `tasks` will be performed, and the results object
 * will only contain partial results. Invoked with (err, results).
 * @returns undefined
 * @example
 *
 * async.auto({
 *     // this function will just be passed a callback
 *     readData: async.apply(fs.readFile, 'data.txt', 'utf-8'),
 *     showData: ['readData', function(results, cb) {
 *         // results.readData is the file's contents
 *         // ...
 *     }]
 * }, callback);
 *
 * async.auto({
 *     get_data: function(callback) {
 *         console.log('in get_data');
 *         // async code to get some data
 *         callback(null, 'data', 'converted to array');
 *     },
 *     make_folder: function(callback) {
 *         console.log('in make_folder');
 *         // async code to create a directory to store a file in
 *         // this is run at the same time as getting the data
 *         callback(null, 'folder');
 *     },
 *     write_file: ['get_data', 'make_folder', function(results, callback) {
 *         console.log('in write_file', JSON.stringify(results));
 *         // once there is some data and the directory exists,
 *         // write the data to a file in the directory
 *         callback(null, 'filename');
 *     }],
 *     email_link: ['write_file', function(results, callback) {
 *         console.log('in email_link', JSON.stringify(results));
 *         // once the file is written let's email a link to it...
 *         // results.write_file contains the filename returned by write_file.
 *         callback(null, {'file':results.write_file, 'email':'user@example.com'});
 *     }]
 * }, function(err, results) {
 *     console.log('err = ', err);
 *     console.log('results = ', results);
 * });
 */
var auto = function (tasks, concurrency, callback) {
    if (typeof concurrency === 'function') {
        // concurrency is optional, shift the args.
        callback = concurrency;
        concurrency = null;
    }
    callback = once(callback || noop);
    var keys$$1 = keys(tasks);
    var numTasks = keys$$1.length;
    if (!numTasks) {
        return callback(null);
    }
    if (!concurrency) {
        concurrency = numTasks;
    }

    var results = {};
    var runningTasks = 0;
    var hasError = false;

    var listeners = Object.create(null);

    var readyTasks = [];

    // for cycle detection:
    var readyToCheck = []; // tasks that have been identified as reachable
    // without the possibility of returning to an ancestor task
    var uncheckedDependencies = {};

    baseForOwn(tasks, function (task, key) {
        if (!isArray(task)) {
            // no dependencies
            enqueueTask(key, [task]);
            readyToCheck.push(key);
            return;
        }

        var dependencies = task.slice(0, task.length - 1);
        var remainingDependencies = dependencies.length;
        if (remainingDependencies === 0) {
            enqueueTask(key, task);
            readyToCheck.push(key);
            return;
        }
        uncheckedDependencies[key] = remainingDependencies;

        arrayEach(dependencies, function (dependencyName) {
            if (!tasks[dependencyName]) {
                throw new Error('async.auto task `' + key +
                    '` has a non-existent dependency `' +
                    dependencyName + '` in ' +
                    dependencies.join(', '));
            }
            addListener(dependencyName, function () {
                remainingDependencies--;
                if (remainingDependencies === 0) {
                    enqueueTask(key, task);
                }
            });
        });
    });

    checkForDeadlocks();
    processQueue();

    function enqueueTask(key, task) {
        readyTasks.push(function () {
            runTask(key, task);
        });
    }

    function processQueue() {
        if (readyTasks.length === 0 && runningTasks === 0) {
            return callback(null, results);
        }
        while(readyTasks.length && runningTasks < concurrency) {
            var run = readyTasks.shift();
            run();
        }

    }

    function addListener(taskName, fn) {
        var taskListeners = listeners[taskName];
        if (!taskListeners) {
            taskListeners = listeners[taskName] = [];
        }

        taskListeners.push(fn);
    }

    function taskComplete(taskName) {
        var taskListeners = listeners[taskName] || [];
        arrayEach(taskListeners, function (fn) {
            fn();
        });
        processQueue();
    }


    function runTask(key, task) {
        if (hasError) return;

        var taskCallback = onlyOnce(function(err, result) {
            runningTasks--;
            if (arguments.length > 2) {
                result = slice(arguments, 1);
            }
            if (err) {
                var safeResults = {};
                baseForOwn(results, function(val, rkey) {
                    safeResults[rkey] = val;
                });
                safeResults[key] = result;
                hasError = true;
                listeners = Object.create(null);

                callback(err, safeResults);
            } else {
                results[key] = result;
                taskComplete(key);
            }
        });

        runningTasks++;
        var taskFn = wrapAsync(task[task.length - 1]);
        if (task.length > 1) {
            taskFn(results, taskCallback);
        } else {
            taskFn(taskCallback);
        }
    }

    function checkForDeadlocks() {
        // Kahn's algorithm
        // https://en.wikipedia.org/wiki/Topological_sorting#Kahn.27s_algorithm
        // http://connalle.blogspot.com/2013/10/topological-sortingkahn-algorithm.html
        var currentTask;
        var counter = 0;
        while (readyToCheck.length) {
            currentTask = readyToCheck.pop();
            counter++;
            arrayEach(getDependents(currentTask), function (dependent) {
                if (--uncheckedDependencies[dependent] === 0) {
                    readyToCheck.push(dependent);
                }
            });
        }

        if (counter !== numTasks) {
            throw new Error(
                'async.auto cannot execute tasks due to a recursive dependency'
            );
        }
    }

    function getDependents(taskName) {
        var result = [];
        baseForOwn(tasks, function (task, key) {
            if (isArray(task) && baseIndexOf(task, taskName, 0) >= 0) {
                result.push(key);
            }
        });
        return result;
    }
};

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined;
var symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : ((end - start) >>> 0);
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

/**
 * Casts `array` to a slice if it's needed.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {number} start The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the cast slice.
 */
function castSlice(array, start, end) {
  var length = array.length;
  end = end === undefined ? length : end;
  return (!start && end >= length) ? array : baseSlice(array, start, end);
}

/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
 * that is not found in the character symbols.
 *
 * @private
 * @param {Array} strSymbols The string symbols to inspect.
 * @param {Array} chrSymbols The character symbols to find.
 * @returns {number} Returns the index of the last unmatched string symbol.
 */
function charsEndIndex(strSymbols, chrSymbols) {
  var index = strSymbols.length;

  while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
  return index;
}

/**
 * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
 * that is not found in the character symbols.
 *
 * @private
 * @param {Array} strSymbols The string symbols to inspect.
 * @param {Array} chrSymbols The character symbols to find.
 * @returns {number} Returns the index of the first unmatched string symbol.
 */
function charsStartIndex(strSymbols, chrSymbols) {
  var index = -1,
      length = strSymbols.length;

  while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
  return index;
}

/**
 * Converts an ASCII `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function asciiToArray(string) {
  return string.split('');
}

/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff';
var rsComboMarksRange = '\\u0300-\\u036f';
var reComboHalfMarksRange = '\\ufe20-\\ufe2f';
var rsComboSymbolsRange = '\\u20d0-\\u20ff';
var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
var rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsZWJ = '\\u200d';

/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

/**
 * Checks if `string` contains Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a symbol is found, else `false`.
 */
function hasUnicode(string) {
  return reHasUnicode.test(string);
}

/** Used to compose unicode character classes. */
var rsAstralRange$1 = '\\ud800-\\udfff';
var rsComboMarksRange$1 = '\\u0300-\\u036f';
var reComboHalfMarksRange$1 = '\\ufe20-\\ufe2f';
var rsComboSymbolsRange$1 = '\\u20d0-\\u20ff';
var rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;
var rsVarRange$1 = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsAstral = '[' + rsAstralRange$1 + ']';
var rsCombo = '[' + rsComboRange$1 + ']';
var rsFitz = '\\ud83c[\\udffb-\\udfff]';
var rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')';
var rsNonAstral = '[^' + rsAstralRange$1 + ']';
var rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}';
var rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]';
var rsZWJ$1 = '\\u200d';

/** Used to compose unicode regexes. */
var reOptMod = rsModifier + '?';
var rsOptVar = '[' + rsVarRange$1 + ']?';
var rsOptJoin = '(?:' + rsZWJ$1 + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*';
var rsSeq = rsOptVar + reOptMod + rsOptJoin;
var rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

/**
 * Converts a Unicode `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function unicodeToArray(string) {
  return string.match(reUnicode) || [];
}

/**
 * Converts `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function stringToArray(string) {
  return hasUnicode(string)
    ? unicodeToArray(string)
    : asciiToArray(string);
}

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/**
 * Removes leading and trailing whitespace or specified characters from `string`.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to trim.
 * @param {string} [chars=whitespace] The characters to trim.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {string} Returns the trimmed string.
 * @example
 *
 * _.trim('  abc  ');
 * // => 'abc'
 *
 * _.trim('-_-abc-_-', '_-');
 * // => 'abc'
 *
 * _.map(['  foo  ', '  bar  '], _.trim);
 * // => ['foo', 'bar']
 */
function trim(string, chars, guard) {
  string = toString(string);
  if (string && (guard || chars === undefined)) {
    return string.replace(reTrim, '');
  }
  if (!string || !(chars = baseToString(chars))) {
    return string;
  }
  var strSymbols = stringToArray(string),
      chrSymbols = stringToArray(chars),
      start = charsStartIndex(strSymbols, chrSymbols),
      end = charsEndIndex(strSymbols, chrSymbols) + 1;

  return castSlice(strSymbols, start, end).join('');
}

var FN_ARGS = /^(?:async\s+)?(function)?\s*[^\(]*\(\s*([^\)]*)\)/m;
var FN_ARG_SPLIT = /,/;
var FN_ARG = /(=.+)?(\s*)$/;
var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;

function parseParams(func) {
    func = func.toString().replace(STRIP_COMMENTS, '');
    func = func.match(FN_ARGS)[2].replace(' ', '');
    func = func ? func.split(FN_ARG_SPLIT) : [];
    func = func.map(function (arg){
        return trim(arg.replace(FN_ARG, ''));
    });
    return func;
}

/**
 * A dependency-injected version of the [async.auto]{@link module:ControlFlow.auto} function. Dependent
 * tasks are specified as parameters to the function, after the usual callback
 * parameter, with the parameter names matching the names of the tasks it
 * depends on. This can provide even more readable task graphs which can be
 * easier to maintain.
 *
 * If a final callback is specified, the task results are similarly injected,
 * specified as named parameters after the initial error parameter.
 *
 * The autoInject function is purely syntactic sugar and its semantics are
 * otherwise equivalent to [async.auto]{@link module:ControlFlow.auto}.
 *
 * @name autoInject
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.auto]{@link module:ControlFlow.auto}
 * @category Control Flow
 * @param {Object} tasks - An object, each of whose properties is an {@link AsyncFunction} of
 * the form 'func([dependencies...], callback). The object's key of a property
 * serves as the name of the task defined by that property, i.e. can be used
 * when specifying requirements for other tasks.
 * * The `callback` parameter is a `callback(err, result)` which must be called
 *   when finished, passing an `error` (which can be `null`) and the result of
 *   the function's execution. The remaining parameters name other tasks on
 *   which the task is dependent, and the results from those tasks are the
 *   arguments of those parameters.
 * @param {Function} [callback] - An optional callback which is called when all
 * the tasks have been completed. It receives the `err` argument if any `tasks`
 * pass an error to their callback, and a `results` object with any completed
 * task results, similar to `auto`.
 * @example
 *
 * //  The example from `auto` can be rewritten as follows:
 * async.autoInject({
 *     get_data: function(callback) {
 *         // async code to get some data
 *         callback(null, 'data', 'converted to array');
 *     },
 *     make_folder: function(callback) {
 *         // async code to create a directory to store a file in
 *         // this is run at the same time as getting the data
 *         callback(null, 'folder');
 *     },
 *     write_file: function(get_data, make_folder, callback) {
 *         // once there is some data and the directory exists,
 *         // write the data to a file in the directory
 *         callback(null, 'filename');
 *     },
 *     email_link: function(write_file, callback) {
 *         // once the file is written let's email a link to it...
 *         // write_file contains the filename returned by write_file.
 *         callback(null, {'file':write_file, 'email':'user@example.com'});
 *     }
 * }, function(err, results) {
 *     console.log('err = ', err);
 *     console.log('email_link = ', results.email_link);
 * });
 *
 * // If you are using a JS minifier that mangles parameter names, `autoInject`
 * // will not work with plain functions, since the parameter names will be
 * // collapsed to a single letter identifier.  To work around this, you can
 * // explicitly specify the names of the parameters your task function needs
 * // in an array, similar to Angular.js dependency injection.
 *
 * // This still has an advantage over plain `auto`, since the results a task
 * // depends on are still spread into arguments.
 * async.autoInject({
 *     //...
 *     write_file: ['get_data', 'make_folder', function(get_data, make_folder, callback) {
 *         callback(null, 'filename');
 *     }],
 *     email_link: ['write_file', function(write_file, callback) {
 *         callback(null, {'file':write_file, 'email':'user@example.com'});
 *     }]
 *     //...
 * }, function(err, results) {
 *     console.log('err = ', err);
 *     console.log('email_link = ', results.email_link);
 * });
 */
function autoInject(tasks, callback) {
    var newTasks = {};

    baseForOwn(tasks, function (taskFn, key) {
        var params;
        var fnIsAsync = isAsync(taskFn);
        var hasNoDeps =
            (!fnIsAsync && taskFn.length === 1) ||
            (fnIsAsync && taskFn.length === 0);

        if (isArray(taskFn)) {
            params = taskFn.slice(0, -1);
            taskFn = taskFn[taskFn.length - 1];

            newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);
        } else if (hasNoDeps) {
            // no dependencies, use the function as-is
            newTasks[key] = taskFn;
        } else {
            params = parseParams(taskFn);
            if (taskFn.length === 0 && !fnIsAsync && params.length === 0) {
                throw new Error("autoInject task functions require explicit parameters.");
            }

            // remove callback param
            if (!fnIsAsync) params.pop();

            newTasks[key] = params.concat(newTask);
        }

        function newTask(results, taskCb) {
            var newArgs = arrayMap(params, function (name) {
                return results[name];
            });
            newArgs.push(taskCb);
            wrapAsync(taskFn).apply(null, newArgs);
        }
    });

    auto(newTasks, callback);
}

// Simple doubly linked list (https://en.wikipedia.org/wiki/Doubly_linked_list) implementation
// used for queues. This implementation assumes that the node provided by the user can be modified
// to adjust the next and last properties. We implement only the minimal functionality
// for queue support.
function DLL() {
    this.head = this.tail = null;
    this.length = 0;
}

function setInitial(dll, node) {
    dll.length = 1;
    dll.head = dll.tail = node;
}

DLL.prototype.removeLink = function(node) {
    if (node.prev) node.prev.next = node.next;
    else this.head = node.next;
    if (node.next) node.next.prev = node.prev;
    else this.tail = node.prev;

    node.prev = node.next = null;
    this.length -= 1;
    return node;
};

DLL.prototype.empty = function () {
    while(this.head) this.shift();
    return this;
};

DLL.prototype.insertAfter = function(node, newNode) {
    newNode.prev = node;
    newNode.next = node.next;
    if (node.next) node.next.prev = newNode;
    else this.tail = newNode;
    node.next = newNode;
    this.length += 1;
};

DLL.prototype.insertBefore = function(node, newNode) {
    newNode.prev = node.prev;
    newNode.next = node;
    if (node.prev) node.prev.next = newNode;
    else this.head = newNode;
    node.prev = newNode;
    this.length += 1;
};

DLL.prototype.unshift = function(node) {
    if (this.head) this.insertBefore(this.head, node);
    else setInitial(this, node);
};

DLL.prototype.push = function(node) {
    if (this.tail) this.insertAfter(this.tail, node);
    else setInitial(this, node);
};

DLL.prototype.shift = function() {
    return this.head && this.removeLink(this.head);
};

DLL.prototype.pop = function() {
    return this.tail && this.removeLink(this.tail);
};

DLL.prototype.toArray = function () {
    var arr = Array(this.length);
    var curr = this.head;
    for(var idx = 0; idx < this.length; idx++) {
        arr[idx] = curr.data;
        curr = curr.next;
    }
    return arr;
};

DLL.prototype.remove = function (testFn) {
    var curr = this.head;
    while(!!curr) {
        var next = curr.next;
        if (testFn(curr)) {
            this.removeLink(curr);
        }
        curr = next;
    }
    return this;
};

function queue(worker, concurrency, payload) {
    if (concurrency == null) {
        concurrency = 1;
    }
    else if(concurrency === 0) {
        throw new Error('Concurrency must not be zero');
    }

    var _worker = wrapAsync(worker);
    var numRunning = 0;
    var workersList = [];

    var processingScheduled = false;
    function _insert(data, insertAtFront, callback) {
        if (callback != null && typeof callback !== 'function') {
            throw new Error('task callback must be a function');
        }
        q.started = true;
        if (!isArray(data)) {
            data = [data];
        }
        if (data.length === 0 && q.idle()) {
            // call drain immediately if there are no tasks
            return setImmediate$1(function() {
                q.drain();
            });
        }

        for (var i = 0, l = data.length; i < l; i++) {
            var item = {
                data: data[i],
                callback: callback || noop
            };

            if (insertAtFront) {
                q._tasks.unshift(item);
            } else {
                q._tasks.push(item);
            }
        }

        if (!processingScheduled) {
            processingScheduled = true;
            setImmediate$1(function() {
                processingScheduled = false;
                q.process();
            });
        }
    }

    function _next(tasks) {
        return function(err){
            numRunning -= 1;

            for (var i = 0, l = tasks.length; i < l; i++) {
                var task = tasks[i];

                var index = baseIndexOf(workersList, task, 0);
                if (index === 0) {
                    workersList.shift();
                } else if (index > 0) {
                    workersList.splice(index, 1);
                }

                task.callback.apply(task, arguments);

                if (err != null) {
                    q.error(err, task.data);
                }
            }

            if (numRunning <= (q.concurrency - q.buffer) ) {
                q.unsaturated();
            }

            if (q.idle()) {
                q.drain();
            }
            q.process();
        };
    }

    var isProcessing = false;
    var q = {
        _tasks: new DLL(),
        concurrency: concurrency,
        payload: payload,
        saturated: noop,
        unsaturated:noop,
        buffer: concurrency / 4,
        empty: noop,
        drain: noop,
        error: noop,
        started: false,
        paused: false,
        push: function (data, callback) {
            _insert(data, false, callback);
        },
        kill: function () {
            q.drain = noop;
            q._tasks.empty();
        },
        unshift: function (data, callback) {
            _insert(data, true, callback);
        },
        remove: function (testFn) {
            q._tasks.remove(testFn);
        },
        process: function () {
            // Avoid trying to start too many processing operations. This can occur
            // when callbacks resolve synchronously (#1267).
            if (isProcessing) {
                return;
            }
            isProcessing = true;
            while(!q.paused && numRunning < q.concurrency && q._tasks.length){
                var tasks = [], data = [];
                var l = q._tasks.length;
                if (q.payload) l = Math.min(l, q.payload);
                for (var i = 0; i < l; i++) {
                    var node = q._tasks.shift();
                    tasks.push(node);
                    workersList.push(node);
                    data.push(node.data);
                }

                numRunning += 1;

                if (q._tasks.length === 0) {
                    q.empty();
                }

                if (numRunning === q.concurrency) {
                    q.saturated();
                }

                var cb = onlyOnce(_next(tasks));
                _worker(data, cb);
            }
            isProcessing = false;
        },
        length: function () {
            return q._tasks.length;
        },
        running: function () {
            return numRunning;
        },
        workersList: function () {
            return workersList;
        },
        idle: function() {
            return q._tasks.length + numRunning === 0;
        },
        pause: function () {
            q.paused = true;
        },
        resume: function () {
            if (q.paused === false) { return; }
            q.paused = false;
            setImmediate$1(q.process);
        }
    };
    return q;
}

/**
 * A cargo of tasks for the worker function to complete. Cargo inherits all of
 * the same methods and event callbacks as [`queue`]{@link module:ControlFlow.queue}.
 * @typedef {Object} CargoObject
 * @memberOf module:ControlFlow
 * @property {Function} length - A function returning the number of items
 * waiting to be processed. Invoke like `cargo.length()`.
 * @property {number} payload - An `integer` for determining how many tasks
 * should be process per round. This property can be changed after a `cargo` is
 * created to alter the payload on-the-fly.
 * @property {Function} push - Adds `task` to the `queue`. The callback is
 * called once the `worker` has finished processing the task. Instead of a
 * single task, an array of `tasks` can be submitted. The respective callback is
 * used for every task in the list. Invoke like `cargo.push(task, [callback])`.
 * @property {Function} saturated - A callback that is called when the
 * `queue.length()` hits the concurrency and further tasks will be queued.
 * @property {Function} empty - A callback that is called when the last item
 * from the `queue` is given to a `worker`.
 * @property {Function} drain - A callback that is called when the last item
 * from the `queue` has returned from the `worker`.
 * @property {Function} idle - a function returning false if there are items
 * waiting or being processed, or true if not. Invoke like `cargo.idle()`.
 * @property {Function} pause - a function that pauses the processing of tasks
 * until `resume()` is called. Invoke like `cargo.pause()`.
 * @property {Function} resume - a function that resumes the processing of
 * queued tasks when the queue is paused. Invoke like `cargo.resume()`.
 * @property {Function} kill - a function that removes the `drain` callback and
 * empties remaining tasks from the queue forcing it to go idle. Invoke like `cargo.kill()`.
 */

/**
 * Creates a `cargo` object with the specified payload. Tasks added to the
 * cargo will be processed altogether (up to the `payload` limit). If the
 * `worker` is in progress, the task is queued until it becomes available. Once
 * the `worker` has completed some tasks, each callback of those tasks is
 * called. Check out [these](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) [animations](https://camo.githubusercontent.com/f4810e00e1c5f5f8addbe3e9f49064fd5d102699/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130312f38346339323036362d356632392d313165322d383134662d3964336430323431336266642e676966)
 * for how `cargo` and `queue` work.
 *
 * While [`queue`]{@link module:ControlFlow.queue} passes only one task to one of a group of workers
 * at a time, cargo passes an array of tasks to a single worker, repeating
 * when the worker is finished.
 *
 * @name cargo
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.queue]{@link module:ControlFlow.queue}
 * @category Control Flow
 * @param {AsyncFunction} worker - An asynchronous function for processing an array
 * of queued tasks. Invoked with `(tasks, callback)`.
 * @param {number} [payload=Infinity] - An optional `integer` for determining
 * how many tasks should be processed per round; if omitted, the default is
 * unlimited.
 * @returns {module:ControlFlow.CargoObject} A cargo object to manage the tasks. Callbacks can
 * attached as certain properties to listen for specific events during the
 * lifecycle of the cargo and inner queue.
 * @example
 *
 * // create a cargo object with payload 2
 * var cargo = async.cargo(function(tasks, callback) {
 *     for (var i=0; i<tasks.length; i++) {
 *         console.log('hello ' + tasks[i].name);
 *     }
 *     callback();
 * }, 2);
 *
 * // add some items
 * cargo.push({name: 'foo'}, function(err) {
 *     console.log('finished processing foo');
 * });
 * cargo.push({name: 'bar'}, function(err) {
 *     console.log('finished processing bar');
 * });
 * cargo.push({name: 'baz'}, function(err) {
 *     console.log('finished processing baz');
 * });
 */
function cargo(worker, payload) {
    return queue(worker, 1, payload);
}

/**
 * The same as [`eachOf`]{@link module:Collections.eachOf} but runs only a single async operation at a time.
 *
 * @name eachOfSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.eachOf]{@link module:Collections.eachOf}
 * @alias forEachOfSeries
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * Invoked with (item, key, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. Invoked with (err).
 */
var eachOfSeries = doLimit(eachOfLimit, 1);

/**
 * Reduces `coll` into a single value using an async `iteratee` to return each
 * successive step. `memo` is the initial state of the reduction. This function
 * only operates in series.
 *
 * For performance reasons, it may make sense to split a call to this function
 * into a parallel map, and then use the normal `Array.prototype.reduce` on the
 * results. This function is for situations where each step in the reduction
 * needs to be async; if you can get the data before reducing it, then it's
 * probably a good idea to do so.
 *
 * @name reduce
 * @static
 * @memberOf module:Collections
 * @method
 * @alias inject
 * @alias foldl
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {*} memo - The initial state of the reduction.
 * @param {AsyncFunction} iteratee - A function applied to each item in the
 * array to produce the next step in the reduction.
 * The `iteratee` should complete with the next state of the reduction.
 * If the iteratee complete with an error, the reduction is stopped and the
 * main `callback` is immediately called with the error.
 * Invoked with (memo, item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Result is the reduced value. Invoked with
 * (err, result).
 * @example
 *
 * async.reduce([1,2,3], 0, function(memo, item, callback) {
 *     // pointless async:
 *     process.nextTick(function() {
 *         callback(null, memo + item)
 *     });
 * }, function(err, result) {
 *     // result is now equal to the last value of memo, which is 6
 * });
 */
function reduce(coll, memo, iteratee, callback) {
    callback = once(callback || noop);
    var _iteratee = wrapAsync(iteratee);
    eachOfSeries(coll, function(x, i, callback) {
        _iteratee(memo, x, function(err, v) {
            memo = v;
            callback(err);
        });
    }, function(err) {
        callback(err, memo);
    });
}

/**
 * Version of the compose function that is more natural to read. Each function
 * consumes the return value of the previous function. It is the equivalent of
 * [compose]{@link module:ControlFlow.compose} with the arguments reversed.
 *
 * Each function is executed with the `this` binding of the composed function.
 *
 * @name seq
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.compose]{@link module:ControlFlow.compose}
 * @category Control Flow
 * @param {...AsyncFunction} functions - the asynchronous functions to compose
 * @returns {Function} a function that composes the `functions` in order
 * @example
 *
 * // Requires lodash (or underscore), express3 and dresende's orm2.
 * // Part of an app, that fetches cats of the logged user.
 * // This example uses `seq` function to avoid overnesting and error
 * // handling clutter.
 * app.get('/cats', function(request, response) {
 *     var User = request.models.User;
 *     async.seq(
 *         _.bind(User.get, User),  // 'User.get' has signature (id, callback(err, data))
 *         function(user, fn) {
 *             user.getCats(fn);      // 'getCats' has signature (callback(err, data))
 *         }
 *     )(req.session.user_id, function (err, cats) {
 *         if (err) {
 *             console.error(err);
 *             response.json({ status: 'error', message: err.message });
 *         } else {
 *             response.json({ status: 'ok', message: 'Cats found', data: cats });
 *         }
 *     });
 * });
 */
function seq(/*...functions*/) {
    var _functions = arrayMap(arguments, wrapAsync);
    return function(/*...args*/) {
        var args = slice(arguments);
        var that = this;

        var cb = args[args.length - 1];
        if (typeof cb == 'function') {
            args.pop();
        } else {
            cb = noop;
        }

        reduce(_functions, args, function(newargs, fn, cb) {
            fn.apply(that, newargs.concat(function(err/*, ...nextargs*/) {
                var nextargs = slice(arguments, 1);
                cb(err, nextargs);
            }));
        },
        function(err, results) {
            cb.apply(that, [err].concat(results));
        });
    };
}

/**
 * Creates a function which is a composition of the passed asynchronous
 * functions. Each function consumes the return value of the function that
 * follows. Composing functions `f()`, `g()`, and `h()` would produce the result
 * of `f(g(h()))`, only this version uses callbacks to obtain the return values.
 *
 * Each function is executed with the `this` binding of the composed function.
 *
 * @name compose
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {...AsyncFunction} functions - the asynchronous functions to compose
 * @returns {Function} an asynchronous function that is the composed
 * asynchronous `functions`
 * @example
 *
 * function add1(n, callback) {
 *     setTimeout(function () {
 *         callback(null, n + 1);
 *     }, 10);
 * }
 *
 * function mul3(n, callback) {
 *     setTimeout(function () {
 *         callback(null, n * 3);
 *     }, 10);
 * }
 *
 * var add1mul3 = async.compose(mul3, add1);
 * add1mul3(4, function (err, result) {
 *     // result now equals 15
 * });
 */
var compose = function(/*...args*/) {
    return seq.apply(null, slice(arguments).reverse());
};

var _concat = Array.prototype.concat;

/**
 * The same as [`concat`]{@link module:Collections.concat} but runs a maximum of `limit` async operations at a time.
 *
 * @name concatLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.concat]{@link module:Collections.concat}
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`,
 * which should use an array as its result. Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished, or an error occurs. Results is an array
 * containing the concatenated results of the `iteratee` function. Invoked with
 * (err, results).
 */
var concatLimit = function(coll, limit, iteratee, callback) {
    callback = callback || noop;
    var _iteratee = wrapAsync(iteratee);
    mapLimit(coll, limit, function(val, callback) {
        _iteratee(val, function(err /*, ...args*/) {
            if (err) return callback(err);
            return callback(null, slice(arguments, 1));
        });
    }, function(err, mapResults) {
        var result = [];
        for (var i = 0; i < mapResults.length; i++) {
            if (mapResults[i]) {
                result = _concat.apply(result, mapResults[i]);
            }
        }

        return callback(err, result);
    });
};

/**
 * Applies `iteratee` to each item in `coll`, concatenating the results. Returns
 * the concatenated list. The `iteratee`s are called in parallel, and the
 * results are concatenated as they return. There is no guarantee that the
 * results array will be returned in the original order of `coll` passed to the
 * `iteratee` function.
 *
 * @name concat
 * @static
 * @memberOf module:Collections
 * @method
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`,
 * which should use an array as its result. Invoked with (item, callback).
 * @param {Function} [callback(err)] - A callback which is called after all the
 * `iteratee` functions have finished, or an error occurs. Results is an array
 * containing the concatenated results of the `iteratee` function. Invoked with
 * (err, results).
 * @example
 *
 * async.concat(['dir1','dir2','dir3'], fs.readdir, function(err, files) {
 *     // files is now a list of filenames that exist in the 3 directories
 * });
 */
var concat = doLimit(concatLimit, Infinity);

/**
 * The same as [`concat`]{@link module:Collections.concat} but runs only a single async operation at a time.
 *
 * @name concatSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.concat]{@link module:Collections.concat}
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`.
 * The iteratee should complete with an array an array of results.
 * Invoked with (item, callback).
 * @param {Function} [callback(err)] - A callback which is called after all the
 * `iteratee` functions have finished, or an error occurs. Results is an array
 * containing the concatenated results of the `iteratee` function. Invoked with
 * (err, results).
 */
var concatSeries = doLimit(concatLimit, 1);

/**
 * Returns a function that when called, calls-back with the values provided.
 * Useful as the first function in a [`waterfall`]{@link module:ControlFlow.waterfall}, or for plugging values in to
 * [`auto`]{@link module:ControlFlow.auto}.
 *
 * @name constant
 * @static
 * @memberOf module:Utils
 * @method
 * @category Util
 * @param {...*} arguments... - Any number of arguments to automatically invoke
 * callback with.
 * @returns {AsyncFunction} Returns a function that when invoked, automatically
 * invokes the callback with the previous given arguments.
 * @example
 *
 * async.waterfall([
 *     async.constant(42),
 *     function (value, next) {
 *         // value === 42
 *     },
 *     //...
 * ], callback);
 *
 * async.waterfall([
 *     async.constant(filename, "utf8"),
 *     fs.readFile,
 *     function (fileData, next) {
 *         //...
 *     }
 *     //...
 * ], callback);
 *
 * async.auto({
 *     hostname: async.constant("https://server.net/"),
 *     port: findFreePort,
 *     launchServer: ["hostname", "port", function (options, cb) {
 *         startServer(options, cb);
 *     }],
 *     //...
 * }, callback);
 */
var constant = function(/*...values*/) {
    var values = slice(arguments);
    var args = [null].concat(values);
    return function (/*...ignoredArgs, callback*/) {
        var callback = arguments[arguments.length - 1];
        return callback.apply(this, args);
    };
};

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

function _createTester(check, getResult) {
    return function(eachfn, arr, iteratee, cb) {
        cb = cb || noop;
        var testPassed = false;
        var testResult;
        eachfn(arr, function(value, _, callback) {
            iteratee(value, function(err, result) {
                if (err) {
                    callback(err);
                } else if (check(result) && !testResult) {
                    testPassed = true;
                    testResult = getResult(true, value);
                    callback(null, breakLoop);
                } else {
                    callback();
                }
            });
        }, function(err) {
            if (err) {
                cb(err);
            } else {
                cb(null, testPassed ? testResult : getResult(false));
            }
        });
    };
}

function _findGetResult(v, x) {
    return x;
}

/**
 * Returns the first value in `coll` that passes an async truth test. The
 * `iteratee` is applied in parallel, meaning the first iteratee to return
 * `true` will fire the detect `callback` with that result. That means the
 * result might not be the first item in the original `coll` (in terms of order)
 * that passes the test.

 * If order within the original `coll` is important, then look at
 * [`detectSeries`]{@link module:Collections.detectSeries}.
 *
 * @name detect
 * @static
 * @memberOf module:Collections
 * @method
 * @alias find
 * @category Collections
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.
 * The iteratee must complete with a boolean value as its result.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called as soon as any
 * iteratee returns `true`, or after all the `iteratee` functions have finished.
 * Result will be the first item in the array that passes the truth test
 * (iteratee) or the value `undefined` if none passed. Invoked with
 * (err, result).
 * @example
 *
 * async.detect(['file1','file2','file3'], function(filePath, callback) {
 *     fs.access(filePath, function(err) {
 *         callback(null, !err)
 *     });
 * }, function(err, result) {
 *     // result now equals the first file in the list that exists
 * });
 */
var detect = doParallel(_createTester(identity, _findGetResult));

/**
 * The same as [`detect`]{@link module:Collections.detect} but runs a maximum of `limit` async operations at a
 * time.
 *
 * @name detectLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.detect]{@link module:Collections.detect}
 * @alias findLimit
 * @category Collections
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.
 * The iteratee must complete with a boolean value as its result.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called as soon as any
 * iteratee returns `true`, or after all the `iteratee` functions have finished.
 * Result will be the first item in the array that passes the truth test
 * (iteratee) or the value `undefined` if none passed. Invoked with
 * (err, result).
 */
var detectLimit = doParallelLimit(_createTester(identity, _findGetResult));

/**
 * The same as [`detect`]{@link module:Collections.detect} but runs only a single async operation at a time.
 *
 * @name detectSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.detect]{@link module:Collections.detect}
 * @alias findSeries
 * @category Collections
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.
 * The iteratee must complete with a boolean value as its result.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called as soon as any
 * iteratee returns `true`, or after all the `iteratee` functions have finished.
 * Result will be the first item in the array that passes the truth test
 * (iteratee) or the value `undefined` if none passed. Invoked with
 * (err, result).
 */
var detectSeries = doLimit(detectLimit, 1);

function consoleFunc(name) {
    return function (fn/*, ...args*/) {
        var args = slice(arguments, 1);
        args.push(function (err/*, ...args*/) {
            var args = slice(arguments, 1);
            if (typeof console === 'object') {
                if (err) {
                    if (console.error) {
                        console.error(err);
                    }
                } else if (console[name]) {
                    arrayEach(args, function (x) {
                        console[name](x);
                    });
                }
            }
        });
        wrapAsync(fn).apply(null, args);
    };
}

/**
 * Logs the result of an [`async` function]{@link AsyncFunction} to the
 * `console` using `console.dir` to display the properties of the resulting object.
 * Only works in Node.js or in browsers that support `console.dir` and
 * `console.error` (such as FF and Chrome).
 * If multiple arguments are returned from the async function,
 * `console.dir` is called on each argument in order.
 *
 * @name dir
 * @static
 * @memberOf module:Utils
 * @method
 * @category Util
 * @param {AsyncFunction} function - The function you want to eventually apply
 * all arguments to.
 * @param {...*} arguments... - Any number of arguments to apply to the function.
 * @example
 *
 * // in a module
 * var hello = function(name, callback) {
 *     setTimeout(function() {
 *         callback(null, {hello: name});
 *     }, 1000);
 * };
 *
 * // in the node repl
 * node> async.dir(hello, 'world');
 * {hello: 'world'}
 */
var dir = consoleFunc('dir');

/**
 * The post-check version of [`during`]{@link module:ControlFlow.during}. To reflect the difference in
 * the order of operations, the arguments `test` and `fn` are switched.
 *
 * Also a version of [`doWhilst`]{@link module:ControlFlow.doWhilst} with asynchronous `test` function.
 * @name doDuring
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.during]{@link module:ControlFlow.during}
 * @category Control Flow
 * @param {AsyncFunction} fn - An async function which is called each time
 * `test` passes. Invoked with (callback).
 * @param {AsyncFunction} test - asynchronous truth test to perform before each
 * execution of `fn`. Invoked with (...args, callback), where `...args` are the
 * non-error args from the previous callback of `fn`.
 * @param {Function} [callback] - A callback which is called after the test
 * function has failed and repeated execution of `fn` has stopped. `callback`
 * will be passed an error if one occurred, otherwise `null`.
 */
function doDuring(fn, test, callback) {
    callback = onlyOnce(callback || noop);
    var _fn = wrapAsync(fn);
    var _test = wrapAsync(test);

    function next(err/*, ...args*/) {
        if (err) return callback(err);
        var args = slice(arguments, 1);
        args.push(check);
        _test.apply(this, args);
    }

    function check(err, truth) {
        if (err) return callback(err);
        if (!truth) return callback(null);
        _fn(next);
    }

    check(null, true);

}

/**
 * The post-check version of [`whilst`]{@link module:ControlFlow.whilst}. To reflect the difference in
 * the order of operations, the arguments `test` and `iteratee` are switched.
 *
 * `doWhilst` is to `whilst` as `do while` is to `while` in plain JavaScript.
 *
 * @name doWhilst
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.whilst]{@link module:ControlFlow.whilst}
 * @category Control Flow
 * @param {AsyncFunction} iteratee - A function which is called each time `test`
 * passes. Invoked with (callback).
 * @param {Function} test - synchronous truth test to perform after each
 * execution of `iteratee`. Invoked with any non-error callback results of
 * `iteratee`.
 * @param {Function} [callback] - A callback which is called after the test
 * function has failed and repeated execution of `iteratee` has stopped.
 * `callback` will be passed an error and any arguments passed to the final
 * `iteratee`'s callback. Invoked with (err, [results]);
 */
function doWhilst(iteratee, test, callback) {
    callback = onlyOnce(callback || noop);
    var _iteratee = wrapAsync(iteratee);
    var next = function(err/*, ...args*/) {
        if (err) return callback(err);
        var args = slice(arguments, 1);
        if (test.apply(this, args)) return _iteratee(next);
        callback.apply(null, [null].concat(args));
    };
    _iteratee(next);
}

/**
 * Like ['doWhilst']{@link module:ControlFlow.doWhilst}, except the `test` is inverted. Note the
 * argument ordering differs from `until`.
 *
 * @name doUntil
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.doWhilst]{@link module:ControlFlow.doWhilst}
 * @category Control Flow
 * @param {AsyncFunction} iteratee - An async function which is called each time
 * `test` fails. Invoked with (callback).
 * @param {Function} test - synchronous truth test to perform after each
 * execution of `iteratee`. Invoked with any non-error callback results of
 * `iteratee`.
 * @param {Function} [callback] - A callback which is called after the test
 * function has passed and repeated execution of `iteratee` has stopped. `callback`
 * will be passed an error and any arguments passed to the final `iteratee`'s
 * callback. Invoked with (err, [results]);
 */
function doUntil(iteratee, test, callback) {
    doWhilst(iteratee, function() {
        return !test.apply(this, arguments);
    }, callback);
}

/**
 * Like [`whilst`]{@link module:ControlFlow.whilst}, except the `test` is an asynchronous function that
 * is passed a callback in the form of `function (err, truth)`. If error is
 * passed to `test` or `fn`, the main callback is immediately called with the
 * value of the error.
 *
 * @name during
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.whilst]{@link module:ControlFlow.whilst}
 * @category Control Flow
 * @param {AsyncFunction} test - asynchronous truth test to perform before each
 * execution of `fn`. Invoked with (callback).
 * @param {AsyncFunction} fn - An async function which is called each time
 * `test` passes. Invoked with (callback).
 * @param {Function} [callback] - A callback which is called after the test
 * function has failed and repeated execution of `fn` has stopped. `callback`
 * will be passed an error, if one occurred, otherwise `null`.
 * @example
 *
 * var count = 0;
 *
 * async.during(
 *     function (callback) {
 *         return callback(null, count < 5);
 *     },
 *     function (callback) {
 *         count++;
 *         setTimeout(callback, 1000);
 *     },
 *     function (err) {
 *         // 5 seconds have passed
 *     }
 * );
 */
function during(test, fn, callback) {
    callback = onlyOnce(callback || noop);
    var _fn = wrapAsync(fn);
    var _test = wrapAsync(test);

    function next(err) {
        if (err) return callback(err);
        _test(check);
    }

    function check(err, truth) {
        if (err) return callback(err);
        if (!truth) return callback(null);
        _fn(next);
    }

    _test(check);
}

function _withoutIndex(iteratee) {
    return function (value, index, callback) {
        return iteratee(value, callback);
    };
}

/**
 * Applies the function `iteratee` to each item in `coll`, in parallel.
 * The `iteratee` is called with an item from the list, and a callback for when
 * it has finished. If the `iteratee` passes an error to its `callback`, the
 * main `callback` (for the `each` function) is immediately called with the
 * error.
 *
 * Note, that since this function applies `iteratee` to each item in parallel,
 * there is no guarantee that the iteratee functions will complete in order.
 *
 * @name each
 * @static
 * @memberOf module:Collections
 * @method
 * @alias forEach
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async function to apply to
 * each item in `coll`. Invoked with (item, callback).
 * The array index is not passed to the iteratee.
 * If you need the index, use `eachOf`.
 * @param {Function} [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 * @example
 *
 * // assuming openFiles is an array of file names and saveFile is a function
 * // to save the modified contents of that file:
 *
 * async.each(openFiles, saveFile, function(err){
 *   // if any of the saves produced an error, err would equal that error
 * });
 *
 * // assuming openFiles is an array of file names
 * async.each(openFiles, function(file, callback) {
 *
 *     // Perform operation on file here.
 *     console.log('Processing file ' + file);
 *
 *     if( file.length > 32 ) {
 *       console.log('This file name is too long');
 *       callback('File name too long');
 *     } else {
 *       // Do work to process file here
 *       console.log('File processed');
 *       callback();
 *     }
 * }, function(err) {
 *     // if any of the file processing produced an error, err would equal that error
 *     if( err ) {
 *       // One of the iterations produced an error.
 *       // All processing will now stop.
 *       console.log('A file failed to process');
 *     } else {
 *       console.log('All files have been processed successfully');
 *     }
 * });
 */
function eachLimit(coll, iteratee, callback) {
    eachOf(coll, _withoutIndex(wrapAsync(iteratee)), callback);
}

/**
 * The same as [`each`]{@link module:Collections.each} but runs a maximum of `limit` async operations at a time.
 *
 * @name eachLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.each]{@link module:Collections.each}
 * @alias forEachLimit
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * The array index is not passed to the iteratee.
 * If you need the index, use `eachOfLimit`.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 */
function eachLimit$1(coll, limit, iteratee, callback) {
    _eachOfLimit(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);
}

/**
 * The same as [`each`]{@link module:Collections.each} but runs only a single async operation at a time.
 *
 * @name eachSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.each]{@link module:Collections.each}
 * @alias forEachSeries
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async function to apply to each
 * item in `coll`.
 * The array index is not passed to the iteratee.
 * If you need the index, use `eachOfSeries`.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 */
var eachSeries = doLimit(eachLimit$1, 1);

/**
 * Wrap an async function and ensure it calls its callback on a later tick of
 * the event loop.  If the function already calls its callback on a next tick,
 * no extra deferral is added. This is useful for preventing stack overflows
 * (`RangeError: Maximum call stack size exceeded`) and generally keeping
 * [Zalgo](http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony)
 * contained. ES2017 `async` functions are returned as-is -- they are immune
 * to Zalgo's corrupting influences, as they always resolve on a later tick.
 *
 * @name ensureAsync
 * @static
 * @memberOf module:Utils
 * @method
 * @category Util
 * @param {AsyncFunction} fn - an async function, one that expects a node-style
 * callback as its last argument.
 * @returns {AsyncFunction} Returns a wrapped function with the exact same call
 * signature as the function passed in.
 * @example
 *
 * function sometimesAsync(arg, callback) {
 *     if (cache[arg]) {
 *         return callback(null, cache[arg]); // this would be synchronous!!
 *     } else {
 *         doSomeIO(arg, callback); // this IO would be asynchronous
 *     }
 * }
 *
 * // this has a risk of stack overflows if many results are cached in a row
 * async.mapSeries(args, sometimesAsync, done);
 *
 * // this will defer sometimesAsync's callback if necessary,
 * // preventing stack overflows
 * async.mapSeries(args, async.ensureAsync(sometimesAsync), done);
 */
function ensureAsync(fn) {
    if (isAsync(fn)) return fn;
    return initialParams(function (args, callback) {
        var sync = true;
        args.push(function () {
            var innerArgs = arguments;
            if (sync) {
                setImmediate$1(function () {
                    callback.apply(null, innerArgs);
                });
            } else {
                callback.apply(null, innerArgs);
            }
        });
        fn.apply(this, args);
        sync = false;
    });
}

function notId(v) {
    return !v;
}

/**
 * Returns `true` if every element in `coll` satisfies an async test. If any
 * iteratee call returns `false`, the main `callback` is immediately called.
 *
 * @name every
 * @static
 * @memberOf module:Collections
 * @method
 * @alias all
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async truth test to apply to each item
 * in the collection in parallel.
 * The iteratee must complete with a boolean result value.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Result will be either `true` or `false`
 * depending on the values of the async tests. Invoked with (err, result).
 * @example
 *
 * async.every(['file1','file2','file3'], function(filePath, callback) {
 *     fs.access(filePath, function(err) {
 *         callback(null, !err)
 *     });
 * }, function(err, result) {
 *     // if result is true then every file exists
 * });
 */
var every = doParallel(_createTester(notId, notId));

/**
 * The same as [`every`]{@link module:Collections.every} but runs a maximum of `limit` async operations at a time.
 *
 * @name everyLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.every]{@link module:Collections.every}
 * @alias allLimit
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - An async truth test to apply to each item
 * in the collection in parallel.
 * The iteratee must complete with a boolean result value.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Result will be either `true` or `false`
 * depending on the values of the async tests. Invoked with (err, result).
 */
var everyLimit = doParallelLimit(_createTester(notId, notId));

/**
 * The same as [`every`]{@link module:Collections.every} but runs only a single async operation at a time.
 *
 * @name everySeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.every]{@link module:Collections.every}
 * @alias allSeries
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async truth test to apply to each item
 * in the collection in series.
 * The iteratee must complete with a boolean result value.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Result will be either `true` or `false`
 * depending on the values of the async tests. Invoked with (err, result).
 */
var everySeries = doLimit(everyLimit, 1);

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

function filterArray(eachfn, arr, iteratee, callback) {
    var truthValues = new Array(arr.length);
    eachfn(arr, function (x, index, callback) {
        iteratee(x, function (err, v) {
            truthValues[index] = !!v;
            callback(err);
        });
    }, function (err) {
        if (err) return callback(err);
        var results = [];
        for (var i = 0; i < arr.length; i++) {
            if (truthValues[i]) results.push(arr[i]);
        }
        callback(null, results);
    });
}

function filterGeneric(eachfn, coll, iteratee, callback) {
    var results = [];
    eachfn(coll, function (x, index, callback) {
        iteratee(x, function (err, v) {
            if (err) {
                callback(err);
            } else {
                if (v) {
                    results.push({index: index, value: x});
                }
                callback();
            }
        });
    }, function (err) {
        if (err) {
            callback(err);
        } else {
            callback(null, arrayMap(results.sort(function (a, b) {
                return a.index - b.index;
            }), baseProperty('value')));
        }
    });
}

function _filter(eachfn, coll, iteratee, callback) {
    var filter = isArrayLike(coll) ? filterArray : filterGeneric;
    filter(eachfn, coll, wrapAsync(iteratee), callback || noop);
}

/**
 * Returns a new array of all the values in `coll` which pass an async truth
 * test. This operation is performed in parallel, but the results array will be
 * in the same order as the original.
 *
 * @name filter
 * @static
 * @memberOf module:Collections
 * @method
 * @alias select
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {Function} iteratee - A truth test to apply to each item in `coll`.
 * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
 * with a boolean argument once it has completed. Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Invoked with (err, results).
 * @example
 *
 * async.filter(['file1','file2','file3'], function(filePath, callback) {
 *     fs.access(filePath, function(err) {
 *         callback(null, !err)
 *     });
 * }, function(err, results) {
 *     // results now equals an array of the existing files
 * });
 */
var filter = doParallel(_filter);

/**
 * The same as [`filter`]{@link module:Collections.filter} but runs a maximum of `limit` async operations at a
 * time.
 *
 * @name filterLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.filter]{@link module:Collections.filter}
 * @alias selectLimit
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {Function} iteratee - A truth test to apply to each item in `coll`.
 * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
 * with a boolean argument once it has completed. Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Invoked with (err, results).
 */
var filterLimit = doParallelLimit(_filter);

/**
 * The same as [`filter`]{@link module:Collections.filter} but runs only a single async operation at a time.
 *
 * @name filterSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.filter]{@link module:Collections.filter}
 * @alias selectSeries
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {Function} iteratee - A truth test to apply to each item in `coll`.
 * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
 * with a boolean argument once it has completed. Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Invoked with (err, results)
 */
var filterSeries = doLimit(filterLimit, 1);

/**
 * Calls the asynchronous function `fn` with a callback parameter that allows it
 * to call itself again, in series, indefinitely.

 * If an error is passed to the callback then `errback` is called with the
 * error, and execution stops, otherwise it will never be called.
 *
 * @name forever
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {AsyncFunction} fn - an async function to call repeatedly.
 * Invoked with (next).
 * @param {Function} [errback] - when `fn` passes an error to it's callback,
 * this function will be called, and execution stops. Invoked with (err).
 * @example
 *
 * async.forever(
 *     function(next) {
 *         // next is suitable for passing to things that need a callback(err [, whatever]);
 *         // it will result in this function being called again.
 *     },
 *     function(err) {
 *         // if next is called with a value in its first parameter, it will appear
 *         // in here as 'err', and execution will stop.
 *     }
 * );
 */
function forever(fn, errback) {
    var done = onlyOnce(errback || noop);
    var task = wrapAsync(ensureAsync(fn));

    function next(err) {
        if (err) return done(err);
        task(next);
    }
    next();
}

/**
 * The same as [`groupBy`]{@link module:Collections.groupBy} but runs a maximum of `limit` async operations at a time.
 *
 * @name groupByLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.groupBy]{@link module:Collections.groupBy}
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * The iteratee should complete with a `key` to group the value under.
 * Invoked with (value, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. Result is an `Object` whoses
 * properties are arrays of values which returned the corresponding key.
 */
var groupByLimit = function(coll, limit, iteratee, callback) {
    callback = callback || noop;
    var _iteratee = wrapAsync(iteratee);
    mapLimit(coll, limit, function(val, callback) {
        _iteratee(val, function(err, key) {
            if (err) return callback(err);
            return callback(null, {key: key, val: val});
        });
    }, function(err, mapResults) {
        var result = {};
        // from MDN, handle object having an `hasOwnProperty` prop
        var hasOwnProperty = Object.prototype.hasOwnProperty;

        for (var i = 0; i < mapResults.length; i++) {
            if (mapResults[i]) {
                var key = mapResults[i].key;
                var val = mapResults[i].val;

                if (hasOwnProperty.call(result, key)) {
                    result[key].push(val);
                } else {
                    result[key] = [val];
                }
            }
        }

        return callback(err, result);
    });
};

/**
 * Returns a new object, where each value corresponds to an array of items, from
 * `coll`, that returned the corresponding key. That is, the keys of the object
 * correspond to the values passed to the `iteratee` callback.
 *
 * Note: Since this function applies the `iteratee` to each item in parallel,
 * there is no guarantee that the `iteratee` functions will complete in order.
 * However, the values for each key in the `result` will be in the same order as
 * the original `coll`. For Objects, the values will roughly be in the order of
 * the original Objects' keys (but this can vary across JavaScript engines).
 *
 * @name groupBy
 * @static
 * @memberOf module:Collections
 * @method
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * The iteratee should complete with a `key` to group the value under.
 * Invoked with (value, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. Result is an `Object` whoses
 * properties are arrays of values which returned the corresponding key.
 * @example
 *
 * async.groupBy(['userId1', 'userId2', 'userId3'], function(userId, callback) {
 *     db.findById(userId, function(err, user) {
 *         if (err) return callback(err);
 *         return callback(null, user.age);
 *     });
 * }, function(err, result) {
 *     // result is object containing the userIds grouped by age
 *     // e.g. { 30: ['userId1', 'userId3'], 42: ['userId2']};
 * });
 */
var groupBy = doLimit(groupByLimit, Infinity);

/**
 * The same as [`groupBy`]{@link module:Collections.groupBy} but runs only a single async operation at a time.
 *
 * @name groupBySeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.groupBy]{@link module:Collections.groupBy}
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * The iteratee should complete with a `key` to group the value under.
 * Invoked with (value, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. Result is an `Object` whoses
 * properties are arrays of values which returned the corresponding key.
 */
var groupBySeries = doLimit(groupByLimit, 1);

/**
 * Logs the result of an `async` function to the `console`. Only works in
 * Node.js or in browsers that support `console.log` and `console.error` (such
 * as FF and Chrome). If multiple arguments are returned from the async
 * function, `console.log` is called on each argument in order.
 *
 * @name log
 * @static
 * @memberOf module:Utils
 * @method
 * @category Util
 * @param {AsyncFunction} function - The function you want to eventually apply
 * all arguments to.
 * @param {...*} arguments... - Any number of arguments to apply to the function.
 * @example
 *
 * // in a module
 * var hello = function(name, callback) {
 *     setTimeout(function() {
 *         callback(null, 'hello ' + name);
 *     }, 1000);
 * };
 *
 * // in the node repl
 * node> async.log(hello, 'world');
 * 'hello world'
 */
var log = consoleFunc('log');

/**
 * The same as [`mapValues`]{@link module:Collections.mapValues} but runs a maximum of `limit` async operations at a
 * time.
 *
 * @name mapValuesLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.mapValues]{@link module:Collections.mapValues}
 * @category Collection
 * @param {Object} obj - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - A function to apply to each value and key
 * in `coll`.
 * The iteratee should complete with the transformed value as its result.
 * Invoked with (value, key, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. `result` is a new object consisting
 * of each key from `obj`, with each transformed value on the right-hand side.
 * Invoked with (err, result).
 */
function mapValuesLimit(obj, limit, iteratee, callback) {
    callback = once(callback || noop);
    var newObj = {};
    var _iteratee = wrapAsync(iteratee);
    eachOfLimit(obj, limit, function(val, key, next) {
        _iteratee(val, key, function (err, result) {
            if (err) return next(err);
            newObj[key] = result;
            next();
        });
    }, function (err) {
        callback(err, newObj);
    });
}

/**
 * A relative of [`map`]{@link module:Collections.map}, designed for use with objects.
 *
 * Produces a new Object by mapping each value of `obj` through the `iteratee`
 * function. The `iteratee` is called each `value` and `key` from `obj` and a
 * callback for when it has finished processing. Each of these callbacks takes
 * two arguments: an `error`, and the transformed item from `obj`. If `iteratee`
 * passes an error to its callback, the main `callback` (for the `mapValues`
 * function) is immediately called with the error.
 *
 * Note, the order of the keys in the result is not guaranteed.  The keys will
 * be roughly in the order they complete, (but this is very engine-specific)
 *
 * @name mapValues
 * @static
 * @memberOf module:Collections
 * @method
 * @category Collection
 * @param {Object} obj - A collection to iterate over.
 * @param {AsyncFunction} iteratee - A function to apply to each value and key
 * in `coll`.
 * The iteratee should complete with the transformed value as its result.
 * Invoked with (value, key, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. `result` is a new object consisting
 * of each key from `obj`, with each transformed value on the right-hand side.
 * Invoked with (err, result).
 * @example
 *
 * async.mapValues({
 *     f1: 'file1',
 *     f2: 'file2',
 *     f3: 'file3'
 * }, function (file, key, callback) {
 *   fs.stat(file, callback);
 * }, function(err, result) {
 *     // result is now a map of stats for each file, e.g.
 *     // {
 *     //     f1: [stats for file1],
 *     //     f2: [stats for file2],
 *     //     f3: [stats for file3]
 *     // }
 * });
 */

var mapValues = doLimit(mapValuesLimit, Infinity);

/**
 * The same as [`mapValues`]{@link module:Collections.mapValues} but runs only a single async operation at a time.
 *
 * @name mapValuesSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.mapValues]{@link module:Collections.mapValues}
 * @category Collection
 * @param {Object} obj - A collection to iterate over.
 * @param {AsyncFunction} iteratee - A function to apply to each value and key
 * in `coll`.
 * The iteratee should complete with the transformed value as its result.
 * Invoked with (value, key, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. `result` is a new object consisting
 * of each key from `obj`, with each transformed value on the right-hand side.
 * Invoked with (err, result).
 */
var mapValuesSeries = doLimit(mapValuesLimit, 1);

function has(obj, key) {
    return key in obj;
}

/**
 * Caches the results of an async function. When creating a hash to store
 * function results against, the callback is omitted from the hash and an
 * optional hash function can be used.
 *
 * If no hash function is specified, the first argument is used as a hash key,
 * which may work reasonably if it is a string or a data type that converts to a
 * distinct string. Note that objects and arrays will not behave reasonably.
 * Neither will cases where the other arguments are significant. In such cases,
 * specify your own hash function.
 *
 * The cache of results is exposed as the `memo` property of the function
 * returned by `memoize`.
 *
 * @name memoize
 * @static
 * @memberOf module:Utils
 * @method
 * @category Util
 * @param {AsyncFunction} fn - The async function to proxy and cache results from.
 * @param {Function} hasher - An optional function for generating a custom hash
 * for storing results. It has all the arguments applied to it apart from the
 * callback, and must be synchronous.
 * @returns {AsyncFunction} a memoized version of `fn`
 * @example
 *
 * var slow_fn = function(name, callback) {
 *     // do something
 *     callback(null, result);
 * };
 * var fn = async.memoize(slow_fn);
 *
 * // fn can now be used as if it were slow_fn
 * fn('some name', function() {
 *     // callback
 * });
 */
function memoize(fn, hasher) {
    var memo = Object.create(null);
    var queues = Object.create(null);
    hasher = hasher || identity;
    var _fn = wrapAsync(fn);
    var memoized = initialParams(function memoized(args, callback) {
        var key = hasher.apply(null, args);
        if (has(memo, key)) {
            setImmediate$1(function() {
                callback.apply(null, memo[key]);
            });
        } else if (has(queues, key)) {
            queues[key].push(callback);
        } else {
            queues[key] = [callback];
            _fn.apply(null, args.concat(function(/*args*/) {
                var args = slice(arguments);
                memo[key] = args;
                var q = queues[key];
                delete queues[key];
                for (var i = 0, l = q.length; i < l; i++) {
                    q[i].apply(null, args);
                }
            }));
        }
    });
    memoized.memo = memo;
    memoized.unmemoized = fn;
    return memoized;
}

/**
 * Calls `callback` on a later loop around the event loop. In Node.js this just
 * calls `process.nextTick`.  In the browser it will use `setImmediate` if
 * available, otherwise `setTimeout(callback, 0)`, which means other higher
 * priority events may precede the execution of `callback`.
 *
 * This is used internally for browser-compatibility purposes.
 *
 * @name nextTick
 * @static
 * @memberOf module:Utils
 * @method
 * @see [async.setImmediate]{@link module:Utils.setImmediate}
 * @category Util
 * @param {Function} callback - The function to call on a later loop around
 * the event loop. Invoked with (args...).
 * @param {...*} args... - any number of additional arguments to pass to the
 * callback on the next tick.
 * @example
 *
 * var call_order = [];
 * async.nextTick(function() {
 *     call_order.push('two');
 *     // call_order now equals ['one','two']
 * });
 * call_order.push('one');
 *
 * async.setImmediate(function (a, b, c) {
 *     // a, b, and c equal 1, 2, and 3
 * }, 1, 2, 3);
 */
var _defer$1;

if (hasNextTick) {
    _defer$1 = process.nextTick;
} else if (hasSetImmediate) {
    _defer$1 = setImmediate;
} else {
    _defer$1 = fallback;
}

var nextTick = wrap(_defer$1);

function _parallel(eachfn, tasks, callback) {
    callback = callback || noop;
    var results = isArrayLike(tasks) ? [] : {};

    eachfn(tasks, function (task, key, callback) {
        wrapAsync(task)(function (err, result) {
            if (arguments.length > 2) {
                result = slice(arguments, 1);
            }
            results[key] = result;
            callback(err);
        });
    }, function (err) {
        callback(err, results);
    });
}

/**
 * Run the `tasks` collection of functions in parallel, without waiting until
 * the previous function has completed. If any of the functions pass an error to
 * its callback, the main `callback` is immediately called with the value of the
 * error. Once the `tasks` have completed, the results are passed to the final
 * `callback` as an array.
 *
 * **Note:** `parallel` is about kicking-off I/O tasks in parallel, not about
 * parallel execution of code.  If your tasks do not use any timers or perform
 * any I/O, they will actually be executed in series.  Any synchronous setup
 * sections for each task will happen one after the other.  JavaScript remains
 * single-threaded.
 *
 * **Hint:** Use [`reflect`]{@link module:Utils.reflect} to continue the
 * execution of other tasks when a task fails.
 *
 * It is also possible to use an object instead of an array. Each property will
 * be run as a function and the results will be passed to the final `callback`
 * as an object instead of an array. This can be a more readable way of handling
 * results from {@link async.parallel}.
 *
 * @name parallel
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Array|Iterable|Object} tasks - A collection of
 * [async functions]{@link AsyncFunction} to run.
 * Each async function can complete with any number of optional `result` values.
 * @param {Function} [callback] - An optional callback to run once all the
 * functions have completed successfully. This function gets a results array
 * (or object) containing all the result arguments passed to the task callbacks.
 * Invoked with (err, results).
 *
 * @example
 * async.parallel([
 *     function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'one');
 *         }, 200);
 *     },
 *     function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'two');
 *         }, 100);
 *     }
 * ],
 * // optional callback
 * function(err, results) {
 *     // the results array will equal ['one','two'] even though
 *     // the second function had a shorter timeout.
 * });
 *
 * // an example using an object instead of an array
 * async.parallel({
 *     one: function(callback) {
 *         setTimeout(function() {
 *             callback(null, 1);
 *         }, 200);
 *     },
 *     two: function(callback) {
 *         setTimeout(function() {
 *             callback(null, 2);
 *         }, 100);
 *     }
 * }, function(err, results) {
 *     // results is now equals to: {one: 1, two: 2}
 * });
 */
function parallelLimit(tasks, callback) {
    _parallel(eachOf, tasks, callback);
}

/**
 * The same as [`parallel`]{@link module:ControlFlow.parallel} but runs a maximum of `limit` async operations at a
 * time.
 *
 * @name parallelLimit
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.parallel]{@link module:ControlFlow.parallel}
 * @category Control Flow
 * @param {Array|Iterable|Object} tasks - A collection of
 * [async functions]{@link AsyncFunction} to run.
 * Each async function can complete with any number of optional `result` values.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {Function} [callback] - An optional callback to run once all the
 * functions have completed successfully. This function gets a results array
 * (or object) containing all the result arguments passed to the task callbacks.
 * Invoked with (err, results).
 */
function parallelLimit$1(tasks, limit, callback) {
    _parallel(_eachOfLimit(limit), tasks, callback);
}

/**
 * A queue of tasks for the worker function to complete.
 * @typedef {Object} QueueObject
 * @memberOf module:ControlFlow
 * @property {Function} length - a function returning the number of items
 * waiting to be processed. Invoke with `queue.length()`.
 * @property {boolean} started - a boolean indicating whether or not any
 * items have been pushed and processed by the queue.
 * @property {Function} running - a function returning the number of items
 * currently being processed. Invoke with `queue.running()`.
 * @property {Function} workersList - a function returning the array of items
 * currently being processed. Invoke with `queue.workersList()`.
 * @property {Function} idle - a function returning false if there are items
 * waiting or being processed, or true if not. Invoke with `queue.idle()`.
 * @property {number} concurrency - an integer for determining how many `worker`
 * functions should be run in parallel. This property can be changed after a
 * `queue` is created to alter the concurrency on-the-fly.
 * @property {Function} push - add a new task to the `queue`. Calls `callback`
 * once the `worker` has finished processing the task. Instead of a single task,
 * a `tasks` array can be submitted. The respective callback is used for every
 * task in the list. Invoke with `queue.push(task, [callback])`,
 * @property {Function} unshift - add a new task to the front of the `queue`.
 * Invoke with `queue.unshift(task, [callback])`.
 * @property {Function} remove - remove items from the queue that match a test
 * function.  The test function will be passed an object with a `data` property,
 * and a `priority` property, if this is a
 * [priorityQueue]{@link module:ControlFlow.priorityQueue} object.
 * Invoked with `queue.remove(testFn)`, where `testFn` is of the form
 * `function ({data, priority}) {}` and returns a Boolean.
 * @property {Function} saturated - a callback that is called when the number of
 * running workers hits the `concurrency` limit, and further tasks will be
 * queued.
 * @property {Function} unsaturated - a callback that is called when the number
 * of running workers is less than the `concurrency` & `buffer` limits, and
 * further tasks will not be queued.
 * @property {number} buffer - A minimum threshold buffer in order to say that
 * the `queue` is `unsaturated`.
 * @property {Function} empty - a callback that is called when the last item
 * from the `queue` is given to a `worker`.
 * @property {Function} drain - a callback that is called when the last item
 * from the `queue` has returned from the `worker`.
 * @property {Function} error - a callback that is called when a task errors.
 * Has the signature `function(error, task)`.
 * @property {boolean} paused - a boolean for determining whether the queue is
 * in a paused state.
 * @property {Function} pause - a function that pauses the processing of tasks
 * until `resume()` is called. Invoke with `queue.pause()`.
 * @property {Function} resume - a function that resumes the processing of
 * queued tasks when the queue is paused. Invoke with `queue.resume()`.
 * @property {Function} kill - a function that removes the `drain` callback and
 * empties remaining tasks from the queue forcing it to go idle. No more tasks
 * should be pushed to the queue after calling this function. Invoke with `queue.kill()`.
 */

/**
 * Creates a `queue` object with the specified `concurrency`. Tasks added to the
 * `queue` are processed in parallel (up to the `concurrency` limit). If all
 * `worker`s are in progress, the task is queued until one becomes available.
 * Once a `worker` completes a `task`, that `task`'s callback is called.
 *
 * @name queue
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {AsyncFunction} worker - An async function for processing a queued task.
 * If you want to handle errors from an individual task, pass a callback to
 * `q.push()`. Invoked with (task, callback).
 * @param {number} [concurrency=1] - An `integer` for determining how many
 * `worker` functions should be run in parallel.  If omitted, the concurrency
 * defaults to `1`.  If the concurrency is `0`, an error is thrown.
 * @returns {module:ControlFlow.QueueObject} A queue object to manage the tasks. Callbacks can
 * attached as certain properties to listen for specific events during the
 * lifecycle of the queue.
 * @example
 *
 * // create a queue object with concurrency 2
 * var q = async.queue(function(task, callback) {
 *     console.log('hello ' + task.name);
 *     callback();
 * }, 2);
 *
 * // assign a callback
 * q.drain = function() {
 *     console.log('all items have been processed');
 * };
 *
 * // add some items to the queue
 * q.push({name: 'foo'}, function(err) {
 *     console.log('finished processing foo');
 * });
 * q.push({name: 'bar'}, function (err) {
 *     console.log('finished processing bar');
 * });
 *
 * // add some items to the queue (batch-wise)
 * q.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function(err) {
 *     console.log('finished processing item');
 * });
 *
 * // add some items to the front of the queue
 * q.unshift({name: 'bar'}, function (err) {
 *     console.log('finished processing bar');
 * });
 */
var queue$1 = function (worker, concurrency) {
    var _worker = wrapAsync(worker);
    return queue(function (items, cb) {
        _worker(items[0], cb);
    }, concurrency, 1);
};

/**
 * The same as [async.queue]{@link module:ControlFlow.queue} only tasks are assigned a priority and
 * completed in ascending priority order.
 *
 * @name priorityQueue
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.queue]{@link module:ControlFlow.queue}
 * @category Control Flow
 * @param {AsyncFunction} worker - An async function for processing a queued task.
 * If you want to handle errors from an individual task, pass a callback to
 * `q.push()`.
 * Invoked with (task, callback).
 * @param {number} concurrency - An `integer` for determining how many `worker`
 * functions should be run in parallel.  If omitted, the concurrency defaults to
 * `1`.  If the concurrency is `0`, an error is thrown.
 * @returns {module:ControlFlow.QueueObject} A priorityQueue object to manage the tasks. There are two
 * differences between `queue` and `priorityQueue` objects:
 * * `push(task, priority, [callback])` - `priority` should be a number. If an
 *   array of `tasks` is given, all tasks will be assigned the same priority.
 * * The `unshift` method was removed.
 */
var priorityQueue = function(worker, concurrency) {
    // Start with a normal queue
    var q = queue$1(worker, concurrency);

    // Override push to accept second parameter representing priority
    q.push = function(data, priority, callback) {
        if (callback == null) callback = noop;
        if (typeof callback !== 'function') {
            throw new Error('task callback must be a function');
        }
        q.started = true;
        if (!isArray(data)) {
            data = [data];
        }
        if (data.length === 0) {
            // call drain immediately if there are no tasks
            return setImmediate$1(function() {
                q.drain();
            });
        }

        priority = priority || 0;
        var nextNode = q._tasks.head;
        while (nextNode && priority >= nextNode.priority) {
            nextNode = nextNode.next;
        }

        for (var i = 0, l = data.length; i < l; i++) {
            var item = {
                data: data[i],
                priority: priority,
                callback: callback
            };

            if (nextNode) {
                q._tasks.insertBefore(nextNode, item);
            } else {
                q._tasks.push(item);
            }
        }
        setImmediate$1(q.process);
    };

    // Remove unshift function
    delete q.unshift;

    return q;
};

/**
 * Runs the `tasks` array of functions in parallel, without waiting until the
 * previous function has completed. Once any of the `tasks` complete or pass an
 * error to its callback, the main `callback` is immediately called. It's
 * equivalent to `Promise.race()`.
 *
 * @name race
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Array} tasks - An array containing [async functions]{@link AsyncFunction}
 * to run. Each function can complete with an optional `result` value.
 * @param {Function} callback - A callback to run once any of the functions have
 * completed. This function gets an error or result from the first function that
 * completed. Invoked with (err, result).
 * @returns undefined
 * @example
 *
 * async.race([
 *     function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'one');
 *         }, 200);
 *     },
 *     function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'two');
 *         }, 100);
 *     }
 * ],
 * // main callback
 * function(err, result) {
 *     // the result will be equal to 'two' as it finishes earlier
 * });
 */
function race(tasks, callback) {
    callback = once(callback || noop);
    if (!isArray(tasks)) return callback(new TypeError('First argument to race must be an array of functions'));
    if (!tasks.length) return callback();
    for (var i = 0, l = tasks.length; i < l; i++) {
        wrapAsync(tasks[i])(callback);
    }
}

/**
 * Same as [`reduce`]{@link module:Collections.reduce}, only operates on `array` in reverse order.
 *
 * @name reduceRight
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.reduce]{@link module:Collections.reduce}
 * @alias foldr
 * @category Collection
 * @param {Array} array - A collection to iterate over.
 * @param {*} memo - The initial state of the reduction.
 * @param {AsyncFunction} iteratee - A function applied to each item in the
 * array to produce the next step in the reduction.
 * The `iteratee` should complete with the next state of the reduction.
 * If the iteratee complete with an error, the reduction is stopped and the
 * main `callback` is immediately called with the error.
 * Invoked with (memo, item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Result is the reduced value. Invoked with
 * (err, result).
 */
function reduceRight (array, memo, iteratee, callback) {
    var reversed = slice(array).reverse();
    reduce(reversed, memo, iteratee, callback);
}

/**
 * Wraps the async function in another function that always completes with a
 * result object, even when it errors.
 *
 * The result object has either the property `error` or `value`.
 *
 * @name reflect
 * @static
 * @memberOf module:Utils
 * @method
 * @category Util
 * @param {AsyncFunction} fn - The async function you want to wrap
 * @returns {Function} - A function that always passes null to it's callback as
 * the error. The second argument to the callback will be an `object` with
 * either an `error` or a `value` property.
 * @example
 *
 * async.parallel([
 *     async.reflect(function(callback) {
 *         // do some stuff ...
 *         callback(null, 'one');
 *     }),
 *     async.reflect(function(callback) {
 *         // do some more stuff but error ...
 *         callback('bad stuff happened');
 *     }),
 *     async.reflect(function(callback) {
 *         // do some more stuff ...
 *         callback(null, 'two');
 *     })
 * ],
 * // optional callback
 * function(err, results) {
 *     // values
 *     // results[0].value = 'one'
 *     // results[1].error = 'bad stuff happened'
 *     // results[2].value = 'two'
 * });
 */
function reflect(fn) {
    var _fn = wrapAsync(fn);
    return initialParams(function reflectOn(args, reflectCallback) {
        args.push(function callback(error, cbArg) {
            if (error) {
                reflectCallback(null, { error: error });
            } else {
                var value;
                if (arguments.length <= 2) {
                    value = cbArg;
                } else {
                    value = slice(arguments, 1);
                }
                reflectCallback(null, { value: value });
            }
        });

        return _fn.apply(this, args);
    });
}

/**
 * A helper function that wraps an array or an object of functions with `reflect`.
 *
 * @name reflectAll
 * @static
 * @memberOf module:Utils
 * @method
 * @see [async.reflect]{@link module:Utils.reflect}
 * @category Util
 * @param {Array|Object|Iterable} tasks - The collection of
 * [async functions]{@link AsyncFunction} to wrap in `async.reflect`.
 * @returns {Array} Returns an array of async functions, each wrapped in
 * `async.reflect`
 * @example
 *
 * let tasks = [
 *     function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'one');
 *         }, 200);
 *     },
 *     function(callback) {
 *         // do some more stuff but error ...
 *         callback(new Error('bad stuff happened'));
 *     },
 *     function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'two');
 *         }, 100);
 *     }
 * ];
 *
 * async.parallel(async.reflectAll(tasks),
 * // optional callback
 * function(err, results) {
 *     // values
 *     // results[0].value = 'one'
 *     // results[1].error = Error('bad stuff happened')
 *     // results[2].value = 'two'
 * });
 *
 * // an example using an object instead of an array
 * let tasks = {
 *     one: function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'one');
 *         }, 200);
 *     },
 *     two: function(callback) {
 *         callback('two');
 *     },
 *     three: function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'three');
 *         }, 100);
 *     }
 * };
 *
 * async.parallel(async.reflectAll(tasks),
 * // optional callback
 * function(err, results) {
 *     // values
 *     // results.one.value = 'one'
 *     // results.two.error = 'two'
 *     // results.three.value = 'three'
 * });
 */
function reflectAll(tasks) {
    var results;
    if (isArray(tasks)) {
        results = arrayMap(tasks, reflect);
    } else {
        results = {};
        baseForOwn(tasks, function(task, key) {
            results[key] = reflect.call(this, task);
        });
    }
    return results;
}

function reject$1(eachfn, arr, iteratee, callback) {
    _filter(eachfn, arr, function(value, cb) {
        iteratee(value, function(err, v) {
            cb(err, !v);
        });
    }, callback);
}

/**
 * The opposite of [`filter`]{@link module:Collections.filter}. Removes values that pass an `async` truth test.
 *
 * @name reject
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.filter]{@link module:Collections.filter}
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {Function} iteratee - An async truth test to apply to each item in
 * `coll`.
 * The should complete with a boolean value as its `result`.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Invoked with (err, results).
 * @example
 *
 * async.reject(['file1','file2','file3'], function(filePath, callback) {
 *     fs.access(filePath, function(err) {
 *         callback(null, !err)
 *     });
 * }, function(err, results) {
 *     // results now equals an array of missing files
 *     createFiles(results);
 * });
 */
var reject = doParallel(reject$1);

/**
 * The same as [`reject`]{@link module:Collections.reject} but runs a maximum of `limit` async operations at a
 * time.
 *
 * @name rejectLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.reject]{@link module:Collections.reject}
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {Function} iteratee - An async truth test to apply to each item in
 * `coll`.
 * The should complete with a boolean value as its `result`.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Invoked with (err, results).
 */
var rejectLimit = doParallelLimit(reject$1);

/**
 * The same as [`reject`]{@link module:Collections.reject} but runs only a single async operation at a time.
 *
 * @name rejectSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.reject]{@link module:Collections.reject}
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {Function} iteratee - An async truth test to apply to each item in
 * `coll`.
 * The should complete with a boolean value as its `result`.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Invoked with (err, results).
 */
var rejectSeries = doLimit(rejectLimit, 1);

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant$1(value) {
  return function() {
    return value;
  };
}

/**
 * Attempts to get a successful response from `task` no more than `times` times
 * before returning an error. If the task is successful, the `callback` will be
 * passed the result of the successful task. If all attempts fail, the callback
 * will be passed the error and result (if any) of the final attempt.
 *
 * @name retry
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @see [async.retryable]{@link module:ControlFlow.retryable}
 * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - Can be either an
 * object with `times` and `interval` or a number.
 * * `times` - The number of attempts to make before giving up.  The default
 *   is `5`.
 * * `interval` - The time to wait between retries, in milliseconds.  The
 *   default is `0`. The interval may also be specified as a function of the
 *   retry count (see example).
 * * `errorFilter` - An optional synchronous function that is invoked on
 *   erroneous result. If it returns `true` the retry attempts will continue;
 *   if the function returns `false` the retry flow is aborted with the current
 *   attempt's error and result being returned to the final callback.
 *   Invoked with (err).
 * * If `opts` is a number, the number specifies the number of times to retry,
 *   with the default interval of `0`.
 * @param {AsyncFunction} task - An async function to retry.
 * Invoked with (callback).
 * @param {Function} [callback] - An optional callback which is called when the
 * task has succeeded, or after the final failed attempt. It receives the `err`
 * and `result` arguments of the last attempt at completing the `task`. Invoked
 * with (err, results).
 *
 * @example
 *
 * // The `retry` function can be used as a stand-alone control flow by passing
 * // a callback, as shown below:
 *
 * // try calling apiMethod 3 times
 * async.retry(3, apiMethod, function(err, result) {
 *     // do something with the result
 * });
 *
 * // try calling apiMethod 3 times, waiting 200 ms between each retry
 * async.retry({times: 3, interval: 200}, apiMethod, function(err, result) {
 *     // do something with the result
 * });
 *
 * // try calling apiMethod 10 times with exponential backoff
 * // (i.e. intervals of 100, 200, 400, 800, 1600, ... milliseconds)
 * async.retry({
 *   times: 10,
 *   interval: function(retryCount) {
 *     return 50 * Math.pow(2, retryCount);
 *   }
 * }, apiMethod, function(err, result) {
 *     // do something with the result
 * });
 *
 * // try calling apiMethod the default 5 times no delay between each retry
 * async.retry(apiMethod, function(err, result) {
 *     // do something with the result
 * });
 *
 * // try calling apiMethod only when error condition satisfies, all other
 * // errors will abort the retry control flow and return to final callback
 * async.retry({
 *   errorFilter: function(err) {
 *     return err.message === 'Temporary error'; // only retry on a specific error
 *   }
 * }, apiMethod, function(err, result) {
 *     // do something with the result
 * });
 *
 * // to retry individual methods that are not as reliable within other
 * // control flow functions, use the `retryable` wrapper:
 * async.auto({
 *     users: api.getUsers.bind(api),
 *     payments: async.retryable(3, api.getPayments.bind(api))
 * }, function(err, results) {
 *     // do something with the results
 * });
 *
 */
function retry(opts, task, callback) {
    var DEFAULT_TIMES = 5;
    var DEFAULT_INTERVAL = 0;

    var options = {
        times: DEFAULT_TIMES,
        intervalFunc: constant$1(DEFAULT_INTERVAL)
    };

    function parseTimes(acc, t) {
        if (typeof t === 'object') {
            acc.times = +t.times || DEFAULT_TIMES;

            acc.intervalFunc = typeof t.interval === 'function' ?
                t.interval :
                constant$1(+t.interval || DEFAULT_INTERVAL);

            acc.errorFilter = t.errorFilter;
        } else if (typeof t === 'number' || typeof t === 'string') {
            acc.times = +t || DEFAULT_TIMES;
        } else {
            throw new Error("Invalid arguments for async.retry");
        }
    }

    if (arguments.length < 3 && typeof opts === 'function') {
        callback = task || noop;
        task = opts;
    } else {
        parseTimes(options, opts);
        callback = callback || noop;
    }

    if (typeof task !== 'function') {
        throw new Error("Invalid arguments for async.retry");
    }

    var _task = wrapAsync(task);

    var attempt = 1;
    function retryAttempt() {
        _task(function(err) {
            if (err && attempt++ < options.times &&
                (typeof options.errorFilter != 'function' ||
                    options.errorFilter(err))) {
                setTimeout(retryAttempt, options.intervalFunc(attempt));
            } else {
                callback.apply(null, arguments);
            }
        });
    }

    retryAttempt();
}

/**
 * A close relative of [`retry`]{@link module:ControlFlow.retry}.  This method
 * wraps a task and makes it retryable, rather than immediately calling it
 * with retries.
 *
 * @name retryable
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.retry]{@link module:ControlFlow.retry}
 * @category Control Flow
 * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - optional
 * options, exactly the same as from `retry`
 * @param {AsyncFunction} task - the asynchronous function to wrap.
 * This function will be passed any arguments passed to the returned wrapper.
 * Invoked with (...args, callback).
 * @returns {AsyncFunction} The wrapped function, which when invoked, will
 * retry on an error, based on the parameters specified in `opts`.
 * This function will accept the same parameters as `task`.
 * @example
 *
 * async.auto({
 *     dep1: async.retryable(3, getFromFlakyService),
 *     process: ["dep1", async.retryable(3, function (results, cb) {
 *         maybeProcessData(results.dep1, cb);
 *     })]
 * }, callback);
 */
var retryable = function (opts, task) {
    if (!task) {
        task = opts;
        opts = null;
    }
    var _task = wrapAsync(task);
    return initialParams(function (args, callback) {
        function taskFn(cb) {
            _task.apply(null, args.concat(cb));
        }

        if (opts) retry(opts, taskFn, callback);
        else retry(taskFn, callback);

    });
};

/**
 * Run the functions in the `tasks` collection in series, each one running once
 * the previous function has completed. If any functions in the series pass an
 * error to its callback, no more functions are run, and `callback` is
 * immediately called with the value of the error. Otherwise, `callback`
 * receives an array of results when `tasks` have completed.
 *
 * It is also possible to use an object instead of an array. Each property will
 * be run as a function, and the results will be passed to the final `callback`
 * as an object instead of an array. This can be a more readable way of handling
 *  results from {@link async.series}.
 *
 * **Note** that while many implementations preserve the order of object
 * properties, the [ECMAScript Language Specification](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6)
 * explicitly states that
 *
 * > The mechanics and order of enumerating the properties is not specified.
 *
 * So if you rely on the order in which your series of functions are executed,
 * and want this to work on all platforms, consider using an array.
 *
 * @name series
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Array|Iterable|Object} tasks - A collection containing
 * [async functions]{@link AsyncFunction} to run in series.
 * Each function can complete with any number of optional `result` values.
 * @param {Function} [callback] - An optional callback to run once all the
 * functions have completed. This function gets a results array (or object)
 * containing all the result arguments passed to the `task` callbacks. Invoked
 * with (err, result).
 * @example
 * async.series([
 *     function(callback) {
 *         // do some stuff ...
 *         callback(null, 'one');
 *     },
 *     function(callback) {
 *         // do some more stuff ...
 *         callback(null, 'two');
 *     }
 * ],
 * // optional callback
 * function(err, results) {
 *     // results is now equal to ['one', 'two']
 * });
 *
 * async.series({
 *     one: function(callback) {
 *         setTimeout(function() {
 *             callback(null, 1);
 *         }, 200);
 *     },
 *     two: function(callback){
 *         setTimeout(function() {
 *             callback(null, 2);
 *         }, 100);
 *     }
 * }, function(err, results) {
 *     // results is now equal to: {one: 1, two: 2}
 * });
 */
function series(tasks, callback) {
    _parallel(eachOfSeries, tasks, callback);
}

/**
 * Returns `true` if at least one element in the `coll` satisfies an async test.
 * If any iteratee call returns `true`, the main `callback` is immediately
 * called.
 *
 * @name some
 * @static
 * @memberOf module:Collections
 * @method
 * @alias any
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async truth test to apply to each item
 * in the collections in parallel.
 * The iteratee should complete with a boolean `result` value.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called as soon as any
 * iteratee returns `true`, or after all the iteratee functions have finished.
 * Result will be either `true` or `false` depending on the values of the async
 * tests. Invoked with (err, result).
 * @example
 *
 * async.some(['file1','file2','file3'], function(filePath, callback) {
 *     fs.access(filePath, function(err) {
 *         callback(null, !err)
 *     });
 * }, function(err, result) {
 *     // if result is true then at least one of the files exists
 * });
 */
var some = doParallel(_createTester(Boolean, identity));

/**
 * The same as [`some`]{@link module:Collections.some} but runs a maximum of `limit` async operations at a time.
 *
 * @name someLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.some]{@link module:Collections.some}
 * @alias anyLimit
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - An async truth test to apply to each item
 * in the collections in parallel.
 * The iteratee should complete with a boolean `result` value.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called as soon as any
 * iteratee returns `true`, or after all the iteratee functions have finished.
 * Result will be either `true` or `false` depending on the values of the async
 * tests. Invoked with (err, result).
 */
var someLimit = doParallelLimit(_createTester(Boolean, identity));

/**
 * The same as [`some`]{@link module:Collections.some} but runs only a single async operation at a time.
 *
 * @name someSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.some]{@link module:Collections.some}
 * @alias anySeries
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async truth test to apply to each item
 * in the collections in series.
 * The iteratee should complete with a boolean `result` value.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called as soon as any
 * iteratee returns `true`, or after all the iteratee functions have finished.
 * Result will be either `true` or `false` depending on the values of the async
 * tests. Invoked with (err, result).
 */
var someSeries = doLimit(someLimit, 1);

/**
 * Sorts a list by the results of running each `coll` value through an async
 * `iteratee`.
 *
 * @name sortBy
 * @static
 * @memberOf module:Collections
 * @method
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * The iteratee should complete with a value to use as the sort criteria as
 * its `result`.
 * Invoked with (item, callback).
 * @param {Function} callback - A callback which is called after all the
 * `iteratee` functions have finished, or an error occurs. Results is the items
 * from the original `coll` sorted by the values returned by the `iteratee`
 * calls. Invoked with (err, results).
 * @example
 *
 * async.sortBy(['file1','file2','file3'], function(file, callback) {
 *     fs.stat(file, function(err, stats) {
 *         callback(err, stats.mtime);
 *     });
 * }, function(err, results) {
 *     // results is now the original array of files sorted by
 *     // modified date
 * });
 *
 * // By modifying the callback parameter the
 * // sorting order can be influenced:
 *
 * // ascending order
 * async.sortBy([1,9,3,5], function(x, callback) {
 *     callback(null, x);
 * }, function(err,result) {
 *     // result callback
 * });
 *
 * // descending order
 * async.sortBy([1,9,3,5], function(x, callback) {
 *     callback(null, x*-1);    //<- x*-1 instead of x, turns the order around
 * }, function(err,result) {
 *     // result callback
 * });
 */
function sortBy (coll, iteratee, callback) {
    var _iteratee = wrapAsync(iteratee);
    map(coll, function (x, callback) {
        _iteratee(x, function (err, criteria) {
            if (err) return callback(err);
            callback(null, {value: x, criteria: criteria});
        });
    }, function (err, results) {
        if (err) return callback(err);
        callback(null, arrayMap(results.sort(comparator), baseProperty('value')));
    });

    function comparator(left, right) {
        var a = left.criteria, b = right.criteria;
        return a < b ? -1 : a > b ? 1 : 0;
    }
}

/**
 * Sets a time limit on an asynchronous function. If the function does not call
 * its callback within the specified milliseconds, it will be called with a
 * timeout error. The code property for the error object will be `'ETIMEDOUT'`.
 *
 * @name timeout
 * @static
 * @memberOf module:Utils
 * @method
 * @category Util
 * @param {AsyncFunction} asyncFn - The async function to limit in time.
 * @param {number} milliseconds - The specified time limit.
 * @param {*} [info] - Any variable you want attached (`string`, `object`, etc)
 * to timeout Error for more information..
 * @returns {AsyncFunction} Returns a wrapped function that can be used with any
 * of the control flow functions.
 * Invoke this function with the same parameters as you would `asyncFunc`.
 * @example
 *
 * function myFunction(foo, callback) {
 *     doAsyncTask(foo, function(err, data) {
 *         // handle errors
 *         if (err) return callback(err);
 *
 *         // do some stuff ...
 *
 *         // return processed data
 *         return callback(null, data);
 *     });
 * }
 *
 * var wrapped = async.timeout(myFunction, 1000);
 *
 * // call `wrapped` as you would `myFunction`
 * wrapped({ bar: 'bar' }, function(err, data) {
 *     // if `myFunction` takes < 1000 ms to execute, `err`
 *     // and `data` will have their expected values
 *
 *     // else `err` will be an Error with the code 'ETIMEDOUT'
 * });
 */
function timeout(asyncFn, milliseconds, info) {
    var fn = wrapAsync(asyncFn);

    return initialParams(function (args, callback) {
        var timedOut = false;
        var timer;

        function timeoutCallback() {
            var name = asyncFn.name || 'anonymous';
            var error  = new Error('Callback function "' + name + '" timed out.');
            error.code = 'ETIMEDOUT';
            if (info) {
                error.info = info;
            }
            timedOut = true;
            callback(error);
        }

        args.push(function () {
            if (!timedOut) {
                callback.apply(null, arguments);
                clearTimeout(timer);
            }
        });

        // setup timer and call original function
        timer = setTimeout(timeoutCallback, milliseconds);
        fn.apply(null, args);
    });
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeCeil = Math.ceil;
var nativeMax = Math.max;

/**
 * The base implementation of `_.range` and `_.rangeRight` which doesn't
 * coerce arguments.
 *
 * @private
 * @param {number} start The start of the range.
 * @param {number} end The end of the range.
 * @param {number} step The value to increment or decrement by.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Array} Returns the range of numbers.
 */
function baseRange(start, end, step, fromRight) {
  var index = -1,
      length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
      result = Array(length);

  while (length--) {
    result[fromRight ? length : ++index] = start;
    start += step;
  }
  return result;
}

/**
 * The same as [times]{@link module:ControlFlow.times} but runs a maximum of `limit` async operations at a
 * time.
 *
 * @name timesLimit
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.times]{@link module:ControlFlow.times}
 * @category Control Flow
 * @param {number} count - The number of times to run the function.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - The async function to call `n` times.
 * Invoked with the iteration index and a callback: (n, next).
 * @param {Function} callback - see [async.map]{@link module:Collections.map}.
 */
function timeLimit(count, limit, iteratee, callback) {
    var _iteratee = wrapAsync(iteratee);
    mapLimit(baseRange(0, count, 1), limit, _iteratee, callback);
}

/**
 * Calls the `iteratee` function `n` times, and accumulates results in the same
 * manner you would use with [map]{@link module:Collections.map}.
 *
 * @name times
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.map]{@link module:Collections.map}
 * @category Control Flow
 * @param {number} n - The number of times to run the function.
 * @param {AsyncFunction} iteratee - The async function to call `n` times.
 * Invoked with the iteration index and a callback: (n, next).
 * @param {Function} callback - see {@link module:Collections.map}.
 * @example
 *
 * // Pretend this is some complicated async factory
 * var createUser = function(id, callback) {
 *     callback(null, {
 *         id: 'user' + id
 *     });
 * };
 *
 * // generate 5 users
 * async.times(5, function(n, next) {
 *     createUser(n, function(err, user) {
 *         next(err, user);
 *     });
 * }, function(err, users) {
 *     // we should now have 5 users
 * });
 */
var times = doLimit(timeLimit, Infinity);

/**
 * The same as [times]{@link module:ControlFlow.times} but runs only a single async operation at a time.
 *
 * @name timesSeries
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.times]{@link module:ControlFlow.times}
 * @category Control Flow
 * @param {number} n - The number of times to run the function.
 * @param {AsyncFunction} iteratee - The async function to call `n` times.
 * Invoked with the iteration index and a callback: (n, next).
 * @param {Function} callback - see {@link module:Collections.map}.
 */
var timesSeries = doLimit(timeLimit, 1);

/**
 * A relative of `reduce`.  Takes an Object or Array, and iterates over each
 * element in series, each step potentially mutating an `accumulator` value.
 * The type of the accumulator defaults to the type of collection passed in.
 *
 * @name transform
 * @static
 * @memberOf module:Collections
 * @method
 * @category Collection
 * @param {Array|Iterable|Object} coll - A collection to iterate over.
 * @param {*} [accumulator] - The initial state of the transform.  If omitted,
 * it will default to an empty Object or Array, depending on the type of `coll`
 * @param {AsyncFunction} iteratee - A function applied to each item in the
 * collection that potentially modifies the accumulator.
 * Invoked with (accumulator, item, key, callback).
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Result is the transformed accumulator.
 * Invoked with (err, result).
 * @example
 *
 * async.transform([1,2,3], function(acc, item, index, callback) {
 *     // pointless async:
 *     process.nextTick(function() {
 *         acc.push(item * 2)
 *         callback(null)
 *     });
 * }, function(err, result) {
 *     // result is now equal to [2, 4, 6]
 * });
 *
 * @example
 *
 * async.transform({a: 1, b: 2, c: 3}, function (obj, val, key, callback) {
 *     setImmediate(function () {
 *         obj[key] = val * 2;
 *         callback();
 *     })
 * }, function (err, result) {
 *     // result is equal to {a: 2, b: 4, c: 6}
 * })
 */
function transform (coll, accumulator, iteratee, callback) {
    if (arguments.length <= 3) {
        callback = iteratee;
        iteratee = accumulator;
        accumulator = isArray(coll) ? [] : {};
    }
    callback = once(callback || noop);
    var _iteratee = wrapAsync(iteratee);

    eachOf(coll, function(v, k, cb) {
        _iteratee(accumulator, v, k, cb);
    }, function(err) {
        callback(err, accumulator);
    });
}

/**
 * It runs each task in series but stops whenever any of the functions were
 * successful. If one of the tasks were successful, the `callback` will be
 * passed the result of the successful task. If all tasks fail, the callback
 * will be passed the error and result (if any) of the final attempt.
 *
 * @name tryEach
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Array|Iterable|Object} tasks - A collection containing functions to
 * run, each function is passed a `callback(err, result)` it must call on
 * completion with an error `err` (which can be `null`) and an optional `result`
 * value.
 * @param {Function} [callback] - An optional callback which is called when one
 * of the tasks has succeeded, or all have failed. It receives the `err` and
 * `result` arguments of the last attempt at completing the `task`. Invoked with
 * (err, results).
 * @example
 * async.tryEach([
 *     function getDataFromFirstWebsite(callback) {
 *         // Try getting the data from the first website
 *         callback(err, data);
 *     },
 *     function getDataFromSecondWebsite(callback) {
 *         // First website failed,
 *         // Try getting the data from the backup website
 *         callback(err, data);
 *     }
 * ],
 * // optional callback
 * function(err, results) {
 *     Now do something with the data.
 * });
 *
 */
function tryEach(tasks, callback) {
    var error = null;
    var result;
    callback = callback || noop;
    eachSeries(tasks, function(task, callback) {
        wrapAsync(task)(function (err, res/*, ...args*/) {
            if (arguments.length > 2) {
                result = slice(arguments, 1);
            } else {
                result = res;
            }
            error = err;
            callback(!err);
        });
    }, function () {
        callback(error, result);
    });
}

/**
 * Undoes a [memoize]{@link module:Utils.memoize}d function, reverting it to the original,
 * unmemoized form. Handy for testing.
 *
 * @name unmemoize
 * @static
 * @memberOf module:Utils
 * @method
 * @see [async.memoize]{@link module:Utils.memoize}
 * @category Util
 * @param {AsyncFunction} fn - the memoized function
 * @returns {AsyncFunction} a function that calls the original unmemoized function
 */
function unmemoize(fn) {
    return function () {
        return (fn.unmemoized || fn).apply(null, arguments);
    };
}

/**
 * Repeatedly call `iteratee`, while `test` returns `true`. Calls `callback` when
 * stopped, or an error occurs.
 *
 * @name whilst
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Function} test - synchronous truth test to perform before each
 * execution of `iteratee`. Invoked with ().
 * @param {AsyncFunction} iteratee - An async function which is called each time
 * `test` passes. Invoked with (callback).
 * @param {Function} [callback] - A callback which is called after the test
 * function has failed and repeated execution of `iteratee` has stopped. `callback`
 * will be passed an error and any arguments passed to the final `iteratee`'s
 * callback. Invoked with (err, [results]);
 * @returns undefined
 * @example
 *
 * var count = 0;
 * async.whilst(
 *     function() { return count < 5; },
 *     function(callback) {
 *         count++;
 *         setTimeout(function() {
 *             callback(null, count);
 *         }, 1000);
 *     },
 *     function (err, n) {
 *         // 5 seconds have passed, n = 5
 *     }
 * );
 */
function whilst(test, iteratee, callback) {
    callback = onlyOnce(callback || noop);
    var _iteratee = wrapAsync(iteratee);
    if (!test()) return callback(null);
    var next = function(err/*, ...args*/) {
        if (err) return callback(err);
        if (test()) return _iteratee(next);
        var args = slice(arguments, 1);
        callback.apply(null, [null].concat(args));
    };
    _iteratee(next);
}

/**
 * Repeatedly call `iteratee` until `test` returns `true`. Calls `callback` when
 * stopped, or an error occurs. `callback` will be passed an error and any
 * arguments passed to the final `iteratee`'s callback.
 *
 * The inverse of [whilst]{@link module:ControlFlow.whilst}.
 *
 * @name until
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @see [async.whilst]{@link module:ControlFlow.whilst}
 * @category Control Flow
 * @param {Function} test - synchronous truth test to perform before each
 * execution of `iteratee`. Invoked with ().
 * @param {AsyncFunction} iteratee - An async function which is called each time
 * `test` fails. Invoked with (callback).
 * @param {Function} [callback] - A callback which is called after the test
 * function has passed and repeated execution of `iteratee` has stopped. `callback`
 * will be passed an error and any arguments passed to the final `iteratee`'s
 * callback. Invoked with (err, [results]);
 */
function until(test, iteratee, callback) {
    whilst(function() {
        return !test.apply(this, arguments);
    }, iteratee, callback);
}

/**
 * Runs the `tasks` array of functions in series, each passing their results to
 * the next in the array. However, if any of the `tasks` pass an error to their
 * own callback, the next function is not executed, and the main `callback` is
 * immediately called with the error.
 *
 * @name waterfall
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Array} tasks - An array of [async functions]{@link AsyncFunction}
 * to run.
 * Each function should complete with any number of `result` values.
 * The `result` values will be passed as arguments, in order, to the next task.
 * @param {Function} [callback] - An optional callback to run once all the
 * functions have completed. This will be passed the results of the last task's
 * callback. Invoked with (err, [results]).
 * @returns undefined
 * @example
 *
 * async.waterfall([
 *     function(callback) {
 *         callback(null, 'one', 'two');
 *     },
 *     function(arg1, arg2, callback) {
 *         // arg1 now equals 'one' and arg2 now equals 'two'
 *         callback(null, 'three');
 *     },
 *     function(arg1, callback) {
 *         // arg1 now equals 'three'
 *         callback(null, 'done');
 *     }
 * ], function (err, result) {
 *     // result now equals 'done'
 * });
 *
 * // Or, with named functions:
 * async.waterfall([
 *     myFirstFunction,
 *     mySecondFunction,
 *     myLastFunction,
 * ], function (err, result) {
 *     // result now equals 'done'
 * });
 * function myFirstFunction(callback) {
 *     callback(null, 'one', 'two');
 * }
 * function mySecondFunction(arg1, arg2, callback) {
 *     // arg1 now equals 'one' and arg2 now equals 'two'
 *     callback(null, 'three');
 * }
 * function myLastFunction(arg1, callback) {
 *     // arg1 now equals 'three'
 *     callback(null, 'done');
 * }
 */
var waterfall = function(tasks, callback) {
    callback = once(callback || noop);
    if (!isArray(tasks)) return callback(new Error('First argument to waterfall must be an array of functions'));
    if (!tasks.length) return callback();
    var taskIndex = 0;

    function nextTask(args) {
        var task = wrapAsync(tasks[taskIndex++]);
        args.push(onlyOnce(next));
        task.apply(null, args);
    }

    function next(err/*, ...args*/) {
        if (err || taskIndex === tasks.length) {
            return callback.apply(null, arguments);
        }
        nextTask(slice(arguments, 1));
    }

    nextTask([]);
};

/**
 * An "async function" in the context of Async is an asynchronous function with
 * a variable number of parameters, with the final parameter being a callback.
 * (`function (arg1, arg2, ..., callback) {}`)
 * The final callback is of the form `callback(err, results...)`, which must be
 * called once the function is completed.  The callback should be called with a
 * Error as its first argument to signal that an error occurred.
 * Otherwise, if no error occurred, it should be called with `null` as the first
 * argument, and any additional `result` arguments that may apply, to signal
 * successful completion.
 * The callback must be called exactly once, ideally on a later tick of the
 * JavaScript event loop.
 *
 * This type of function is also referred to as a "Node-style async function",
 * or a "continuation passing-style function" (CPS). Most of the methods of this
 * library are themselves CPS/Node-style async functions, or functions that
 * return CPS/Node-style async functions.
 *
 * Wherever we accept a Node-style async function, we also directly accept an
 * [ES2017 `async` function]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function}.
 * In this case, the `async` function will not be passed a final callback
 * argument, and any thrown error will be used as the `err` argument of the
 * implicit callback, and the return value will be used as the `result` value.
 * (i.e. a `rejected` of the returned Promise becomes the `err` callback
 * argument, and a `resolved` value becomes the `result`.)
 *
 * Note, due to JavaScript limitations, we can only detect native `async`
 * functions and not transpilied implementations.
 * Your environment must have `async`/`await` support for this to work.
 * (e.g. Node > v7.6, or a recent version of a modern browser).
 * If you are using `async` functions through a transpiler (e.g. Babel), you
 * must still wrap the function with [asyncify]{@link module:Utils.asyncify},
 * because the `async function` will be compiled to an ordinary function that
 * returns a promise.
 *
 * @typedef {Function} AsyncFunction
 * @static
 */

/**
 * Async is a utility module which provides straight-forward, powerful functions
 * for working with asynchronous JavaScript. Although originally designed for
 * use with [Node.js](http://nodejs.org) and installable via
 * `npm install --save async`, it can also be used directly in the browser.
 * @module async
 * @see AsyncFunction
 */


/**
 * A collection of `async` functions for manipulating collections, such as
 * arrays and objects.
 * @module Collections
 */

/**
 * A collection of `async` functions for controlling the flow through a script.
 * @module ControlFlow
 */

/**
 * A collection of `async` utility functions.
 * @module Utils
 */

var index = {
    apply: apply,
    applyEach: applyEach,
    applyEachSeries: applyEachSeries,
    asyncify: asyncify,
    auto: auto,
    autoInject: autoInject,
    cargo: cargo,
    compose: compose,
    concat: concat,
    concatLimit: concatLimit,
    concatSeries: concatSeries,
    constant: constant,
    detect: detect,
    detectLimit: detectLimit,
    detectSeries: detectSeries,
    dir: dir,
    doDuring: doDuring,
    doUntil: doUntil,
    doWhilst: doWhilst,
    during: during,
    each: eachLimit,
    eachLimit: eachLimit$1,
    eachOf: eachOf,
    eachOfLimit: eachOfLimit,
    eachOfSeries: eachOfSeries,
    eachSeries: eachSeries,
    ensureAsync: ensureAsync,
    every: every,
    everyLimit: everyLimit,
    everySeries: everySeries,
    filter: filter,
    filterLimit: filterLimit,
    filterSeries: filterSeries,
    forever: forever,
    groupBy: groupBy,
    groupByLimit: groupByLimit,
    groupBySeries: groupBySeries,
    log: log,
    map: map,
    mapLimit: mapLimit,
    mapSeries: mapSeries,
    mapValues: mapValues,
    mapValuesLimit: mapValuesLimit,
    mapValuesSeries: mapValuesSeries,
    memoize: memoize,
    nextTick: nextTick,
    parallel: parallelLimit,
    parallelLimit: parallelLimit$1,
    priorityQueue: priorityQueue,
    queue: queue$1,
    race: race,
    reduce: reduce,
    reduceRight: reduceRight,
    reflect: reflect,
    reflectAll: reflectAll,
    reject: reject,
    rejectLimit: rejectLimit,
    rejectSeries: rejectSeries,
    retry: retry,
    retryable: retryable,
    seq: seq,
    series: series,
    setImmediate: setImmediate$1,
    some: some,
    someLimit: someLimit,
    someSeries: someSeries,
    sortBy: sortBy,
    timeout: timeout,
    times: times,
    timesLimit: timeLimit,
    timesSeries: timesSeries,
    transform: transform,
    tryEach: tryEach,
    unmemoize: unmemoize,
    until: until,
    waterfall: waterfall,
    whilst: whilst,

    // aliases
    all: every,
    allLimit: everyLimit,
    allSeries: everySeries,
    any: some,
    anyLimit: someLimit,
    anySeries: someSeries,
    find: detect,
    findLimit: detectLimit,
    findSeries: detectSeries,
    forEach: eachLimit,
    forEachSeries: eachSeries,
    forEachLimit: eachLimit$1,
    forEachOf: eachOf,
    forEachOfSeries: eachOfSeries,
    forEachOfLimit: eachOfLimit,
    inject: reduce,
    foldl: reduce,
    foldr: reduceRight,
    select: filter,
    selectLimit: filterLimit,
    selectSeries: filterSeries,
    wrapSync: asyncify
};

exports['default'] = index;
exports.apply = apply;
exports.applyEach = applyEach;
exports.applyEachSeries = applyEachSeries;
exports.asyncify = asyncify;
exports.auto = auto;
exports.autoInject = autoInject;
exports.cargo = cargo;
exports.compose = compose;
exports.concat = concat;
exports.concatLimit = concatLimit;
exports.concatSeries = concatSeries;
exports.constant = constant;
exports.detect = detect;
exports.detectLimit = detectLimit;
exports.detectSeries = detectSeries;
exports.dir = dir;
exports.doDuring = doDuring;
exports.doUntil = doUntil;
exports.doWhilst = doWhilst;
exports.during = during;
exports.each = eachLimit;
exports.eachLimit = eachLimit$1;
exports.eachOf = eachOf;
exports.eachOfLimit = eachOfLimit;
exports.eachOfSeries = eachOfSeries;
exports.eachSeries = eachSeries;
exports.ensureAsync = ensureAsync;
exports.every = every;
exports.everyLimit = everyLimit;
exports.everySeries = everySeries;
exports.filter = filter;
exports.filterLimit = filterLimit;
exports.filterSeries = filterSeries;
exports.forever = forever;
exports.groupBy = groupBy;
exports.groupByLimit = groupByLimit;
exports.groupBySeries = groupBySeries;
exports.log = log;
exports.map = map;
exports.mapLimit = mapLimit;
exports.mapSeries = mapSeries;
exports.mapValues = mapValues;
exports.mapValuesLimit = mapValuesLimit;
exports.mapValuesSeries = mapValuesSeries;
exports.memoize = memoize;
exports.nextTick = nextTick;
exports.parallel = parallelLimit;
exports.parallelLimit = parallelLimit$1;
exports.priorityQueue = priorityQueue;
exports.queue = queue$1;
exports.race = race;
exports.reduce = reduce;
exports.reduceRight = reduceRight;
exports.reflect = reflect;
exports.reflectAll = reflectAll;
exports.reject = reject;
exports.rejectLimit = rejectLimit;
exports.rejectSeries = rejectSeries;
exports.retry = retry;
exports.retryable = retryable;
exports.seq = seq;
exports.series = series;
exports.setImmediate = setImmediate$1;
exports.some = some;
exports.someLimit = someLimit;
exports.someSeries = someSeries;
exports.sortBy = sortBy;
exports.timeout = timeout;
exports.times = times;
exports.timesLimit = timeLimit;
exports.timesSeries = timesSeries;
exports.transform = transform;
exports.tryEach = tryEach;
exports.unmemoize = unmemoize;
exports.until = until;
exports.waterfall = waterfall;
exports.whilst = whilst;
exports.all = every;
exports.allLimit = everyLimit;
exports.allSeries = everySeries;
exports.any = some;
exports.anyLimit = someLimit;
exports.anySeries = someSeries;
exports.find = detect;
exports.findLimit = detectLimit;
exports.findSeries = detectSeries;
exports.forEach = eachLimit;
exports.forEachSeries = eachSeries;
exports.forEachLimit = eachLimit$1;
exports.forEachOf = eachOf;
exports.forEachOfSeries = eachOfSeries;
exports.forEachOfLimit = eachOfLimit;
exports.inject = reduce;
exports.foldl = reduce;
exports.foldr = reduceRight;
exports.select = filter;
exports.selectLimit = filterLimit;
exports.selectSeries = filterSeries;
exports.wrapSync = asyncify;

Object.defineProperty(exports, '__esModule', { value: true });

})));

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("timers").setImmediate)
},{"_process":2,"timers":3}],105:[function(require,module,exports){
'use strict'
// base-x encoding / decoding
// Copyright (c) 2018 base-x contributors
// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)
// Distributed under the MIT software license, see the accompanying
// file LICENSE or http://www.opensource.org/licenses/mit-license.php.
function base (ALPHABET) {
  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }
  var BASE_MAP = new Uint8Array(256)
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i)
    var xc = x.charCodeAt(0)
    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }
    BASE_MAP[xc] = i
  }
  var BASE = ALPHABET.length
  var LEADER = ALPHABET.charAt(0)
  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up
  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up
  function encode (source) {
    if (source instanceof Uint8Array) {
    } else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength)
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source)
    }
    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }
    if (source.length === 0) { return '' }
        // Skip & count leading zeroes.
    var zeroes = 0
    var length = 0
    var pbegin = 0
    var pend = source.length
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++
      zeroes++
    }
        // Allocate enough space in big-endian base58 representation.
    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0
    var b58 = new Uint8Array(size)
        // Process the bytes.
    while (pbegin !== pend) {
      var carry = source[pbegin]
            // Apply "b58 = b58 * 256 + ch".
      var i = 0
      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {
        carry += (256 * b58[it1]) >>> 0
        b58[it1] = (carry % BASE) >>> 0
        carry = (carry / BASE) >>> 0
      }
      if (carry !== 0) { throw new Error('Non-zero carry') }
      length = i
      pbegin++
    }
        // Skip leading zeroes in base58 result.
    var it2 = size - length
    while (it2 !== size && b58[it2] === 0) {
      it2++
    }
        // Translate the result into a string.
    var str = LEADER.repeat(zeroes)
    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }
    return str
  }
  function decodeUnsafe (source) {
    if (typeof source !== 'string') { throw new TypeError('Expected String') }
    if (source.length === 0) { return new Uint8Array() }
    var psz = 0
        // Skip and count leading '1's.
    var zeroes = 0
    var length = 0
    while (source[psz] === LEADER) {
      zeroes++
      psz++
    }
        // Allocate enough space in big-endian base256 representation.
    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.
    var b256 = new Uint8Array(size)
        // Process the characters.
    while (source[psz]) {
            // Decode character
      var carry = BASE_MAP[source.charCodeAt(psz)]
            // Invalid character
      if (carry === 255) { return }
      var i = 0
      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {
        carry += (BASE * b256[it3]) >>> 0
        b256[it3] = (carry % 256) >>> 0
        carry = (carry / 256) >>> 0
      }
      if (carry !== 0) { throw new Error('Non-zero carry') }
      length = i
      psz++
    }
        // Skip leading zeroes in b256.
    var it4 = size - length
    while (it4 !== size && b256[it4] === 0) {
      it4++
    }
    var vch = new Uint8Array(zeroes + (size - it4))
    var j = zeroes
    while (it4 !== size) {
      vch[j++] = b256[it4++]
    }
    return vch
  }
  function decode (string) {
    var buffer = decodeUnsafe(string)
    if (buffer) { return buffer }
    throw new Error('Non-base' + BASE + ' character')
  }
  return {
    encode: encode,
    decodeUnsafe: decodeUnsafe,
    decode: decode
  }
}
module.exports = base

},{}],106:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],107:[function(require,module,exports){
const basex = require('base-x')
const ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'

module.exports = basex(ALPHABET)

},{"base-x":105}],108:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.c32ToB58 = exports.b58ToC32 = exports.c32addressDecode = exports.c32address = exports.versions = void 0;
const checksum_1 = require("./checksum");
const base58check = require("./base58check");
const utils_1 = require("@noble/hashes/utils");
exports.versions = {
    mainnet: {
        p2pkh: 22,
        p2sh: 20, // 'M'
    },
    testnet: {
        p2pkh: 26,
        p2sh: 21, // 'N'
    },
};
// address conversion : bitcoin to stacks
const ADDR_BITCOIN_TO_STACKS = {};
ADDR_BITCOIN_TO_STACKS[0] = exports.versions.mainnet.p2pkh;
ADDR_BITCOIN_TO_STACKS[5] = exports.versions.mainnet.p2sh;
ADDR_BITCOIN_TO_STACKS[111] = exports.versions.testnet.p2pkh;
ADDR_BITCOIN_TO_STACKS[196] = exports.versions.testnet.p2sh;
// address conversion : stacks to bitcoin
const ADDR_STACKS_TO_BITCOIN = {};
ADDR_STACKS_TO_BITCOIN[exports.versions.mainnet.p2pkh] = 0;
ADDR_STACKS_TO_BITCOIN[exports.versions.mainnet.p2sh] = 5;
ADDR_STACKS_TO_BITCOIN[exports.versions.testnet.p2pkh] = 111;
ADDR_STACKS_TO_BITCOIN[exports.versions.testnet.p2sh] = 196;
/**
 * Make a c32check address with the given version and hash160
 * The only difference between a c32check string and c32 address
 * is that the letter 'S' is pre-pended.
 * @param {number} version - the address version number
 * @param {string} hash160hex - the hash160 to encode (must be a hash160)
 * @returns {string} the address
 */
function c32address(version, hash160hex) {
    if (!hash160hex.match(/^[0-9a-fA-F]{40}$/)) {
        throw new Error('Invalid argument: not a hash160 hex string');
    }
    const c32string = (0, checksum_1.c32checkEncode)(version, hash160hex);
    return `S${c32string}`;
}
exports.c32address = c32address;
/**
 * Decode a c32 address into its version and hash160
 * @param {string} c32addr - the c32check-encoded address
 * @returns {[number, string]} a tuple with the version and hash160
 */
function c32addressDecode(c32addr) {
    if (c32addr.length <= 5) {
        throw new Error('Invalid c32 address: invalid length');
    }
    if (c32addr[0] != 'S') {
        throw new Error('Invalid c32 address: must start with "S"');
    }
    return (0, checksum_1.c32checkDecode)(c32addr.slice(1));
}
exports.c32addressDecode = c32addressDecode;
/*
 * Convert a base58check address to a c32check address.
 * Try to convert the version number if one is not given.
 * @param {string} b58check - the base58check encoded address
 * @param {number} version - the version number, if not inferred from the address
 * @returns {string} the c32 address with the given version number (or the
 *   semantically-equivalent c32 version number, if not given)
 */
function b58ToC32(b58check, version = -1) {
    const addrInfo = base58check.decode(b58check);
    const hash160String = (0, utils_1.bytesToHex)(addrInfo.data);
    const addrVersion = parseInt((0, utils_1.bytesToHex)(addrInfo.prefix), 16);
    let stacksVersion;
    if (version < 0) {
        stacksVersion = addrVersion;
        if (ADDR_BITCOIN_TO_STACKS[addrVersion] !== undefined) {
            stacksVersion = ADDR_BITCOIN_TO_STACKS[addrVersion];
        }
    }
    else {
        stacksVersion = version;
    }
    return c32address(stacksVersion, hash160String);
}
exports.b58ToC32 = b58ToC32;
/*
 * Convert a c32check address to a base58check address.
 * @param {string} c32string - the c32check address
 * @param {number} version - the version number, if not inferred from the address
 * @returns {string} the base58 address with the given version number (or the
 *    semantically-equivalent bitcoin version number, if not given)
 */
function c32ToB58(c32string, version = -1) {
    const addrInfo = c32addressDecode(c32string);
    const stacksVersion = addrInfo[0];
    const hash160String = addrInfo[1];
    let bitcoinVersion;
    if (version < 0) {
        bitcoinVersion = stacksVersion;
        if (ADDR_STACKS_TO_BITCOIN[stacksVersion] !== undefined) {
            bitcoinVersion = ADDR_STACKS_TO_BITCOIN[stacksVersion];
        }
    }
    else {
        bitcoinVersion = version;
    }
    let prefix = bitcoinVersion.toString(16);
    if (prefix.length === 1) {
        prefix = `0${prefix}`;
    }
    return base58check.encode(hash160String, prefix);
}
exports.c32ToB58 = c32ToB58;

},{"./base58check":109,"./checksum":110,"@noble/hashes/utils":14}],109:[function(require,module,exports){
/*
 * From https://github.com/wzbg/base58check
 * @Author: zyc
 * @Date:   2016-09-11 23:36:05
 */
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.decode = exports.encode = void 0;
const sha256_1 = require("@noble/hashes/sha256");
const utils_1 = require("@noble/hashes/utils");
const basex = require("base-x");
const ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
function encode(data, prefix = '00') {
    const dataBytes = typeof data === 'string' ? (0, utils_1.hexToBytes)(data) : data;
    const prefixBytes = typeof prefix === 'string' ? (0, utils_1.hexToBytes)(prefix) : data;
    if (!(dataBytes instanceof Uint8Array) || !(prefixBytes instanceof Uint8Array)) {
        throw new TypeError('Argument must be of type Uint8Array or string');
    }
    const checksum = (0, sha256_1.sha256)((0, sha256_1.sha256)(new Uint8Array([...prefixBytes, ...dataBytes])));
    return basex(ALPHABET).encode([...prefixBytes, ...dataBytes, ...checksum.slice(0, 4)]);
}
exports.encode = encode;
function decode(string) {
    const bytes = basex(ALPHABET).decode(string);
    const prefixBytes = bytes.slice(0, 1);
    const dataBytes = bytes.slice(1, -4);
    // todo: for better performance replace spread with `concatBytes` method
    const checksum = (0, sha256_1.sha256)((0, sha256_1.sha256)(new Uint8Array([...prefixBytes, ...dataBytes])));
    bytes.slice(-4).forEach((check, index) => {
        if (check !== checksum[index]) {
            throw new Error('Invalid checksum');
        }
    });
    return { prefix: prefixBytes, data: dataBytes };
}
exports.decode = decode;

},{"@noble/hashes/sha256":12,"@noble/hashes/utils":14,"base-x":105}],110:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.c32checkDecode = exports.c32checkEncode = void 0;
const sha256_1 = require("@noble/hashes/sha256");
const utils_1 = require("@noble/hashes/utils");
const encoding_1 = require("./encoding");
/**
 * Get the c32check checksum of a hex-encoded string
 * @param {string} dataHex - the hex string
 * @returns {string} the c32 checksum, as a bin-encoded string
 */
function c32checksum(dataHex) {
    const dataHash = (0, sha256_1.sha256)((0, sha256_1.sha256)((0, utils_1.hexToBytes)(dataHex)));
    const checksum = (0, utils_1.bytesToHex)(dataHash.slice(0, 4));
    return checksum;
}
/**
 * Encode a hex string as a c32check string.  This is a lot like how
 * base58check works in Bitcoin-land, but this algorithm uses the
 * z-base-32 alphabet instead of the base58 alphabet.  The algorithm
 * is as follows:
 * * calculate the c32checksum of version + data
 * * c32encode version + data + c32checksum
 * @param {number} version - the version string (between 0 and 31)
 * @param {string} data - the data to encode
 * @returns {string} the c32check representation
 */
function c32checkEncode(version, data) {
    if (version < 0 || version >= 32) {
        throw new Error('Invalid version (must be between 0 and 31)');
    }
    if (!data.match(/^[0-9a-fA-F]*$/)) {
        throw new Error('Invalid data (not a hex string)');
    }
    data = data.toLowerCase();
    if (data.length % 2 !== 0) {
        data = `0${data}`;
    }
    let versionHex = version.toString(16);
    if (versionHex.length === 1) {
        versionHex = `0${versionHex}`;
    }
    const checksumHex = c32checksum(`${versionHex}${data}`);
    const c32str = (0, encoding_1.c32encode)(`${data}${checksumHex}`);
    return `${encoding_1.c32[version]}${c32str}`;
}
exports.c32checkEncode = c32checkEncode;
/*
 * Decode a c32check string back into its version and data payload.  This is
 * a lot like how base58check works in Bitcoin-land, but this algorithm uses
 * the z-base-32 alphabet instead of the base58 alphabet.  The algorithm
 * is as follows:
 * * extract the version, data, and checksum
 * * verify the checksum matches c32checksum(version + data)
 * * return data
 * @param {string} c32data - the c32check-encoded string
 * @returns {array} [version (number), data (string)].  The returned data
 * will be a hex string.  Throws an exception if the checksum does not match.
 */
function c32checkDecode(c32data) {
    c32data = (0, encoding_1.c32normalize)(c32data);
    const dataHex = (0, encoding_1.c32decode)(c32data.slice(1));
    const versionChar = c32data[0];
    const version = encoding_1.c32.indexOf(versionChar);
    const checksum = dataHex.slice(-8);
    let versionHex = version.toString(16);
    if (versionHex.length === 1) {
        versionHex = `0${versionHex}`;
    }
    if (c32checksum(`${versionHex}${dataHex.substring(0, dataHex.length - 8)}`) !== checksum) {
        throw new Error('Invalid c32check string: checksum mismatch');
    }
    return [version, dataHex.substring(0, dataHex.length - 8)];
}
exports.c32checkDecode = c32checkDecode;

},{"./encoding":111,"@noble/hashes/sha256":12,"@noble/hashes/utils":14}],111:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.c32decode = exports.c32normalize = exports.c32encode = exports.c32 = void 0;
const utils_1 = require("@noble/hashes/utils");
exports.c32 = '0123456789ABCDEFGHJKMNPQRSTVWXYZ';
const hex = '0123456789abcdef';
/**
 * Encode a hex string as a c32 string.  Note that the hex string is assumed
 * to be big-endian (and the resulting c32 string will be as well).
 * @param {string} inputHex - the input to encode
 * @param {number} minLength - the minimum length of the c32 string
 * @returns {string} the c32check-encoded representation of the data, as a string
 */
function c32encode(inputHex, minLength) {
    // must be hex
    if (!inputHex.match(/^[0-9a-fA-F]*$/)) {
        throw new Error('Not a hex-encoded string');
    }
    if (inputHex.length % 2 !== 0) {
        inputHex = `0${inputHex}`;
    }
    inputHex = inputHex.toLowerCase();
    let res = [];
    let carry = 0;
    for (let i = inputHex.length - 1; i >= 0; i--) {
        if (carry < 4) {
            const currentCode = hex.indexOf(inputHex[i]) >> carry;
            let nextCode = 0;
            if (i !== 0) {
                nextCode = hex.indexOf(inputHex[i - 1]);
            }
            // carry = 0, nextBits is 1, carry = 1, nextBits is 2
            const nextBits = 1 + carry;
            const nextLowBits = nextCode % (1 << nextBits) << (5 - nextBits);
            const curC32Digit = exports.c32[currentCode + nextLowBits];
            carry = nextBits;
            res.unshift(curC32Digit);
        }
        else {
            carry = 0;
        }
    }
    let C32leadingZeros = 0;
    for (let i = 0; i < res.length; i++) {
        if (res[i] !== '0') {
            break;
        }
        else {
            C32leadingZeros++;
        }
    }
    res = res.slice(C32leadingZeros);
    const zeroPrefix = new TextDecoder().decode((0, utils_1.hexToBytes)(inputHex)).match(/^\u0000*/);
    const numLeadingZeroBytesInHex = zeroPrefix ? zeroPrefix[0].length : 0;
    for (let i = 0; i < numLeadingZeroBytesInHex; i++) {
        res.unshift(exports.c32[0]);
    }
    if (minLength) {
        const count = minLength - res.length;
        for (let i = 0; i < count; i++) {
            res.unshift(exports.c32[0]);
        }
    }
    return res.join('');
}
exports.c32encode = c32encode;
/*
 * Normalize a c32 string
 * @param {string} c32input - the c32-encoded input string
 * @returns {string} the canonical representation of the c32 input string
 */
function c32normalize(c32input) {
    // must be upper-case
    // replace all O's with 0's
    // replace all I's and L's with 1's
    return c32input.toUpperCase().replace(/O/g, '0').replace(/L|I/g, '1');
}
exports.c32normalize = c32normalize;
/*
 * Decode a c32 string back into a hex string.  Note that the c32 input
 * string is assumed to be big-endian (and the resulting hex string will
 * be as well).
 * @param {string} c32input - the c32-encoded input to decode
 * @param {number} minLength - the minimum length of the output hex string (in bytes)
 * @returns {string} the hex-encoded representation of the data, as a string
 */
function c32decode(c32input, minLength) {
    c32input = c32normalize(c32input);
    // must result in a c32 string
    if (!c32input.match(`^[${exports.c32}]*$`)) {
        throw new Error('Not a c32-encoded string');
    }
    const zeroPrefix = c32input.match(`^${exports.c32[0]}*`);
    const numLeadingZeroBytes = zeroPrefix ? zeroPrefix[0].length : 0;
    let res = [];
    let carry = 0;
    let carryBits = 0;
    for (let i = c32input.length - 1; i >= 0; i--) {
        if (carryBits === 4) {
            res.unshift(hex[carry]);
            carryBits = 0;
            carry = 0;
        }
        const currentCode = exports.c32.indexOf(c32input[i]) << carryBits;
        const currentValue = currentCode + carry;
        const currentHexDigit = hex[currentValue % 16];
        carryBits += 1;
        carry = currentValue >> 4;
        if (carry > 1 << carryBits) {
            throw new Error('Panic error in decoding.');
        }
        res.unshift(currentHexDigit);
    }
    // one last carry
    res.unshift(hex[carry]);
    if (res.length % 2 === 1) {
        res.unshift('0');
    }
    let hexLeadingZeros = 0;
    for (let i = 0; i < res.length; i++) {
        if (res[i] !== '0') {
            break;
        }
        else {
            hexLeadingZeros++;
        }
    }
    res = res.slice(hexLeadingZeros - (hexLeadingZeros % 2));
    let hexStr = res.join('');
    for (let i = 0; i < numLeadingZeroBytes; i++) {
        hexStr = `00${hexStr}`;
    }
    if (minLength) {
        const count = minLength * 2 - hexStr.length;
        for (let i = 0; i < count; i += 2) {
            hexStr = `00${hexStr}`;
        }
    }
    return hexStr;
}
exports.c32decode = c32decode;

},{"@noble/hashes/utils":14}],112:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.b58ToC32 = exports.c32ToB58 = exports.versions = exports.c32normalize = exports.c32addressDecode = exports.c32address = exports.c32checkDecode = exports.c32checkEncode = exports.c32decode = exports.c32encode = void 0;
const encoding_1 = require("./encoding");
Object.defineProperty(exports, "c32encode", { enumerable: true, get: function () { return encoding_1.c32encode; } });
Object.defineProperty(exports, "c32decode", { enumerable: true, get: function () { return encoding_1.c32decode; } });
Object.defineProperty(exports, "c32normalize", { enumerable: true, get: function () { return encoding_1.c32normalize; } });
const checksum_1 = require("./checksum");
Object.defineProperty(exports, "c32checkEncode", { enumerable: true, get: function () { return checksum_1.c32checkEncode; } });
Object.defineProperty(exports, "c32checkDecode", { enumerable: true, get: function () { return checksum_1.c32checkDecode; } });
const address_1 = require("./address");
Object.defineProperty(exports, "c32address", { enumerable: true, get: function () { return address_1.c32address; } });
Object.defineProperty(exports, "c32addressDecode", { enumerable: true, get: function () { return address_1.c32addressDecode; } });
Object.defineProperty(exports, "c32ToB58", { enumerable: true, get: function () { return address_1.c32ToB58; } });
Object.defineProperty(exports, "b58ToC32", { enumerable: true, get: function () { return address_1.b58ToC32; } });
Object.defineProperty(exports, "versions", { enumerable: true, get: function () { return address_1.versions; } });

},{"./address":108,"./checksum":110,"./encoding":111}],113:[function(require,module,exports){
(function(self) {

var irrelevant = (function (exports) {

  var support = {
    searchParams: 'URLSearchParams' in self,
    iterable: 'Symbol' in self && 'iterator' in Symbol,
    blob:
      'FileReader' in self &&
      'Blob' in self &&
      (function() {
        try {
          new Blob();
          return true
        } catch (e) {
          return false
        }
      })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  };

  function isDataView(obj) {
    return obj && DataView.prototype.isPrototypeOf(obj)
  }

  if (support.arrayBuffer) {
    var viewClasses = [
      '[object Int8Array]',
      '[object Uint8Array]',
      '[object Uint8ClampedArray]',
      '[object Int16Array]',
      '[object Uint16Array]',
      '[object Int32Array]',
      '[object Uint32Array]',
      '[object Float32Array]',
      '[object Float64Array]'
    ];

    var isArrayBufferView =
      ArrayBuffer.isView ||
      function(obj) {
        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
      };
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name);
    }
    if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value);
    }
    return value
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift();
        return {done: value === undefined, value: value}
      }
    };

    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator
      };
    }

    return iterator
  }

  function Headers(headers) {
    this.map = {};

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value);
      }, this);
    } else if (Array.isArray(headers)) {
      headers.forEach(function(header) {
        this.append(header[0], header[1]);
      }, this);
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name]);
      }, this);
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name);
    value = normalizeValue(value);
    var oldValue = this.map[name];
    this.map[name] = oldValue ? oldValue + ', ' + value : value;
  };

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)];
  };

  Headers.prototype.get = function(name) {
    name = normalizeName(name);
    return this.has(name) ? this.map[name] : null
  };

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  };

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value);
  };

  Headers.prototype.forEach = function(callback, thisArg) {
    for (var name in this.map) {
      if (this.map.hasOwnProperty(name)) {
        callback.call(thisArg, this.map[name], name, this);
      }
    }
  };

  Headers.prototype.keys = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push(name);
    });
    return iteratorFor(items)
  };

  Headers.prototype.values = function() {
    var items = [];
    this.forEach(function(value) {
      items.push(value);
    });
    return iteratorFor(items)
  };

  Headers.prototype.entries = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push([name, value]);
    });
    return iteratorFor(items)
  };

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true;
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result);
      };
      reader.onerror = function() {
        reject(reader.error);
      };
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsArrayBuffer(blob);
    return promise
  }

  function readBlobAsText(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsText(blob);
    return promise
  }

  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf);
    var chars = new Array(view.length);

    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i]);
    }
    return chars.join('')
  }

  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0)
    } else {
      var view = new Uint8Array(buf.byteLength);
      view.set(new Uint8Array(buf));
      return view.buffer
    }
  }

  function Body() {
    this.bodyUsed = false;

    this._initBody = function(body) {
      this._bodyInit = body;
      if (!body) {
        this._bodyText = '';
      } else if (typeof body === 'string') {
        this._bodyText = body;
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body;
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body;
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString();
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer);
        // IE 10-11 can't handle a DataView body.
        this._bodyInit = new Blob([this._bodyArrayBuffer]);
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body);
      } else {
        this._bodyText = body = Object.prototype.toString.call(body);
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8');
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type);
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
        }
      }
    };

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this);
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      };

      this.arrayBuffer = function() {
        if (this._bodyArrayBuffer) {
          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
        } else {
          return this.blob().then(readBlobAsArrayBuffer)
        }
      };
    }

    this.text = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as text')
      } else {
        return Promise.resolve(this._bodyText)
      }
    };

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      };
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    };

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

  function normalizeMethod(method) {
    var upcased = method.toUpperCase();
    return methods.indexOf(upcased) > -1 ? upcased : method
  }

  function Request(input, options) {
    options = options || {};
    var body = options.body;

    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url;
      this.credentials = input.credentials;
      if (!options.headers) {
        this.headers = new Headers(input.headers);
      }
      this.method = input.method;
      this.mode = input.mode;
      this.signal = input.signal;
      if (!body && input._bodyInit != null) {
        body = input._bodyInit;
        input.bodyUsed = true;
      }
    } else {
      this.url = String(input);
    }

    this.credentials = options.credentials || this.credentials || 'same-origin';
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers);
    }
    this.method = normalizeMethod(options.method || this.method || 'GET');
    this.mode = options.mode || this.mode || null;
    this.signal = options.signal || this.signal;
    this.referrer = null;

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body);
  }

  Request.prototype.clone = function() {
    return new Request(this, {body: this._bodyInit})
  };

  function decode(body) {
    var form = new FormData();
    body
      .trim()
      .split('&')
      .forEach(function(bytes) {
        if (bytes) {
          var split = bytes.split('=');
          var name = split.shift().replace(/\+/g, ' ');
          var value = split.join('=').replace(/\+/g, ' ');
          form.append(decodeURIComponent(name), decodeURIComponent(value));
        }
      });
    return form
  }

  function parseHeaders(rawHeaders) {
    var headers = new Headers();
    // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
    // https://tools.ietf.org/html/rfc7230#section-3.2
    var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
    preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
      var parts = line.split(':');
      var key = parts.shift().trim();
      if (key) {
        var value = parts.join(':').trim();
        headers.append(key, value);
      }
    });
    return headers
  }

  Body.call(Request.prototype);

  function Response(bodyInit, options) {
    if (!options) {
      options = {};
    }

    this.type = 'default';
    this.status = options.status === undefined ? 200 : options.status;
    this.ok = this.status >= 200 && this.status < 300;
    this.statusText = 'statusText' in options ? options.statusText : 'OK';
    this.headers = new Headers(options.headers);
    this.url = options.url || '';
    this._initBody(bodyInit);
  }

  Body.call(Response.prototype);

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  };

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''});
    response.type = 'error';
    return response
  };

  var redirectStatuses = [301, 302, 303, 307, 308];

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  };

  exports.DOMException = self.DOMException;
  try {
    new exports.DOMException();
  } catch (err) {
    exports.DOMException = function(message, name) {
      this.message = message;
      this.name = name;
      var error = Error(message);
      this.stack = error.stack;
    };
    exports.DOMException.prototype = Object.create(Error.prototype);
    exports.DOMException.prototype.constructor = exports.DOMException;
  }

  function fetch(input, init) {
    return new Promise(function(resolve, reject) {
      var request = new Request(input, init);

      if (request.signal && request.signal.aborted) {
        return reject(new exports.DOMException('Aborted', 'AbortError'))
      }

      var xhr = new XMLHttpRequest();

      function abortXhr() {
        xhr.abort();
      }

      xhr.onload = function() {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
        };
        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
        var body = 'response' in xhr ? xhr.response : xhr.responseText;
        resolve(new Response(body, options));
      };

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.ontimeout = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.onabort = function() {
        reject(new exports.DOMException('Aborted', 'AbortError'));
      };

      xhr.open(request.method, request.url, true);

      if (request.credentials === 'include') {
        xhr.withCredentials = true;
      } else if (request.credentials === 'omit') {
        xhr.withCredentials = false;
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob';
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value);
      });

      if (request.signal) {
        request.signal.addEventListener('abort', abortXhr);

        xhr.onreadystatechange = function() {
          // DONE (success or failure)
          if (xhr.readyState === 4) {
            request.signal.removeEventListener('abort', abortXhr);
          }
        };
      }

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
    })
  }

  fetch.polyfill = true;

  if (!self.fetch) {
    self.fetch = fetch;
    self.Headers = Headers;
    self.Request = Request;
    self.Response = Response;
  }

  exports.Headers = Headers;
  exports.Request = Request;
  exports.Response = Response;
  exports.fetch = fetch;

  Object.defineProperty(exports, '__esModule', { value: true });

  return exports;

})({});
})(typeof self !== 'undefined' ? self : this);

},{}],114:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decode = exports.encode = exports.unescape = exports.escape = exports.pad = void 0;
const base64_js_1 = require("base64-js");
function pad(base64) {
    return `${base64}${'='.repeat(4 - (base64.length % 4 || 4))}`;
}
exports.pad = pad;
function escape(base64) {
    return base64.replace(/=/g, '').replace(/\+/g, '-').replace(/\//g, '_');
}
exports.escape = escape;
function unescape(base64Url) {
    return pad(base64Url).replace(/-/g, '+').replace(/_/g, '/');
}
exports.unescape = unescape;
function encode(base64) {
    return escape((0, base64_js_1.fromByteArray)(new TextEncoder().encode(base64)));
}
exports.encode = encode;
function decode(base64Url) {
    return new TextDecoder().decode((0, base64_js_1.toByteArray)(pad(unescape(base64Url))));
}
exports.decode = decode;

},{"base64-js":106}],115:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cryptoClients = exports.SECP256K1Client = void 0;
const secp256k1_1 = require("./secp256k1");
Object.defineProperty(exports, "SECP256K1Client", { enumerable: true, get: function () { return secp256k1_1.SECP256K1Client; } });
const cryptoClients = {
    ES256K: secp256k1_1.SECP256K1Client,
};
exports.cryptoClients = cryptoClients;

},{"./secp256k1":116}],116:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SECP256K1Client = void 0;
const hmac_1 = require("@noble/hashes/hmac");
const sha256_1 = require("@noble/hashes/sha256");
const secp = require("@noble/secp256k1");
const ecdsaSigFormatter_1 = require("../ecdsaSigFormatter");
const errors_1 = require("../errors");
const utils_1 = require("@noble/hashes/utils");
// required to use noble secp https://github.com/paulmillr/noble-secp256k1
secp.utils.hmacSha256Sync = (key, ...msgs) => {
    const h = hmac_1.hmac.create(sha256_1.sha256, key);
    msgs.forEach(msg => h.update(msg));
    return h.digest();
};
class SECP256K1Client {
    static derivePublicKey(privateKey, compressed = true) {
        if (privateKey.length === 66) {
            privateKey = privateKey.slice(0, 64);
        }
        if (privateKey.length < 64) {
            // backward compatibly accept too short private keys
            privateKey = privateKey.padStart(64, '0');
        }
        return (0, utils_1.bytesToHex)(secp.getPublicKey(privateKey, compressed));
    }
    static signHash(signingInputHash, privateKey, format = 'jose') {
        // make sure the required parameters are provided
        if (!signingInputHash || !privateKey) {
            throw new errors_1.MissingParametersError('a signing input hash and private key are all required');
        }
        const derSignature = secp.signSync(signingInputHash, privateKey.slice(0, 64), {
            der: true,
            canonical: false,
        });
        if (format === 'der')
            return (0, utils_1.bytesToHex)(derSignature);
        if (format === 'jose')
            return (0, ecdsaSigFormatter_1.derToJose)(derSignature, 'ES256');
        throw Error('Invalid signature format');
    }
    static loadSignature(joseSignature) {
        // create and return the DER-formatted signature bytes
        return (0, ecdsaSigFormatter_1.joseToDer)(joseSignature, 'ES256');
    }
    static verifyHash(signingInputHash, derSignatureBytes, publicKey) {
        // make sure the required parameters are provided
        if (!signingInputHash || !derSignatureBytes || !publicKey) {
            throw new errors_1.MissingParametersError('a signing input hash, der signature, and public key are all required');
        }
        return secp.verify(derSignatureBytes, signingInputHash, publicKey, { strict: false });
    }
}
exports.SECP256K1Client = SECP256K1Client;
SECP256K1Client.algorithmName = 'ES256K';

},{"../ecdsaSigFormatter":119,"../errors":120,"@noble/hashes/hmac":9,"@noble/hashes/sha256":12,"@noble/hashes/utils":14,"@noble/secp256k1":15}],117:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.hashSha256Async = exports.hashSha256 = void 0;
const sha256_1 = require("@noble/hashes/sha256");
function hashSha256(input) {
    return (0, sha256_1.sha256)(input);
}
exports.hashSha256 = hashSha256;
function hashSha256Async(input) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const isSubtleCryptoAvailable = typeof crypto !== 'undefined' && typeof crypto.subtle !== 'undefined';
            if (isSubtleCryptoAvailable) {
                // Use the W3C Web Crypto API if available (running in a web browser).
                const bytes = typeof input === 'string' ? new TextEncoder().encode(input) : input;
                const hash = yield crypto.subtle.digest('SHA-256', bytes);
                return new Uint8Array(hash);
            }
            else {
                // Otherwise try loading the Node.js `crypto` module (running in Node.js, or an older browser with a polyfill).
                const nodeCrypto = require('crypto');
                if (!nodeCrypto.createHash) {
                    throw new Error('`crypto` module does not contain `createHash`');
                }
                return Promise.resolve(nodeCrypto.createHash('sha256').update(input).digest());
            }
        }
        catch (error) {
            console.log(error);
            console.log('Crypto lib not found. Neither the global `crypto.subtle` Web Crypto API, ' +
                'nor the or the Node.js `require("crypto").createHash` module is available. ' +
                'Falling back to JS implementation.');
            return Promise.resolve(hashSha256(input));
        }
    });
}
exports.hashSha256Async = hashSha256Async;

},{"@noble/hashes/sha256":12,"crypto":1}],118:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeToken = void 0;
const base64url = require("./base64Url");
function decodeToken(token) {
    if (typeof token === 'string') {
        // decompose the token into parts
        const tokenParts = token.split('.');
        const header = JSON.parse(base64url.decode(tokenParts[0]));
        const payload = JSON.parse(base64url.decode(tokenParts[1]));
        const signature = tokenParts[2];
        // return the token object
        return {
            header: header,
            payload: payload,
            signature: signature,
        };
    }
    else if (typeof token === 'object') {
        if (typeof token.payload !== 'string') {
            throw new Error('Expected token payload to be a base64 or json string');
        }
        let payload = token.payload;
        if (token.payload[0] !== '{') {
            payload = base64url.decode(payload);
        }
        const allHeaders = [];
        token.header.map((headerValue) => {
            const header = JSON.parse(base64url.decode(headerValue));
            allHeaders.push(header);
        });
        return {
            header: allHeaders,
            payload: JSON.parse(payload),
            signature: token.signature,
        };
    }
}
exports.decodeToken = decodeToken;

},{"./base64Url":114}],119:[function(require,module,exports){
"use strict";
//  NOTICE
//  Copyright 2015 D2L Corporation
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.joseToDer = exports.derToJose = void 0;
// The following code is adapted from https://github.com/Brightspace/node-ecdsa-sig-formatter
const base64_js_1 = require("base64-js");
const base64Url_1 = require("./base64Url");
function getParamSize(keySize) {
    return ((keySize / 8) | 0) + (keySize % 8 === 0 ? 0 : 1);
}
const paramBytesForAlg = {
    ES256: getParamSize(256),
    ES384: getParamSize(384),
    ES512: getParamSize(521),
};
function getParamBytesForAlg(alg) {
    const paramBytes = paramBytesForAlg[alg];
    if (paramBytes) {
        return paramBytes;
    }
    throw new Error(`Unknown algorithm "${alg}"`);
}
const MAX_OCTET = 0x80;
const CLASS_UNIVERSAL = 0;
const PRIMITIVE_BIT = 0x20;
const TAG_SEQ = 0x10;
const TAG_INT = 0x02;
const ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | (CLASS_UNIVERSAL << 6);
const ENCODED_TAG_INT = TAG_INT | (CLASS_UNIVERSAL << 6);
function signatureAsBytes(signature) {
    if (signature instanceof Uint8Array) {
        return signature;
    }
    else if ('string' === typeof signature) {
        return (0, base64_js_1.toByteArray)((0, base64Url_1.pad)(signature));
    }
    throw new TypeError('ECDSA signature must be a Base64 string or a Uint8Array');
}
function derToJose(signature, alg) {
    const signatureBytes = signatureAsBytes(signature);
    const paramBytes = getParamBytesForAlg(alg);
    // the DER encoded param should at most be the param size, plus a padding
    // zero, since due to being a signed integer
    const maxEncodedParamLength = paramBytes + 1;
    const inputLength = signatureBytes.length;
    let offset = 0;
    if (signatureBytes[offset++] !== ENCODED_TAG_SEQ) {
        throw new Error('Could not find expected "seq"');
    }
    let seqLength = signatureBytes[offset++];
    if (seqLength === (MAX_OCTET | 1)) {
        seqLength = signatureBytes[offset++];
    }
    if (inputLength - offset < seqLength) {
        throw new Error(`"seq" specified length of "${seqLength}", only "${inputLength - offset}" remaining`);
    }
    if (signatureBytes[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "r"');
    }
    const rLength = signatureBytes[offset++];
    if (inputLength - offset - 2 < rLength) {
        throw new Error(`"r" specified length of "${rLength}", only "${inputLength - offset - 2}" available`);
    }
    if (maxEncodedParamLength < rLength) {
        throw new Error(`"r" specified length of "${rLength}", max of "${maxEncodedParamLength}" is acceptable`);
    }
    const rOffset = offset;
    offset += rLength;
    if (signatureBytes[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "s"');
    }
    const sLength = signatureBytes[offset++];
    if (inputLength - offset !== sLength) {
        throw new Error(`"s" specified length of "${sLength}", expected "${inputLength - offset}"`);
    }
    if (maxEncodedParamLength < sLength) {
        throw new Error(`"s" specified length of "${sLength}", max of "${maxEncodedParamLength}" is acceptable`);
    }
    const sOffset = offset;
    offset += sLength;
    if (offset !== inputLength) {
        throw new Error(`Expected to consume entire array, but "${inputLength - offset}" bytes remain`);
    }
    const rPadding = paramBytes - rLength;
    const sPadding = paramBytes - sLength;
    const dst = new Uint8Array(rPadding + rLength + sPadding + sLength);
    for (offset = 0; offset < rPadding; ++offset) {
        dst[offset] = 0;
    }
    dst.set(signatureBytes.subarray(rOffset + Math.max(-rPadding, 0), rOffset + rLength), offset);
    offset = paramBytes;
    for (const o = offset; offset < o + sPadding; ++offset) {
        dst[offset] = 0;
    }
    dst.set(signatureBytes.subarray(sOffset + Math.max(-sPadding, 0), sOffset + sLength), offset);
    return (0, base64Url_1.escape)((0, base64_js_1.fromByteArray)(dst));
}
exports.derToJose = derToJose;
function countPadding(buf, start, stop) {
    let padding = 0;
    while (start + padding < stop && buf[start + padding] === 0) {
        ++padding;
    }
    const needsSign = buf[start + padding] >= MAX_OCTET;
    if (needsSign) {
        --padding;
    }
    return padding;
}
function joseToDer(signature, alg) {
    signature = signatureAsBytes(signature);
    const paramBytes = getParamBytesForAlg(alg);
    const signatureBytes = signature.length;
    if (signatureBytes !== paramBytes * 2) {
        throw new TypeError(`"${alg}" signatures must be "${paramBytes * 2}" bytes, saw "${signatureBytes}"`);
    }
    const rPadding = countPadding(signature, 0, paramBytes);
    const sPadding = countPadding(signature, paramBytes, signature.length);
    const rLength = paramBytes - rPadding;
    const sLength = paramBytes - sPadding;
    const rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;
    const shortLength = rsBytes < MAX_OCTET;
    const dst = new Uint8Array((shortLength ? 2 : 3) + rsBytes);
    let offset = 0;
    dst[offset++] = ENCODED_TAG_SEQ;
    if (shortLength) {
        // Bit 8 has value "0"
        // bits 7-1 give the length.
        dst[offset++] = rsBytes;
    }
    else {
        // Bit 8 of first octet has value "1"
        // bits 7-1 give the number of additional length octets.
        dst[offset++] = MAX_OCTET | 1;
        // length, base 256
        dst[offset++] = rsBytes & 0xff;
    }
    dst[offset++] = ENCODED_TAG_INT;
    dst[offset++] = rLength;
    if (rPadding < 0) {
        dst[offset++] = 0;
        dst.set(signature.subarray(0, paramBytes), offset);
        offset += paramBytes;
    }
    else {
        dst.set(signature.subarray(rPadding, paramBytes), offset);
        offset += paramBytes - rPadding;
    }
    dst[offset++] = ENCODED_TAG_INT;
    dst[offset++] = sLength;
    if (sPadding < 0) {
        dst[offset++] = 0;
        dst.set(signature.subarray(paramBytes), offset);
    }
    else {
        dst.set(signature.subarray(paramBytes + sPadding), offset);
    }
    return dst;
}
exports.joseToDer = joseToDer;

},{"./base64Url":114,"base64-js":106}],120:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InvalidTokenError = exports.MissingParametersError = void 0;
class MissingParametersError extends Error {
    constructor(message) {
        super();
        this.name = 'MissingParametersError';
        this.message = message || '';
    }
}
exports.MissingParametersError = MissingParametersError;
class InvalidTokenError extends Error {
    constructor(message) {
        super();
        this.name = 'InvalidTokenError';
        this.message = message || '';
    }
}
exports.InvalidTokenError = InvalidTokenError;

},{}],121:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./signer"), exports);
__exportStar(require("./verifier"), exports);
__exportStar(require("./decode"), exports);
__exportStar(require("./errors"), exports);
__exportStar(require("./cryptoClients"), exports);

},{"./cryptoClients":115,"./decode":118,"./errors":120,"./signer":122,"./verifier":123}],122:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenSigner = exports.createUnsecuredToken = void 0;
const base64url = require("./base64Url");
const cryptoClients_1 = require("./cryptoClients");
const errors_1 = require("./errors");
const sha256_1 = require("./cryptoClients/sha256");
function createSigningInput(payload, header) {
    const tokenParts = [];
    // add in the header
    const encodedHeader = base64url.encode(JSON.stringify(header));
    tokenParts.push(encodedHeader);
    // add in the payload
    const encodedPayload = base64url.encode(JSON.stringify(payload));
    tokenParts.push(encodedPayload);
    // prepare the message
    const signingInput = tokenParts.join('.');
    // return the signing input
    return signingInput;
}
function createUnsecuredToken(payload) {
    const header = { typ: 'JWT', alg: 'none' };
    return createSigningInput(payload, header) + '.';
}
exports.createUnsecuredToken = createUnsecuredToken;
class TokenSigner {
    constructor(signingAlgorithm, rawPrivateKey) {
        if (!(signingAlgorithm && rawPrivateKey)) {
            throw new errors_1.MissingParametersError('a signing algorithm and private key are required');
        }
        if (typeof signingAlgorithm !== 'string') {
            throw new Error('signing algorithm parameter must be a string');
        }
        signingAlgorithm = signingAlgorithm.toUpperCase();
        if (!cryptoClients_1.cryptoClients.hasOwnProperty(signingAlgorithm)) {
            throw new Error('invalid signing algorithm');
        }
        this.tokenType = 'JWT';
        this.cryptoClient = cryptoClients_1.cryptoClients[signingAlgorithm];
        this.rawPrivateKey = rawPrivateKey;
    }
    header(header = {}) {
        const defaultHeader = { typ: this.tokenType, alg: this.cryptoClient.algorithmName };
        return Object.assign({}, defaultHeader, header);
    }
    sign(payload, expanded = false, customHeader = {}) {
        // generate the token header
        const header = this.header(customHeader);
        // prepare the message to be signed
        const signingInput = createSigningInput(payload, header);
        const signingInputHash = (0, sha256_1.hashSha256)(signingInput);
        return this.createWithSignedHash(payload, expanded, header, signingInput, signingInputHash);
    }
    signAsync(payload, expanded = false, customHeader = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            // generate the token header
            const header = this.header(customHeader);
            // prepare the message to be signed
            const signingInput = createSigningInput(payload, header);
            const signingInputHash = yield (0, sha256_1.hashSha256Async)(signingInput);
            return this.createWithSignedHash(payload, expanded, header, signingInput, signingInputHash);
        });
    }
    createWithSignedHash(payload, expanded, header, signingInput, signingInputHash) {
        // sign the message and add in the signature
        const signature = this.cryptoClient.signHash(signingInputHash, this.rawPrivateKey);
        if (expanded) {
            const signedToken = {
                header: [base64url.encode(JSON.stringify(header))],
                payload: JSON.stringify(payload),
                signature: [signature],
            };
            return signedToken;
        }
        else {
            return [signingInput, signature].join('.');
        }
    }
}
exports.TokenSigner = TokenSigner;

},{"./base64Url":114,"./cryptoClients":115,"./cryptoClients/sha256":117,"./errors":120}],123:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenVerifier = void 0;
const base64url = require("./base64Url");
const cryptoClients_1 = require("./cryptoClients");
const errors_1 = require("./errors");
const sha256_1 = require("./cryptoClients/sha256");
class TokenVerifier {
    constructor(signingAlgorithm, rawPublicKey) {
        if (!(signingAlgorithm && rawPublicKey)) {
            throw new errors_1.MissingParametersError('a signing algorithm and public key are required');
        }
        if (typeof signingAlgorithm !== 'string') {
            throw 'signing algorithm parameter must be a string';
        }
        signingAlgorithm = signingAlgorithm.toUpperCase();
        if (!cryptoClients_1.cryptoClients.hasOwnProperty(signingAlgorithm)) {
            throw 'invalid signing algorithm';
        }
        this.tokenType = 'JWT';
        this.cryptoClient = cryptoClients_1.cryptoClients[signingAlgorithm];
        this.rawPublicKey = rawPublicKey;
    }
    verify(token) {
        if (typeof token === 'string') {
            return this.verifyCompact(token, false);
        }
        else if (typeof token === 'object') {
            return this.verifyExpanded(token, false);
        }
        else {
            return false;
        }
    }
    verifyAsync(token) {
        if (typeof token === 'string') {
            return this.verifyCompact(token, true);
        }
        else if (typeof token === 'object') {
            return this.verifyExpanded(token, true);
        }
        else {
            return Promise.resolve(false);
        }
    }
    verifyCompact(token, async) {
        // decompose the token into parts
        const tokenParts = token.split('.');
        // calculate the signing input hash
        const signingInput = tokenParts[0] + '.' + tokenParts[1];
        const performVerify = (signingInputHash) => {
            // extract the signature as a DER array
            const derSignatureBytes = this.cryptoClient.loadSignature(tokenParts[2]);
            // verify the signed hash
            return this.cryptoClient.verifyHash(signingInputHash, derSignatureBytes, this.rawPublicKey);
        };
        if (async) {
            return (0, sha256_1.hashSha256Async)(signingInput).then(signingInputHash => performVerify(signingInputHash));
        }
        else {
            const signingInputHash = (0, sha256_1.hashSha256)(signingInput);
            return performVerify(signingInputHash);
        }
    }
    verifyExpanded(token, async) {
        const signingInput = [token['header'].join('.'), base64url.encode(token['payload'])].join('.');
        let verified = true;
        const performVerify = (signingInputHash) => {
            token['signature'].map((signature) => {
                const derSignatureBytes = this.cryptoClient.loadSignature(signature);
                const signatureVerified = this.cryptoClient.verifyHash(signingInputHash, derSignatureBytes, this.rawPublicKey);
                if (!signatureVerified) {
                    verified = false;
                }
            });
            return verified;
        };
        if (async) {
            return (0, sha256_1.hashSha256Async)(signingInput).then(signingInputHash => performVerify(signingInputHash));
        }
        else {
            const signingInputHash = (0, sha256_1.hashSha256)(signingInput);
            return performVerify(signingInputHash);
        }
    }
}
exports.TokenVerifier = TokenVerifier;

},{"./base64Url":114,"./cryptoClients":115,"./cryptoClients/sha256":117,"./errors":120}],124:[function(require,module,exports){
(function (global){(function (){
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/**
 * Adds the key-value `pair` to `map`.
 *
 * @private
 * @param {Object} map The map to modify.
 * @param {Array} pair The key-value pair to add.
 * @returns {Object} Returns `map`.
 */
function addMapEntry(map, pair) {
  // Don't return `map.set` because it's not chainable in IE 11.
  map.set(pair[0], pair[1]);
  return map;
}

/**
 * Adds `value` to `set`.
 *
 * @private
 * @param {Object} set The set to modify.
 * @param {*} value The value to add.
 * @returns {Object} Returns `set`.
 */
function addSetEntry(set, value) {
  // Don't return `set.add` because it's not chainable in IE 11.
  set.add(value);
  return set;
}

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array ? array.length : 0;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    Symbol = root.Symbol,
    Uint8Array = root.Uint8Array,
    getPrototype = overArg(Object.getPrototypeOf, Object),
    objectCreate = Object.create,
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    splice = arrayProto.splice;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols,
    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
    nativeKeys = overArg(Object.keys, Object);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView'),
    Map = getNative(root, 'Map'),
    Promise = getNative(root, 'Promise'),
    Set = getNative(root, 'Set'),
    WeakMap = getNative(root, 'WeakMap'),
    nativeCreate = getNative(Object, 'create');

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  this.__data__ = new ListCache(entries);
}

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  return this.__data__['delete'](key);
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var cache = this.__data__;
  if (cache instanceof ListCache) {
    var pairs = cache.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      return this;
    }
    cache = this.__data__ = new MapCache(pairs);
  }
  cache.set(key, value);
  return this;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  // Safari 9 makes `arguments.length` enumerable in strict mode.
  var result = (isArray(value) || isArguments(value))
    ? baseTimes(value.length, String)
    : [];

  var length = result.length,
      skipIndexes = !!length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    object[key] = value;
  }
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @param {boolean} [isFull] Specify a clone including symbols.
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
  var result;
  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      if (isHostObject(value)) {
        return object ? value : {};
      }
      result = initCloneObject(isFunc ? {} : value);
      if (!isDeep) {
        return copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, baseClone, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (!isArr) {
    var props = isFull ? getAllKeys(value) : keys(value);
  }
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));
  });
  return result;
}

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} prototype The object to inherit from.
 * @returns {Object} Returns the new object.
 */
function baseCreate(proto) {
  return isObject(proto) ? objectCreate(proto) : {};
}

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

/**
 * The base implementation of `getTag`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  return objectToString.call(value);
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var result = new buffer.constructor(buffer.length);
  buffer.copy(result);
  return result;
}

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

/**
 * Creates a clone of `map`.
 *
 * @private
 * @param {Object} map The map to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned map.
 */
function cloneMap(map, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
  return arrayReduce(array, addMapEntry, new map.constructor);
}

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

/**
 * Creates a clone of `set`.
 *
 * @private
 * @param {Object} set The set to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned set.
 */
function cloneSet(set, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
  return arrayReduce(array, addSetEntry, new set.constructor);
}

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    assignValue(object, key, newValue === undefined ? source[key] : newValue);
  }
  return object;
}

/**
 * Copies own symbol properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Creates an array of the own enumerable symbol properties of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11,
// for data views in Edge < 14, and promises in Node.js.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = objectToString.call(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : undefined;

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, cloneFunc, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return cloneMap(object, isDeep, cloneFunc);

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return cloneSet(object, isDeep, cloneFunc);

    case symbolTag:
      return cloneSymbol(object);
  }
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return baseClone(value, true, true);
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = cloneDeep;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],125:[function(require,module,exports){
module.exports = require('./lib/schema-inspector');

},{"./lib/schema-inspector":126}],126:[function(require,module,exports){
// Disable no-var because we need to support old IE for now.
/* eslint-disable no-var */
// Disable space-before-function-paren for compatibility with VS Code default JS formatter.
/* eslint-disable space-before-function-paren */

/*
 * This module is intended to be executed both on client side and server side.
 * No error should be thrown. (soft error handling)
 */

(function () {
  var root = {};
  // Dependencies --------------------------------------------------------------
  root.async = (typeof require === 'function') ? require('async') : window.async;
  if (typeof root.async !== 'object') {
    throw new Error('Module async is required (https://github.com/caolan/async)');
  }
  var async = root.async;

  function _extend(origin, add) {
    if (!add || typeof add !== 'object') {
      return origin;
    }
    var keys = Object.keys(add);
    var i = keys.length;
    while (i--) {
      origin[keys[i]] = add[keys[i]];
    }
    return origin;
  }

  function _merge() {
    var ret = {};
    var args = Array.prototype.slice.call(arguments);
    var keys = null;
    var i = null;

    args.forEach(function (arg) {
      if (arg && arg.constructor === Object) {
        keys = Object.keys(arg);
        i = keys.length;
        while (i--) {
          ret[keys[i]] = arg[keys[i]];
        }
      }
    });
    return ret;
  }

  // Customisable class (Base class) -------------------------------------------
  // Use with operation "new" to extend Validation and Sanitization themselves,
  // not their prototype. In other words, constructor shall be call to extend
  // those functions, instead of being in their constructor, like this:
  //   _extend(Validation, new Customisable);

  function Customisable() {
    this.custom = {};

    this.extend = function (custom) {
      return _extend(this.custom, custom);
    };

    this.reset = function () {
      this.custom = {};
    };

    this.remove = function (fields) {
      if (!_typeIs.array(fields)) {
        fields = [fields];
      }
      fields.forEach(function (field) {
        delete this.custom[field];
      }, this);
    };
  }

  // Inspection class (Base class) ---------------------------------------------
  // Use to extend Validation and Sanitization prototypes. Inspection
  // constructor shall be called in derived class constructor.

  function Inspection(schema, custom) {
    var _stack = ['@'];

    this._schema = schema;
    this._custom = {};
    if (custom != null) {
      for (var key in custom) {
        if (Object.prototype.hasOwnProperty.call(custom, key)) {
          this._custom['$' + key] = custom[key];
        }
      }
    }

    this._getDepth = function () {
      return _stack.length;
    };

    this._dumpStack = function () {
      /* eslint-disable no-control-regex */
      return _stack.map(function (i) { return i.replace(/^\[/g, '\u001b\u001c\u001d\u001e'); })
        .join('.').replace(/\.\u001b\u001c\u001d\u001e/g, '[');
      /* eslint-enable no-control-regex */
    };

    this._deeperObject = function (name) {
      _stack.push((/^[a-z$_][a-z0-9$_]*$/i).test(name) ? name : '["' + name + '"]');
      return this;
    };

    this._deeperArray = function (i) {
      _stack.push('[' + i + ']');
      return this;
    };

    this._back = function () {
      _stack.pop();
      return this;
    };
  }
  // Simple types --------------------------------------------------------------
  // If the property is not defined or is not in this list:
  var _typeIs = {
    function: function (element) {
      return typeof element === 'function';
    },
    string: function (element) {
      return typeof element === 'string';
    },
    number: function (element) {
      return typeof element === 'number' && !isNaN(element);
    },
    integer: function (element) {
      return typeof element === 'number' && element % 1 === 0;
    },
    NaN: function (element) {
      return typeof element === 'number' && isNaN(element);
    },
    boolean: function (element) {
      return typeof element === 'boolean';
    },
    null: function (element) {
      return element === null;
    },
    date: function (element) {
      return element != null && element instanceof Date;
    },
    object: function (element) {
      return typeof element === 'object' && element != null && element.constructor !== Array;
    },
    array: function (element) {
      return element != null && element.constructor === Array;
    },
    any: function () {
      return true;
    }
  };

  function _simpleType(type, candidate) {
    if (typeof type === 'function') {
      return candidate instanceof type;
    }
    type = type in _typeIs ? type : 'any';
    return _typeIs[type](candidate);
  }

  function _realType(candidate) {
    for (var i in _typeIs) {
      if (_simpleType(i, candidate)) {
        if (i !== 'any' && (i !== 'object' || candidate.constructor === Object)) { return i; }
        return 'an instance of ' + candidate.constructor.name;
      }
    }
  }

  function getIndexes(a, value) {
    var indexes = [];
    var i = a.indexOf(value);

    while (i !== -1) {
      indexes.push(i);
      i = a.indexOf(value, i + 1);
    }
    return indexes;
  }

  // Available formats ---------------------------------------------------------
  /* eslint-disable no-useless-escape */
  // TODO: Study these regex expressions and add more tests so we can consider removing
  // rule no-useless-escape.
  var _formats = {
    void: /^$/,
    url: /^(https?|ftp):\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)?(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i,
    'date-time': /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d{3})?(Z?|(-|\+)\d{2}:\d{2})$/,
    date: /^\d{4}-\d{2}-\d{2}$/,
    coolDateTime: /^\d{4}(-|\/)\d{2}(-|\/)\d{2}(T| )\d{2}:\d{2}:\d{2}(\.\d{3})?Z?$/,
    time: /^\d{2}\:\d{2}\:\d{2}$/,
    color: /^#([0-9a-f])+$/i,
    // 2021-03-13 - Email regex was replaced with result of running email-safe-regex
    // latest version as of that day in order so fix GHSL-2020-35.
    // const emailRegexSafe = require('email-regex-safe');
    // const regexString = emailRegexSafe({
    //   exact: true,
    //   returnString: true,
    // });
    // <using debugger to inspect state of regexString after previous statement>
    //
    // Note that this regex is pretty flexible, but it's a bit stricter than
    // what we had before. It requires the local part of the email address to
    // be at least two characters. Was able to find some justification for
    // this at https://stackoverflow.com/a/15783334/5051165. Test suite
    // was corrected accordingly.
    /* eslint-disable prefer-regex-literals */
    /* eslint-disable quotes */
    email: new RegExp(`(?:[^\\W_](?:[\\w\\.\\+]+)@(?:localhost|(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:northwesternmutual|travelersinsurance|vermögensberatung|vermögensberater|americanexpress|kerryproperties|sandvikcoromant|afamilycompany|americanfamily|bananarepublic|cancerresearch|cookingchannel|kerrylogistics|weatherchannel|international|lifeinsurance|spreadbetting|travelchannel|wolterskluwer|construction|lplfinancial|scholarships|versicherung|accountants|barclaycard|blackfriday|blockbuster|bridgestone|calvinklein|contractors|creditunion|engineering|enterprises|foodnetwork|investments|kerryhotels|lamborghini|motorcycles|olayangroup|photography|playstation|productions|progressive|redumbrella|williamhill|சிங்கப்பூர்|accountant|apartments|associates|basketball|bnpparibas|boehringer|capitalone|consulting|creditcard|cuisinella|eurovision|extraspace|foundation|healthcare|immobilien|industries|management|mitsubishi|nationwide|nextdirect|onyourside|properties|protection|prudential|realestate|republican|restaurant|schaeffler|swiftcover|tatamotors|technology|university|vlaanderen|volkswagen|accenture|alfaromeo|allfinanz|amsterdam|analytics|aquarelle|barcelona|bloomberg|christmas|community|directory|education|equipment|fairwinds|financial|firestone|fresenius|frontdoor|fujixerox|furniture|goldpoint|hisamitsu|homedepot|homegoods|homesense|institute|insurance|kuokgroup|lancaster|landrover|lifestyle|marketing|marshalls|melbourne|microsoft|panasonic|passagens|pramerica|richardli|scjohnson|shangrila|solutions|statebank|statefarm|stockholm|travelers|vacations|موريتانيا|yodobashi|abudhabi|airforce|allstate|attorney|barclays|barefoot|bargains|baseball|boutique|bradesco|broadway|brussels|budapest|builders|business|capetown|catering|catholic|cipriani|cityeats|cleaning|clinique|clothing|commbank|computer|delivery|deloitte|democrat|diamonds|discount|discover|download|engineer|ericsson|etisalat|exchange|feedback|fidelity|firmdale|football|frontier|goodyear|grainger|graphics|guardian|hdfcbank|helsinki|holdings|hospital|infiniti|ipiranga|istanbul|jpmorgan|lighting|lundbeck|marriott|maserati|mckinsey|memorial|merckmsd|mortgage|observer|partners|pharmacy|pictures|plumbing|property|redstone|reliance|saarland|samsclub|security|services|shopping|showtime|softbank|software|stcgroup|supplies|training|vanguard|ventures|verisign|woodside|السعودية|yokohama|abogado|academy|agakhan|alibaba|android|athleta|auction|audible|auspost|avianca|banamex|bauhaus|bentley|bestbuy|booking|brother|bugatti|capital|caravan|careers|channel|charity|chintai|citadel|clubmed|college|cologne|comcast|company|compare|contact|cooking|corsica|country|coupons|courses|cricket|cruises|dentist|digital|domains|exposed|express|farmers|fashion|ferrari|ferrero|finance|fishing|fitness|flights|florist|flowers|forsale|frogans|fujitsu|gallery|genting|godaddy|grocery|guitars|hamburg|hangout|hitachi|holiday|hosting|hoteles|hotmail|hyundai|ismaili|jewelry|juniper|kitchen|komatsu|lacaixa|lanxess|lasalle|latrobe|leclerc|limited|lincoln|markets|monster|netbank|netflix|network|neustar|okinawa|oldnavy|organic|origins|philips|pioneer|politie|realtor|recipes|rentals|reviews|rexroth|samsung|sandvik|schmidt|schwarz|science|shiksha|singles|staples|storage|support|surgery|systems|temasek|theater|theatre|tickets|tiffany|toshiba|trading|walmart|wanggou|watches|weather|website|wedding|whoswho|windows|winners|xfinity|католик|الجزائر|العليان|اتصالات|پاکستان|البحرين|كاثوليك|இந்தியா|yamaxun|youtube|zuerich|abarth|abbott|abbvie|africa|agency|airbus|airtel|alipay|alsace|alstom|amazon|anquan|aramco|author|bayern|beauty|berlin|bharti|bostik|boston|broker|camera|career|casino|center|chanel|chrome|church|circle|claims|clinic|coffee|comsec|condos|coupon|credit|cruise|dating|datsun|dealer|degree|dental|design|direct|doctor|dunlop|dupont|durban|emerck|energy|estate|events|expert|family|flickr|futbol|gallup|garden|george|giving|global|google|gratis|health|hermes|hiphop|hockey|hotels|hughes|imamat|insure|intuit|jaguar|joburg|juegos|kaufen|kinder|kindle|kosher|lancia|latino|lawyer|lefrak|living|locker|london|luxury|madrid|maison|makeup|market|mattel|mobile|monash|mormon|moscow|museum|mutual|nagoya|natura|nissan|nissay|norton|nowruz|office|olayan|online|oracle|orange|otsuka|pfizer|photos|physio|pictet|quebec|racing|realty|reisen|repair|report|review|rocher|rogers|ryukyu|safety|sakura|sanofi|school|schule|search|secure|select|shouji|soccer|social|stream|studio|supply|suzuki|swatch|sydney|taipei|taobao|target|tattoo|tennis|tienda|tjmaxx|tkmaxx|toyota|travel|unicom|viajes|viking|villas|virgin|vision|voting|voyage|vuelos|walter|webcam|xihuan|москва|онлайн|ファッション|भारतम्|ارامكو|امارات|الاردن|المغرب|ابوظبي|مليسيا|இலங்கை|فلسطين|yachts|yandex|zappos|actor|adult|aetna|amfam|amica|apple|archi|audio|autos|azure|baidu|beats|bible|bingo|black|boats|bosch|build|canon|cards|chase|cheap|cisco|citic|click|cloud|coach|codes|crown|cymru|dabur|dance|deals|delta|drive|dubai|earth|edeka|email|epson|faith|fedex|final|forex|forum|gallo|games|gifts|gives|glade|glass|globo|gmail|green|gripe|group|gucci|guide|homes|honda|horse|house|hyatt|ikano|irish|iveco|jetzt|koeln|kyoto|lamer|lease|legal|lexus|lilly|linde|lipsy|lixil|loans|locus|lotte|lotto|macys|mango|media|miami|money|movie|nexus|nikon|ninja|nokia|nowtv|omega|osaka|paris|parts|party|phone|photo|pizza|place|poker|praxi|press|prime|promo|quest|radio|rehab|reise|ricoh|rocks|rodeo|rugby|salon|sener|seven|sharp|shell|shoes|skype|sling|smart|smile|solar|space|sport|stada|store|study|style|sucks|swiss|tatar|tires|tirol|tmall|today|tokyo|tools|toray|total|tours|trade|trust|tunes|tushu|ubank|vegas|video|vodka|volvo|wales|watch|weber|weibo|works|world|xerox|ישראל|বাংলা|భారత్|भारोत|संगठन|ایران|بازار|بھارت|سودان|همراه|سورية|ഭാരതം|嘉里大酒店|yahoo|aarp|able|adac|aero|akdn|ally|amex|arab|army|arpa|arte|asda|asia|audi|auto|baby|band|bank|bbva|beer|best|bike|bing|blog|blue|bofa|bond|book|buzz|cafe|call|camp|care|cars|casa|case|cash|cbre|cern|chat|citi|city|club|cool|coop|cyou|data|date|dclk|deal|dell|desi|diet|dish|docs|duck|dvag|erni|fage|fail|fans|farm|fast|fiat|fido|film|fire|fish|flir|food|ford|free|fund|game|gbiz|gent|ggee|gift|gmbh|gold|golf|goog|guge|guru|hair|haus|hdfc|help|here|hgtv|host|hsbc|icbc|ieee|imdb|immo|info|itau|java|jeep|jobs|jprs|kddi|kiwi|kpmg|kred|land|lego|lgbt|lidl|life|like|limo|link|live|loan|loft|love|ltda|luxe|maif|meet|meme|menu|mini|mint|mobi|moda|moto|name|navy|news|next|nico|nike|ollo|open|page|pars|pccw|pics|ping|pink|play|plus|pohl|porn|post|prod|prof|qpon|raid|read|reit|rent|rest|rich|rmit|room|rsvp|ruhr|safe|sale|sarl|save|saxo|scot|seat|seek|sexy|shaw|shia|shop|show|silk|sina|site|skin|sncf|sohu|song|sony|spot|star|surf|talk|taxi|team|tech|teva|tiaa|tips|town|toys|tube|vana|visa|viva|vivo|vote|voto|wang|weir|wien|wiki|wine|work|xbox|ಭಾರತ|ଭାରତ|大众汽车|ভাৰত|ভারত|موقع|香格里拉|сайт|アマゾン|дети|ポイント|ලංකා|電訊盈科|クラウド|ભારત|भारत|عمان|بارت|ڀارت|عراق|شبكة|بيتك|组织机构|تونس|グーグル|ਭਾਰਤ|yoga|zara|zero|zone|aaa|abb|abc|aco|ads|aeg|afl|aig|anz|aol|app|art|aws|axa|bar|bbc|bbt|bcg|bcn|bet|bid|bio|biz|bms|bmw|bom|boo|bot|box|buy|bzh|cab|cal|cam|car|cat|cba|cbn|cbs|ceo|cfa|cfd|com|cpa|crs|csc|dad|day|dds|dev|dhl|diy|dnp|dog|dot|dtv|dvr|eat|eco|edu|esq|eus|fan|fit|fly|foo|fox|frl|ftr|fun|fyi|gal|gap|gay|gdn|gea|gle|gmo|gmx|goo|gop|got|gov|hbo|hiv|hkt|hot|how|ibm|ice|icu|ifm|inc|ing|ink|int|ist|itv|jcb|jio|jll|jmp|jnj|jot|joy|kfh|kia|kim|kpn|krd|lat|law|lds|llc|llp|lol|lpl|ltd|man|map|mba|med|men|mil|mit|mlb|mls|mma|moe|moi|mom|mov|msd|mtn|mtr|nab|nba|nec|net|new|nfl|ngo|nhk|now|nra|nrw|ntt|nyc|obi|off|one|ong|onl|ooo|org|ott|ovh|pay|pet|phd|pid|pin|pnc|pro|pru|pub|pwc|qvc|red|ren|ril|rio|rip|run|rwe|sap|sas|sbi|sbs|sca|scb|ses|sew|sex|sfr|ski|sky|soy|spa|srl|stc|tab|tax|tci|tdk|tel|thd|tjx|top|trv|tui|tvs|ubs|uno|uol|ups|vet|vig|vin|vip|wed|win|wme|wow|wtc|wtf|xin|कॉम|セール|คอม|我爱你|қаз|срб|бел|קום|淡马锡|орг|नेट|ストア|мкд|كوم|中文网|ком|укр|亚马逊|诺基亚|飞利浦|мон|عرب|ไทย|рус|ລາວ|みんな|天主教|مصر|قطر|հայ|新加坡|xxx|xyz|you|yun|zip|ac|ad|ae|af|ag|ai|al|am|ao|aq|ar|as|at|au|aw|ax|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cu|cv|cw|cx|cy|cz|de|dj|dk|dm|do|dz|ec|ee|eg|er|es|et|eu|fi|fj|fk|fm|fo|fr|ga|gb|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|iq|ir|is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|me|mg|mh|mk|ml|mm|mn|mo|mp|mq|mr|ms|mt|mu|mv|mw|mx|my|mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nu|nz|om|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|ps|pt|pw|py|qa|re|ro|rs|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|sk|sl|sm|sn|so|sr|ss|st|su|sv|sx|sy|sz|tc|td|tf|tg|th|tj|tk|tl|tm|tn|to|tr|tt|tv|tw|tz|ua|ug|uk|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|佛山|慈善|集团|在线|한국|点看|八卦|公益|公司|网站|移动|联通|бг|时尚|微博|삼성|商标|商店|商城|ею|新闻|家電|中信|中国|中國|娱乐|谷歌|购物|通販|网店|餐厅|网络|香港|食品|台湾|台灣|手机|澳門|닷컴|政府|გე|机构|健康|招聘|рф|大拿|ευ|ελ|世界|書籍|网址|닷넷|コム|游戏|企业|信息|嘉里|广东|政务|ye|yt|za|zm|zw))))`),
    /* eslint-enable prefer-regex-literals */
    /* eslint-enable quotes */
    numeric: /^[0-9]+$/,
    integer: /^\-?[0-9]+$/,
    decimal: /^\-?[0-9]*\.?[0-9]+$/,
    alpha: /^[a-z]+$/i,
    alphaNumeric: /^[a-z0-9]+$/i,
    alphaDash: /^[a-z0-9_-]+$/i,
    javascript: /^[a-z_\$][a-z0-9_\$]*$/i,
    upperString: /^[A-Z ]*$/,
    lowerString: /^[a-z ]*$/,
    v4uuid: /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[0-9a-f]{4}-[0-9a-f]{12}$/i
  };
  /* eslint-enable no-useless-escape */

  // Validation ------------------------------------------------------------------
  var _validationAttribut = {
    optional: function (schema, candidate) {
      var opt = typeof schema.optional === 'boolean' ? schema.optional : (schema.optional === 'true'); // Default is false

      if (opt === true) {
        return;
      }
      if (typeof candidate === 'undefined') {
        this.report('is missing and not optional', null, 'optional');
      }
    },
    type: function (schema, candidate) {
      // return because optional function already handle this case
      if (typeof candidate === 'undefined' || (typeof schema.type !== 'string' && !(schema.type instanceof Array) && typeof schema.type !== 'function')) {
        return;
      }
      var types = _typeIs.array(schema.type) ? schema.type : [schema.type];
      var typeIsValid = types.some(function (type) {
        return _simpleType(type, candidate);
      });
      if (!typeIsValid) {
        types = types.map(function (t) { return typeof t === 'function' ? 'an instance of ' + t.name : t; });
        this.report('must be ' + types.join(' or ') + ', but is ' + _realType(candidate), null, 'type');
      }
    },
    uniqueness: function (schema, candidate) {
      if (typeof schema.uniqueness === 'string') { schema.uniqueness = (schema.uniqueness === 'true'); }
      if (typeof schema.uniqueness !== 'boolean' || schema.uniqueness === false || (!_typeIs.array(candidate) && typeof candidate !== 'string')) {
        return;
      }
      var reported = [];
      for (var i = 0; i < candidate.length; i++) {
        if (reported.indexOf(candidate[i]) >= 0) {
          continue;
        }
        var indexes = getIndexes(candidate, candidate[i]);
        if (indexes.length > 1) {
          reported.push(candidate[i]);
          this.report('has value [' + candidate[i] + '] more than once at indexes [' + indexes.join(', ') + ']', null, 'uniqueness');
        }
      }
    },
    pattern: function (schema, candidate) {
      var self = this;
      var regexs = schema.pattern;
      if (typeof candidate !== 'string') {
        return;
      }
      var matches = false;
      if (!_typeIs.array(regexs)) {
        regexs = [regexs];
      }
      regexs.forEach(function (regex) {
        if (typeof regex === 'string' && regex in _formats) {
          regex = _formats[regex];
        }
        if (regex instanceof RegExp) {
          if (regex.test(candidate)) {
            matches = true;
          }
        }
      });
      if (!matches) {
        self.report('must match [' + regexs.join(' or ') + '], but is equal to "' + candidate + '"', null, 'pattern');
      }
    },
    validDate: function (schema, candidate) {
      if (String(schema.validDate) === 'true' && candidate instanceof Date && isNaN(candidate.getTime())) {
        this.report('must be a valid date', null, 'validDate');
      }
    },
    minLength: function (schema, candidate) {
      if (typeof candidate !== 'string' && !_typeIs.array(candidate)) {
        return;
      }
      var minLength = Number(schema.minLength);
      if (isNaN(minLength)) {
        return;
      }
      if (candidate.length < minLength) {
        this.report('must be longer than ' + minLength + ' elements, but it has ' + candidate.length, null, 'minLength');
      }
    },
    maxLength: function (schema, candidate) {
      if (typeof candidate !== 'string' && !_typeIs.array(candidate)) {
        return;
      }
      var maxLength = Number(schema.maxLength);
      if (isNaN(maxLength)) {
        return;
      }
      if (candidate.length > maxLength) {
        this.report('must be shorter than ' + maxLength + ' elements, but it has ' + candidate.length, null, 'maxLength');
      }
    },
    exactLength: function (schema, candidate) {
      if (typeof candidate !== 'string' && !_typeIs.array(candidate)) {
        return;
      }
      var exactLength = Number(schema.exactLength);
      if (isNaN(exactLength)) {
        return;
      }
      if (candidate.length !== exactLength) {
        this.report('must have exactly ' + exactLength + ' elements, but it have ' + candidate.length, null, 'exactLength');
      }
    },
    lt: function (schema, candidate) {
      var limit = Number(schema.lt);
      if (typeof candidate !== 'number' || isNaN(limit)) {
        return;
      }
      if (candidate >= limit) {
        this.report('must be less than ' + limit + ', but is equal to "' + candidate + '"', null, 'lt');
      }
    },
    lte: function (schema, candidate) {
      var limit = Number(schema.lte);
      if (typeof candidate !== 'number' || isNaN(limit)) {
        return;
      }
      if (candidate > limit) {
        this.report('must be less than or equal to ' + limit + ', but is equal to "' + candidate + '"', null, 'lte');
      }
    },
    gt: function (schema, candidate) {
      var limit = Number(schema.gt);
      if (typeof candidate !== 'number' || isNaN(limit)) {
        return;
      }
      if (candidate <= limit) {
        this.report('must be greater than ' + limit + ', but is equal to "' + candidate + '"', null, 'gt');
      }
    },
    gte: function (schema, candidate) {
      var limit = Number(schema.gte);
      if (typeof candidate !== 'number' || isNaN(limit)) {
        return;
      }
      if (candidate < limit) {
        this.report('must be greater than or equal to ' + limit + ', but is equal to "' + candidate + '"', null, 'gte');
      }
    },
    eq: function (schema, candidate) {
      if (typeof candidate !== 'number' && typeof candidate !== 'string' && typeof candidate !== 'boolean') {
        return;
      }
      var limit = schema.eq;
      if (typeof limit !== 'number' && typeof limit !== 'string' && typeof limit !== 'boolean' && !_typeIs.array(limit)) {
        return;
      }
      if (_typeIs.array(limit)) {
        for (var i = 0; i < limit.length; i++) {
          if (candidate === limit[i]) {
            return;
          }
        }
        this.report('must be equal to [' + limit.map(function (l) {
          return '"' + l + '"';
        }).join(' or ') + '], but is equal to "' + candidate + '"', null, 'eq');
      } else {
        if (candidate !== limit) {
          this.report('must be equal to "' + limit + '", but is equal to "' + candidate + '"', null, 'eq');
        }
      }
    },
    ne: function (schema, candidate) {
      if (typeof candidate !== 'number' && typeof candidate !== 'string') {
        return;
      }
      var limit = schema.ne;
      if (typeof limit !== 'number' && typeof limit !== 'string' && !_typeIs.array(limit)) {
        return;
      }
      if (_typeIs.array(limit)) {
        for (var i = 0; i < limit.length; i++) {
          if (candidate === limit[i]) {
            this.report('must not be equal to "' + limit[i] + '"', null, 'ne');
            return;
          }
        }
      } else {
        if (candidate === limit) {
          this.report('must not be equal to "' + limit + '"', null, 'ne');
        }
      }
    },
    someKeys: function (schema, candidat) {
      var _keys = schema.someKeys;
      if (!_typeIs.object(candidat)) {
        return;
      }
      var valid = _keys.some(function (action) {
        return (action in candidat);
      });
      if (!valid) {
        this.report('must have at least key ' + _keys.map(function (i) {
          return '"' + i + '"';
        }).join(' or '), null, 'someKeys');
      }
    },
    strict: function (schema, candidate) {
      if (typeof schema.strict === 'string') { schema.strict = (schema.strict === 'true'); }
      if (schema.strict !== true || !_typeIs.object(candidate) || !_typeIs.object(schema.properties)) {
        return;
      }
      var self = this;
      if (typeof schema.properties['*'] === 'undefined') {
        var intruder = Object.keys(candidate).filter(function (key) {
          return (typeof schema.properties[key] === 'undefined');
        });
        if (intruder.length > 0) {
          var msg = 'should not contains ' + (intruder.length > 1 ? 'properties' : 'property') +
            ' [' + intruder.map(function (i) { return '"' + i + '"'; }).join(', ') + ']';
          self.report(msg, null, 'strict');
        }
      }
    },
    exec: function (schema, candidate, callback) {
      var self = this;

      if (typeof callback === 'function') {
        return this.asyncExec(schema, candidate, callback);
      }
      (_typeIs.array(schema.exec) ? schema.exec : [schema.exec]).forEach(function (exec) {
        if (typeof exec === 'function') {
          exec.call(self, schema, candidate);
        }
      });
    },
    properties: function (schema, candidate, callback) {
      if (typeof callback === 'function') {
        return this.asyncProperties(schema, candidate, callback);
      }
      if (!(schema.properties instanceof Object) || !(candidate instanceof Object)) {
        return;
      }
      var properties = schema.properties;
      var i;
      if (properties['*'] != null) {
        for (i in candidate) {
          if (i in properties) {
            continue;
          }
          this._deeperObject(i);
          this._validate(properties['*'], candidate[i]);
          this._back();
        }
      }
      for (i in properties) {
        if (i === '*') {
          continue;
        }
        this._deeperObject(i);
        this._validate(properties[i], candidate[i]);
        this._back();
      }
    },
    items: function (schema, candidate, callback) {
      if (typeof callback === 'function') {
        return this.asyncItems(schema, candidate, callback);
      }
      if (!(schema.items instanceof Object) || !(candidate instanceof Object)) {
        return;
      }
      var items = schema.items;
      var i, l;
      // If provided schema is an array
      // then call validate for each case
      // else it is an Object
      // then call validate for each key
      if (_typeIs.array(items) && _typeIs.array(candidate)) {
        for (i = 0, l = items.length; i < l; i++) {
          this._deeperArray(i);
          this._validate(items[i], candidate[i]);
          this._back();
        }
      } else {
        for (var key in candidate) {
          if (Object.prototype.hasOwnProperty.call(candidate, key)) {
            this._deeperArray(key);
            this._validate(items, candidate[key]);
            this._back();
          }
        }
      }
    }
  };

  var _asyncValidationAttribut = {
    asyncExec: function (schema, candidate, callback) {
      var self = this;
      async.eachSeries(_typeIs.array(schema.exec) ? schema.exec : [schema.exec], function (exec, done) {
        if (typeof exec === 'function') {
          if (exec.length > 2) {
            return exec.call(self, schema, candidate, done);
          }
          exec.call(self, schema, candidate);
        }
        async.nextTick(done);
      }, callback);
    },
    asyncProperties: function (schema, candidate, callback) {
      if (!(schema.properties instanceof Object) || !_typeIs.object(candidate)) {
        return callback();
      }
      var self = this;
      var properties = schema.properties;
      async.series([
        function (next) {
          if (properties['*'] == null) {
            return next();
          }
          async.eachSeries(Object.keys(candidate), function (i, done) {
            if (i in properties) {
              return async.nextTick(done);
            }
            self._deeperObject(i);
            self._asyncValidate(properties['*'], candidate[i], function (err) {
              self._back();
              done(err);
            });
          }, next);
        },
        function (next) {
          async.eachSeries(Object.keys(properties), function (i, done) {
            if (i === '*') {
              return async.nextTick(done);
            }
            self._deeperObject(i);
            self._asyncValidate(properties[i], candidate[i], function (err) {
              self._back();
              done(err);
            });
          }, next);
        }
      ], callback);
    },
    asyncItems: function (schema, candidate, callback) {
      if (!(schema.items instanceof Object) || !(candidate instanceof Object)) {
        return callback();
      }
      var self = this;
      var items = schema.items;

      if (_typeIs.array(items) && _typeIs.array(candidate)) {
        async.timesSeries(items.length, function (i, done) {
          self._deeperArray(i);
          self._asyncValidate(items[i], candidate[i], function (err, res) {
            self._back();
            done(err, res);
          });
          self._back();
        }, callback);
      } else {
        async.eachSeries(Object.keys(candidate), function (key, done) {
          self._deeperArray(key);
          self._asyncValidate(items, candidate[key], function (err, res) {
            self._back();
            done(err, res);
          });
        }, callback);
      }
    }
  };

  // Validation Class ----------------------------------------------------------
  // inherits from Inspection class (actually we just call Inspection
  // constructor with the new context, because its prototype is empty
  function Validation(schema, custom) {
    Inspection.prototype.constructor.call(this, schema, _merge(Validation.custom, custom));
    var _error = [];

    this._basicFields = Object.keys(_validationAttribut);
    this._customFields = Object.keys(this._custom);
    this.origin = null;

    this.report = function (message, code, reason) {
      var newErr = {
        code: code || this.userCode || null,
        reason: reason || 'unknown',
        message: this.userError || message || 'is invalid',
        property: this.userAlias ? (this.userAlias + ' (' + this._dumpStack() + ')') : this._dumpStack()
      };
      _error.push(newErr);
      return this;
    };

    this.result = function () {
      return {
        error: _error,
        valid: _error.length === 0,
        format: function () {
          if (this.valid === true) {
            return 'Candidate is valid';
          }
          return this.error.map(function (i) {
            return 'Property ' + i.property + ': ' + i.message;
          }).join('\n');
        }
      };
    };
  }

  _extend(Validation.prototype, _validationAttribut);
  _extend(Validation.prototype, _asyncValidationAttribut);
  _extend(Validation, new Customisable());

  Validation.prototype.validate = function (candidate, callback) {
    this.origin = candidate;
    if (typeof callback === 'function') {
      var self = this;
      return async.nextTick(function () {
        self._asyncValidate(self._schema, candidate, function (err) {
          self.origin = null;
          callback(err, self.result());
        });
      });
    }
    return this._validate(this._schema, candidate).result();
  };

  Validation.prototype._validate = function (schema, candidate, callback) {
    this.userCode = schema.code || null;
    this.userError = schema.error || null;
    this.userAlias = schema.alias || null;
    this._basicFields.forEach(function (i) {
      if ((i in schema || i === 'optional') && typeof this[i] === 'function') {
        this[i](schema, candidate);
      }
    }, this);
    this._customFields.forEach(function (i) {
      if (i in schema && typeof this._custom[i] === 'function') {
        this._custom[i].call(this, schema, candidate);
      }
    }, this);
    return this;
  };

  Validation.prototype._asyncValidate = function (schema, candidate, callback) {
    var self = this;
    this.userCode = schema.code || null;
    this.userError = schema.error || null;
    this.userAlias = schema.alias || null;

    async.series([
      function (next) {
        async.eachSeries(Object.keys(_validationAttribut), function (i, done) {
          async.nextTick(function () {
            if ((i in schema || i === 'optional') && typeof self[i] === 'function') {
              if (self[i].length > 2) {
                return self[i](schema, candidate, done);
              }
              self[i](schema, candidate);
            }
            done();
          });
        }, next);
      },
      function (next) {
        async.eachSeries(Object.keys(self._custom), function (i, done) {
          async.nextTick(function () {
            if (i in schema && typeof self._custom[i] === 'function') {
              if (self._custom[i].length > 2) {
                return self._custom[i].call(self, schema, candidate, done);
              }
              self._custom[i].call(self, schema, candidate);
            }
            done();
          });
        }, next);
      }
    ], callback);
  };

  // Sanitization ----------------------------------------------------------------
  // functions called by _sanitization.type method.
  var _forceType = {
    number: function (post, schema) {
      var n;
      if (typeof post === 'number') {
        return post;
      } else if (post === '') {
        if (typeof schema.def !== 'undefined') {
          return schema.def;
        }
        return null;
      } else if (typeof post === 'string') {
        n = parseFloat(post.replace(/,/g, '.').replace(/ /g, ''));
        if (typeof n === 'number') {
          return n;
        }
      } else if (post instanceof Date) {
        return +post;
      }
      return null;
    },
    integer: function (post, schema) {
      var n;
      if (typeof post === 'number' && post % 1 === 0) {
        return post;
      } else if (post === '') {
        if (typeof schema.def !== 'undefined') {
          return schema.def;
        }
        return null;
      } else if (typeof post === 'string') {
        n = parseInt(post.replace(/ /g, ''), 10);
        if (typeof n === 'number') {
          return n;
        }
      } else if (typeof post === 'number') {
        return parseInt(post, 10);
      } else if (typeof post === 'boolean') {
        if (post) { return 1; }
        return 0;
      } else if (post instanceof Date) {
        return +post;
      }
      return null;
    },
    string: function (post, schema) {
      if (typeof post === 'boolean' || typeof post === 'number' || post instanceof Date) {
        return post.toString();
      } else if (_typeIs.array(post)) {
        // If user authorize array and strings...
        if (schema.items || schema.properties) {
          return post;
        }
        return post.join(String(schema.joinWith || ','));
      } else if (post instanceof Object) {
        // If user authorize objects ans strings...
        if (schema.items || schema.properties) {
          return post;
        }
        return JSON.stringify(post);
      } else if (typeof post === 'string' && post.length) {
        return post;
      }
      return null;
    },
    date: function (post, schema) {
      if (post instanceof Date) {
        return post;
      } else {
        var d = new Date(post);
        if (!isNaN(d.getTime())) { // if valid date
          return d;
        }
      }
      return null;
    },
    boolean: function (post, schema) {
      if (typeof post === 'undefined') return null;
      if (typeof post === 'string' && post.toLowerCase() === 'false') return false;
      return !!post;
    },
    object: function (post, schema) {
      if (typeof post !== 'string' || _typeIs.object(post)) {
        return post;
      }
      try {
        return JSON.parse(post);
      } catch (e) {
        return null;
      }
    },
    array: function (post, schema) {
      if (_typeIs.array(post)) {
        return post;
      }
      if (typeof post === 'undefined') {
        return null;
      }
      if (typeof post === 'string') {
        if (post.substring(0, 1) === '[' && post.slice(-1) === ']') {
          try {
            return JSON.parse(post);
          } catch (e) {
            return null;
          }
        }
        return post.split(String(schema.splitWith || ','));
      }
      if (!_typeIs.array(post)) {
        return [post];
      }
      return null;
    }
  };

  var _applyRules = {
    upper: function (post) {
      return post.toUpperCase();
    },
    lower: function (post) {
      return post.toLowerCase();
    },
    title: function (post) {
      // Fix by seb (replace \w\S* by \S* => exemple : coucou ça va)
      return post.replace(/\S*/g, function (txt) {
        return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
      });
    },
    capitalize: function (post) {
      return post.charAt(0).toUpperCase() + post.substr(1).toLowerCase();
    },
    ucfirst: function (post) {
      return post.charAt(0).toUpperCase() + post.substr(1);
    },
    trim: function (post) {
      return post.trim();
    }
  };

  // Every function return the future value of each property. Therefore you
  // have to return post even if you do not change its value
  var _sanitizationAttribut = {
    strict: function (schema, post) {
      if (typeof schema.strict === 'string') { schema.strict = (schema.strict === 'true'); }
      if (schema.strict !== true) {
        return post;
      }
      if (!_typeIs.object(schema.properties)) {
        return post;
      }
      if (!_typeIs.object(post)) {
        return post;
      }
      Object.keys(post).forEach(function (key) {
        if (!(key in schema.properties)) {
          delete post[key];
        }
      });
      return post;
    },
    optional: function (schema, post) {
      var opt = typeof schema.optional === 'boolean' ? schema.optional : (schema.optional !== 'false'); // Default: true
      if (opt === true) {
        return post;
      }
      if (typeof post !== 'undefined') {
        return post;
      }
      this.report();
      if (schema.def === Date) {
        return new Date();
      }
      return schema.def;
    },
    type: function (schema, post) {
      // if (_typeIs['object'](post) || _typeIs.array(post)) {
      //   return post;
      // }
      if (typeof schema.type !== 'string' || typeof _forceType[schema.type] !== 'function') {
        return post;
      }
      var n;
      var opt = typeof schema.optional === 'boolean' ? schema.optional : true;
      if (typeof _forceType[schema.type] === 'function') {
        n = _forceType[schema.type](post, schema);
        if ((n === null && !opt) || (!n && isNaN(n)) || (n === null && schema.type === 'string')) {
          n = schema.def;
        }
      } else if (!opt) {
        n = schema.def;
      }
      if ((n != null || (typeof schema.def !== 'undefined' && schema.def === n)) && n !== post) {
        this.report();
        return n;
      }
      return post;
    },
    rules: function (schema, post) {
      var rules = schema.rules;
      if (typeof post !== 'string' || (typeof rules !== 'string' && !_typeIs.array(rules))) {
        return post;
      }
      var modified = false;
      (_typeIs.array(rules) ? rules : [rules]).forEach(function (rule) {
        if (typeof _applyRules[rule] === 'function') {
          post = _applyRules[rule](post);
          modified = true;
        }
      });
      if (modified) {
        this.report();
      }
      return post;
    },
    min: function (schema, post) {
      var postTest = Number(post);
      if (isNaN(postTest)) {
        return post;
      }
      var min = Number(schema.min);
      if (isNaN(min)) {
        return post;
      }
      if (postTest < min) {
        this.report();
        return min;
      }
      return post;
    },
    max: function (schema, post) {
      var postTest = Number(post);
      if (isNaN(postTest)) {
        return post;
      }
      var max = Number(schema.max);
      if (isNaN(max)) {
        return post;
      }
      if (postTest > max) {
        this.report();
        return max;
      }
      return post;
    },
    minLength: function (schema, post) {
      var limit = Number(schema.minLength);
      if (typeof post !== 'string' || isNaN(limit) || limit < 0) {
        return post;
      }
      var str = '';
      var gap = limit - post.length;
      if (gap > 0) {
        for (var i = 0; i < gap; i++) {
          str += '-';
        }
        this.report();
        return post + str;
      }
      return post;
    },
    maxLength: function (schema, post) {
      var limit = Number(schema.maxLength);
      if (typeof post !== 'string' || isNaN(limit) || limit < 0) {
        return post;
      }
      if (post.length > limit) {
        this.report();
        return post.slice(0, limit);
      }
      return post;
    },
    properties: function (schema, post, callback) {
      if (typeof callback === 'function') {
        return this.asyncProperties(schema, post, callback);
      }
      if (!post || typeof post !== 'object') {
        return post;
      }
      var properties = schema.properties;
      var tmp;
      var i;
      if (typeof properties['*'] !== 'undefined') {
        for (i in post) {
          if (i in properties) {
            continue;
          }
          this._deeperObject(i);
          tmp = this._sanitize(properties['*'], post[i]);
          if (typeof tmp !== 'undefined' || 'exec' in properties['*']) {
            post[i] = tmp;
          }
          this._back();
        }
      }
      for (i in properties) {
        if (i !== '*') {
          this._deeperObject(i);
          tmp = this._sanitize(properties[i], post[i]);
          if (typeof tmp !== 'undefined' || 'exec' in properties[i]) {
            post[i] = tmp;
          }
          this._back();
        }
      }
      return post;
    },
    items: function (schema, post, callback) {
      if (typeof callback === 'function') {
        return this.asyncItems(schema, post, callback);
      }
      if (!(schema.items instanceof Object) || !(post instanceof Object)) {
        return post;
      }
      var i;
      if (_typeIs.array(schema.items) && _typeIs.array(post)) {
        var minLength = schema.items.length < post.length ? schema.items.length : post.length;
        for (i = 0; i < minLength; i++) {
          this._deeperArray(i);
          post[i] = this._sanitize(schema.items[i], post[i]);
          this._back();
        }
      } else {
        for (i in post) {
          if (Object.prototype.hasOwnProperty.call(post, i)) {
            this._deeperArray(i);
            post[i] = this._sanitize(schema.items, post[i]);
            this._back();
          }
        }
      }
      return post;
    },
    exec: function (schema, post, callback) {
      if (typeof callback === 'function') {
        return this.asyncExec(schema, post, callback);
      }
      var execs = _typeIs.array(schema.exec) ? schema.exec : [schema.exec];

      execs.forEach(function (exec) {
        if (typeof exec === 'function') {
          post = exec.call(this, schema, post);
        }
      }, this);
      return post;
    }
  };

  var _asyncSanitizationAttribut = {
    asyncExec: function (schema, post, callback) {
      var self = this;
      var execs = _typeIs.array(schema.exec) ? schema.exec : [schema.exec];

      async.eachSeries(execs, function (exec, done) {
        if (typeof exec === 'function') {
          if (exec.length > 2) {
            return exec.call(self, schema, post, function (err, res) {
              if (err) {
                return done(err);
              }
              post = res;
              done();
            });
          }
          post = exec.call(self, schema, post);
        }
        done();
      }, function (err) {
        callback(err, post);
      });
    },
    asyncProperties: function (schema, post, callback) {
      if (!post || typeof post !== 'object') {
        return callback(null, post);
      }
      var self = this;
      var properties = schema.properties;

      async.series([
        function (next) {
          if (properties['*'] == null) {
            return next();
          }
          var globing = properties['*'];
          async.eachSeries(Object.keys(post), function (i, next) {
            if (i in properties) {
              return next();
            }
            self._deeperObject(i);
            self._asyncSanitize(globing, post[i], function (err, res) {
              if (err) { /* Error can safely be ignored here */ }
              if (typeof res !== 'undefined') {
                post[i] = res;
              }
              self._back();
              next();
            });
          }, next);
        },
        function (next) {
          async.eachSeries(Object.keys(properties), function (i, next) {
            if (i === '*') {
              return next();
            }
            self._deeperObject(i);
            self._asyncSanitize(properties[i], post[i], function (err, res) {
              if (err) {
                return next(err);
              }
              if (typeof res !== 'undefined') {
                post[i] = res;
              }
              self._back();
              next();
            });
          }, next);
        }
      ], function (err) {
        return callback(err, post);
      });
    },
    asyncItems: function (schema, post, callback) {
      if (!(schema.items instanceof Object) || !(post instanceof Object)) {
        return callback(null, post);
      }
      var self = this;
      var items = schema.items;
      if (_typeIs.array(items) && _typeIs.array(post)) {
        var minLength = items.length < post.length ? items.length : post.length;
        async.timesSeries(minLength, function (i, next) {
          self._deeperArray(i);
          self._asyncSanitize(items[i], post[i], function (err, res) {
            if (err) {
              return next(err);
            }
            post[i] = res;
            self._back();
            next();
          });
        }, function (err) {
          callback(err, post);
        });
      } else {
        async.eachSeries(Object.keys(post), function (key, next) {
          self._deeperArray(key);
          self._asyncSanitize(items, post[key], function (err, res) {
            if (err) {
              return next();
            }
            post[key] = res;
            self._back();
            next();
          });
        }, function (err) {
          callback(err, post);
        });
      }
      return post;
    }
  };

  // Sanitization Class --------------------------------------------------------
  // inherits from Inspection class (actually we just call Inspection
  // constructor with the new context, because its prototype is empty
  function Sanitization(schema, custom) {
    Inspection.prototype.constructor.call(this, schema, _merge(Sanitization.custom, custom));
    var _reporting = [];

    this._basicFields = Object.keys(_sanitizationAttribut);
    this._customFields = Object.keys(this._custom);
    this.origin = null;

    this.report = function (message) {
      var newNot = {
        message: message || 'was sanitized',
        property: this.userAlias ? (this.userAlias + ' (' + this._dumpStack() + ')') : this._dumpStack()
      };
      if (!_reporting.some(function (e) { return e.property === newNot.property; })) {
        _reporting.push(newNot);
      }
    };

    this.result = function (data) {
      // For old IE.
      /* eslint-disable object-shorthand */
      return {
        data: data,
        reporting: _reporting,
        format: function () {
          return this.reporting.map(function (i) {
            return 'Property ' + i.property + ' ' + i.message;
          }).join('\n');
        }
      };
      /* eslint-enable object-shorthand */
    };
  }

  _extend(Sanitization.prototype, _sanitizationAttribut);
  _extend(Sanitization.prototype, _asyncSanitizationAttribut);
  _extend(Sanitization, new Customisable());

  Sanitization.prototype.sanitize = function (post, callback) {
    this.origin = post;
    if (typeof callback === 'function') {
      var self = this;
      return this._asyncSanitize(this._schema, post, function (err, data) {
        self.origin = null;
        callback(err, self.result(data));
      });
    }
    var data = this._sanitize(this._schema, post);
    this.origin = null;
    return this.result(data);
  };

  Sanitization.prototype._sanitize = function (schema, post) {
    this.userAlias = schema.alias || null;
    this._basicFields.forEach(function (i) {
      if ((i in schema || i === 'optional') && typeof this[i] === 'function') {
        post = this[i](schema, post);
      }
    }, this);
    this._customFields.forEach(function (i) {
      if (i in schema && typeof this._custom[i] === 'function') {
        post = this._custom[i].call(this, schema, post);
      }
    }, this);
    return post;
  };

  Sanitization.prototype._asyncSanitize = function (schema, post, callback) {
    var self = this;
    this.userAlias = schema.alias || null;

    async.waterfall([
      function (next) {
        async.reduce(self._basicFields, post, function (value, i, next) {
          async.nextTick(function () {
            if ((i in schema || i === 'optional') && typeof self[i] === 'function') {
              if (self[i].length > 2) {
                return self[i](schema, value, next);
              }
              value = self[i](schema, value);
            }
            next(null, value);
          });
        }, next);
      },
      function (inter, next) {
        async.reduce(self._customFields, inter, function (value, i, next) {
          async.nextTick(function () {
            if (i in schema && typeof self._custom[i] === 'function') {
              if (self._custom[i].length > 2) {
                return self._custom[i].call(self, schema, value, next);
              }
              value = self._custom[i].call(self, schema, value);
            }
            next(null, value);
          });
        }, next);
      }
    ], callback);
  };

  // ---------------------------------------------------------------------------

  var INT_MIN = -2147483648;
  var INT_MAX = 2147483647;

  var _rand = {
    int: function (min, max) {
      return min + (0 | Math.random() * (max - min + 1));
    },
    float: function (min, max) {
      return (Math.random() * (max - min) + min);
    },
    bool: function () {
      return (Math.random() > 0.5);
    },
    char: function (min, max) {
      return String.fromCharCode(this.int(min, max));
    },
    fromList: function (list) {
      return list[this.int(0, list.length - 1)];
    }
  };

  var _formatSample = {
    'date-time': function () {
      return new Date().toISOString();
    },
    date: function () {
      return new Date().toISOString().replace(/T.*$/, '');
    },
    time: function () {
      return new Date().toLocaleTimeString({}, { hour12: false });
    },
    color: function (min, max) {
      var s = '#';
      if (min < 1) {
        min = 1;
      }
      for (var i = 0, l = _rand.int(min, max); i < l; i++) {
        s += _rand.fromList('0123456789abcdefABCDEF');
      }
      return s;
    },
    numeric: function () {
      return '' + _rand.int(0, INT_MAX);
    },
    integer: function () {
      if (_rand.bool() === true) {
        return '-' + this.numeric();
      }
      return this.numeric();
    },
    decimal: function () {
      return this.integer() + '.' + this.numeric();
    },
    alpha: function (min, max) {
      var s = '';
      if (min < 1) {
        min = 1;
      }
      for (var i = 0, l = _rand.int(min, max); i < l; i++) {
        s += _rand.fromList('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ');
      }
      return s;
    },
    alphaNumeric: function (min, max) {
      var s = '';
      if (min < 1) {
        min = 1;
      }
      for (var i = 0, l = _rand.int(min, max); i < l; i++) {
        s += _rand.fromList('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789');
      }
      return s;
    },
    alphaDash: function (min, max) {
      var s = '';
      if (min < 1) {
        min = 1;
      }
      for (var i = 0, l = _rand.int(min, max); i < l; i++) {
        s += _rand.fromList('_-abcdefghijklmnopqrstuvwxyz_-ABCDEFGHIJKLMNOPQRSTUVWXYZ_-0123456789_-');
      }
      return s;
    },
    javascript: function (min, max) {
      var s = _rand.fromList('_$abcdefghijklmnopqrstuvwxyz_$ABCDEFGHIJKLMNOPQRSTUVWXYZ_$');
      for (var i = 0, l = _rand.int(min, max - 1); i < l; i++) {
        s += _rand.fromList('_$abcdefghijklmnopqrstuvwxyz_$ABCDEFGHIJKLMNOPQRSTUVWXYZ_$0123456789_$');
      }
      return s;
    }
  };

  function _getLimits(schema) {
    var min = INT_MIN;
    var max = INT_MAX;

    if (schema.gte != null) {
      min = schema.gte;
    } else if (schema.gt != null) {
      min = schema.gt + 1;
    }
    if (schema.lte != null) {
      max = schema.lte;
    } else if (schema.lt != null) {
      max = schema.lt - 1;
    }
    // For old IE.
    /* eslint-disable object-shorthand */
    return { min: min, max: max };
    /* eslint-enable object-shorthand */
  }

  var _typeGenerator = {
    string: function (schema) {
      if (schema.eq != null) {
        return schema.eq;
      }
      var s = '';
      var minLength = schema.minLength != null ? schema.minLength : 0;
      var maxLength = schema.maxLength != null ? schema.maxLength : 32;
      if (typeof schema.pattern === 'string' && typeof _formatSample[schema.pattern] === 'function') {
        return _formatSample[schema.pattern](minLength, maxLength);
      }

      var l = schema.exactLength != null ? schema.exactLength : _rand.int(minLength, maxLength);
      for (var i = 0; i < l; i++) {
        s += _rand.char(32, 126);
      }
      return s;
    },
    number: function (schema) {
      if (schema.eq != null) {
        return schema.eq;
      }
      var limit = _getLimits(schema);
      var n = _rand.float(limit.min, limit.max);
      if (schema.ne != null) {
        var ne = _typeIs.array(schema.ne) ? schema.ne : [schema.ne];
        while (ne.indexOf(n) !== -1) {
          n = _rand.float(limit.min, limit.max);
        }
      }
      return n;
    },
    integer: function (schema) {
      if (schema.eq != null) {
        return schema.eq;
      }
      var limit = _getLimits(schema);
      var n = _rand.int(limit.min, limit.max);
      if (schema.ne != null) {
        var ne = _typeIs.array(schema.ne) ? schema.ne : [schema.ne];
        while (ne.indexOf(n) !== -1) {
          n = _rand.int(limit.min, limit.max);
        }
      }
      return n;
    },
    boolean: function (schema) {
      if (schema.eq != null) {
        return schema.eq;
      }
      return _rand.bool();
    },
    null: function (schema) {
      return null;
    },
    date: function (schema) {
      if (schema.eq != null) {
        return schema.eq;
      }
      return new Date();
    },
    object: function (schema) {
      var o = {};
      var prop = schema.properties || {};

      for (var key in prop) {
        if (Object.prototype.hasOwnProperty.call(prop, key)) {
          if (prop[key].optional === true && _rand.bool() === true) {
            continue;
          }
          if (key !== '*') {
            o[key] = this.generate(prop[key]);
          } else {
            var rk = '__random_key_';
            var randomKey = rk + 0;
            var n = _rand.int(1, 9);
            for (var i = 1; i <= n; i++) {
              if (!(randomKey in prop)) {
                o[randomKey] = this.generate(prop[key]);
              }
              randomKey = rk + i;
            }
          }
        }
      }
      return o;
    },
    array: function (schema) {
      var self = this;
      var items = schema.items || {};
      var minLength = schema.minLength != null ? schema.minLength : 0;
      var maxLength = schema.maxLength != null ? schema.maxLength : 16;
      var type;
      var candidate;
      var size;
      var i;

      if (_typeIs.array(items)) {
        size = items.length;
        if (schema.exactLength != null) {
          size = schema.exactLength;
        } else if (size < minLength) {
          size = minLength;
        } else if (size > maxLength) {
          size = maxLength;
        }
        candidate = new Array(size);
        type = null;
        for (i = 0; i < size; i++) {
          type = items[i].type || 'any';
          if (_typeIs.array(type)) {
            type = type[_rand.int(0, type.length - 1)];
          }
          candidate[i] = self[type](items[i]);
        }
      } else {
        size = schema.exactLength != null ? schema.exactLength : _rand.int(minLength, maxLength);
        candidate = new Array(size);
        type = items.type || 'any';
        if (_typeIs.array(type)) {
          type = type[_rand.int(0, type.length - 1)];
        }
        for (i = 0; i < size; i++) {
          candidate[i] = self[type](items);
        }
      }
      return candidate;
    },
    any: function (schema) {
      var fields = Object.keys(_typeGenerator);
      var i = fields[_rand.int(0, fields.length - 2)];
      return this[i](schema);
    }
  };

  // CandidateGenerator Class (Singleton) --------------------------------------
  function CandidateGenerator() {
    // Maybe extends Inspection class too ?
  }

  _extend(CandidateGenerator.prototype, _typeGenerator);

  var _instance = null;
  CandidateGenerator.instance = function () {
    if (!(_instance instanceof CandidateGenerator)) {
      _instance = new CandidateGenerator();
    }
    return _instance;
  };

  CandidateGenerator.prototype.generate = function (schema) {
    var type = schema.type || 'any';
    if (_typeIs.array(type)) {
      type = type[_rand.int(0, type.length - 1)];
    }
    return this[type](schema);
  };

  // Exports ---------------------------------------------------------------------
  var SchemaInspector = {};

  // if server-side (node.js) else client-side
  if (typeof module !== 'undefined' && module.exports) {
    module.exports = SchemaInspector;
  } else {
    window.SchemaInspector = SchemaInspector;
  }

  SchemaInspector.newSanitization = function (schema, custom) {
    return new Sanitization(schema, custom);
  };

  SchemaInspector.newValidation = function (schema, custom) {
    return new Validation(schema, custom);
  };

  SchemaInspector.Validation = Validation;
  SchemaInspector.Sanitization = Sanitization;

  SchemaInspector.sanitize = function (schema, post, custom, callback) {
    if (arguments.length === 3 && typeof custom === 'function') {
      callback = custom;
      custom = null;
    }
    return new Sanitization(schema, custom).sanitize(post, callback);
  };

  SchemaInspector.validate = function (schema, candidate, custom, callback) {
    if (arguments.length === 3 && typeof custom === 'function') {
      callback = custom;
      custom = null;
    }
    return new Validation(schema, custom).validate(candidate, callback);
  };

  SchemaInspector.generate = function (schema, n) {
    if (typeof n === 'number') {
      var r = new Array(n);
      for (var i = 0; i < n; i++) {
        r[i] = CandidateGenerator.instance().generate(schema);
      }
      return r;
    }
    return CandidateGenerator.instance().generate(schema);
  };
})();

},{"async":104}],127:[function(require,module,exports){
(function (process){(function (){

'use strict'

if (process.env.NODE_ENV === 'production') {
  module.exports = require('./zone-file.cjs.production.min.js')
} else {
  module.exports = require('./zone-file.cjs.development.js')
}

}).call(this)}).call(this,require('_process'))
},{"./zone-file.cjs.development.js":128,"./zone-file.cjs.production.min.js":129,"_process":2}],128:[function(require,module,exports){
'use strict';

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it;

  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      return function () {
        if (i >= o.length) return {
          done: true
        };
        return {
          done: false,
          value: o[i++]
        };
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  it = o[Symbol.iterator]();
  return it.next.bind(it);
}

function getZoneFileTemplate() {
  return '{$origin}\n\
{$ttl}\n\
\n\
; SOA Record\n\
{name} {ttl}    IN  SOA {mname}{rname}(\n\
{serial} ;serial\n\
{refresh} ;refresh\n\
{retry} ;retry\n\
{expire} ;expire\n\
{minimum} ;minimum ttl\n\
)\n\
\n\
; NS Records\n\
{ns}\n\
\n\
; MX Records\n\
{mx}\n\
\n\
; A Records\n\
{a}\n\
\n\
; AAAA Records\n\
{aaaa}\n\
\n\
; CNAME Records\n\
{cname}\n\
\n\
; PTR Records\n\
{ptr}\n\
\n\
; TXT Records\n\
{txt}\n\
\n\
; SRV Records\n\
{srv}\n\
\n\
; SPF Records\n\
{spf}\n\
\n\
; URI Records\n\
{uri}\n\
';
}

function makeZoneFile(jsonZoneFile, template) {
  if (template === void 0) {
    template = getZoneFileTemplate();
  }

  template = processOrigin(jsonZoneFile['$origin'], template);
  template = processTTL(jsonZoneFile['$ttl'], template);
  template = processSOA(jsonZoneFile['soa'], template);
  template = processNS(jsonZoneFile['ns'], template);
  template = processA(jsonZoneFile['a'], template);
  template = processAAAA(jsonZoneFile['aaaa'], template);
  template = processCNAME(jsonZoneFile['cname'], template);
  template = processMX(jsonZoneFile['mx'], template);
  template = processPTR(jsonZoneFile['ptr'], template);
  template = processTXT(jsonZoneFile['txt'], template);
  template = processSRV(jsonZoneFile['srv'], template);
  template = processSPF(jsonZoneFile['spf'], template);
  template = processURI(jsonZoneFile['uri'], template);
  template = processValues(jsonZoneFile, template);
  return template.replace(/\n{2,}/gim, '\n\n');
}

function processOrigin(data, template) {
  var ret = '';

  if (typeof data !== 'undefined') {
    ret += '$ORIGIN ' + data;
  }

  return template.replace('{$origin}', ret);
}

function processTTL(data, template) {
  var ret = '';

  if (typeof data !== 'undefined') {
    ret += '$TTL ' + data;
  }

  return template.replace('{$ttl}', ret);
}

function processSOA(data, template) {
  var ret = template;

  if (typeof data !== 'undefined') {
    data.name = data.name || '@';
    data.ttl = data.ttl || '';

    for (var key in data) {
      var value = data[key];
      ret = ret.replace('{' + key + '}', value + '\t');
    }
  }

  return ret;
}

function processNS(data, template) {
  var ret = '';

  if (data) {
    for (var _iterator = _createForOfIteratorHelperLoose(data), _step; !(_step = _iterator()).done;) {
      var record = _step.value;
      ret += (record.name || '@') + '\t';
      if (record.ttl) ret += record.ttl + '\t';
      ret += 'IN\tNS\t' + record.host + '\n';
    }
  }

  return template.replace('{ns}', ret);
}

function processA(data, template) {
  var ret = '';

  if (data) {
    for (var _iterator2 = _createForOfIteratorHelperLoose(data), _step2; !(_step2 = _iterator2()).done;) {
      var record = _step2.value;
      ret += (record.name || '@') + '\t';
      if (record.ttl) ret += record.ttl + '\t';
      ret += 'IN\tA\t' + record.ip + '\n';
    }
  }

  return template.replace('{a}', ret);
}

function processAAAA(data, template) {
  var ret = '';

  if (data) {
    for (var _iterator3 = _createForOfIteratorHelperLoose(data), _step3; !(_step3 = _iterator3()).done;) {
      var record = _step3.value;
      ret += (record.name || '@') + '\t';
      if (record.ttl) ret += record.ttl + '\t';
      ret += 'IN\tAAAA\t' + record.ip + '\n';
    }
  }

  return template.replace('{aaaa}', ret);
}

function processCNAME(data, template) {
  var ret = '';

  if (data) {
    for (var _iterator4 = _createForOfIteratorHelperLoose(data), _step4; !(_step4 = _iterator4()).done;) {
      var record = _step4.value;
      ret += (record.name || '@') + '\t';
      if (record.ttl) ret += record.ttl + '\t';
      ret += 'IN\tCNAME\t' + record.alias + '\n';
    }
  }

  return template.replace('{cname}', ret);
}

function processMX(data, template) {
  var ret = '';

  if (data) {
    for (var _iterator5 = _createForOfIteratorHelperLoose(data), _step5; !(_step5 = _iterator5()).done;) {
      var record = _step5.value;
      ret += (record.name || '@') + '\t';
      if (record.ttl) ret += record.ttl + '\t';
      ret += 'IN\tMX\t' + record.preference + '\t' + record.host + '\n';
    }
  }

  return template.replace('{mx}', ret);
}

function processPTR(data, template) {
  var ret = '';

  if (data) {
    for (var _iterator6 = _createForOfIteratorHelperLoose(data), _step6; !(_step6 = _iterator6()).done;) {
      var record = _step6.value;
      ret += (record.name || '@') + '\t';
      if (record.ttl) ret += record.ttl + '\t';
      ret += 'IN\tPTR\t' + record.host + '\n';
    }
  }

  return template.replace('{ptr}', ret);
}

function processTXT(data, template) {
  var ret = '';

  if (data) {
    for (var _iterator7 = _createForOfIteratorHelperLoose(data), _step7; !(_step7 = _iterator7()).done;) {
      var record = _step7.value;
      ret += (record.name || '@') + '\t';
      if (record.ttl) ret += record.ttl + '\t';
      ret += 'IN\tTXT\t';
      var txtData = record.txt;

      if (typeof txtData === 'string') {
        ret += '"' + txtData + '"';
      } else if (txtData instanceof Array) {
        ret += txtData.map(function (datum) {
          return '"' + datum + '"';
        }).join(' ');
      }

      ret += '\n';
    }
  }

  return template.replace('{txt}', ret);
}

function processSRV(data, template) {
  var ret = '';

  if (data) {
    for (var _iterator8 = _createForOfIteratorHelperLoose(data), _step8; !(_step8 = _iterator8()).done;) {
      var record = _step8.value;
      ret += (record.name || '@') + '\t';
      if (record.ttl) ret += record.ttl + '\t';
      ret += 'IN\tSRV\t' + record.priority + '\t';
      ret += record.weight + '\t';
      ret += record.port + '\t';
      ret += record.target + '\n';
    }
  }

  return template.replace('{srv}', ret);
}

function processSPF(data, template) {
  var ret = '';

  if (data) {
    for (var _iterator9 = _createForOfIteratorHelperLoose(data), _step9; !(_step9 = _iterator9()).done;) {
      var record = _step9.value;
      ret += (record.name || '@') + '\t';
      if (record.ttl) ret += record.ttl + '\t';
      ret += 'IN\tSPF\t' + record.data + '\n';
    }
  }

  return template.replace('{spf}', ret);
}

function processURI(data, template) {
  var ret = '';

  if (data) {
    for (var _iterator10 = _createForOfIteratorHelperLoose(data), _step10; !(_step10 = _iterator10()).done;) {
      var record = _step10.value;
      ret += (record.name || '@') + '\t';
      if (record.ttl) ret += record.ttl + '\t';
      ret += 'IN\tURI\t' + record.priority + '\t';
      ret += record.weight + '\t';
      ret += '"' + record.target + '"\n';
    }
  }

  return template.replace('{uri}', ret);
}

function processValues(jsonZoneFile, template) {
  template = template.replace('{zone}', jsonZoneFile['$origin'] || (jsonZoneFile['soa'] ? jsonZoneFile['soa']['name'] : false) || '');
  template = template.replace('{datetime}', new Date().toISOString());
  var time = Math.round(Date.now() / 1000);
  return template.replace('{time}', "" + time);
}

function parseZoneFile(text) {
  text = removeComments(text);
  text = flatten(text);
  return parseRRs(text);
}

function removeComments(text) {
  var re = /(^|[^\\]);.*/g;
  return text.replace(re, function (_m, g1) {
    return g1 ? g1 : ''; // if g1 is set/matched, re-insert it, else remove
  });
}

function flatten(text) {
  var captured = [];
  var re = /\([\s\S]*?\)/gim;
  var match = re.exec(text);

  while (match !== null) {
    var replacement = match[0].replace(/\s+/gm, ' ');
    captured.push({
      match: match,
      replacement: replacement
    }); // captured Text, index, input

    match = re.exec(text);
  }

  var arrText = text.split('');

  for (var _i = 0, _captured = captured; _i < _captured.length; _i++) {
    var cur = _captured[_i];
    var _match = cur.match,
        _replacement = cur.replacement;
    arrText.splice(_match.index, _match[0].length, _replacement);
  }

  return arrText.join('').replace(/\(|\)/gim, ' ');
}

function parseRRs(text) {
  var ret = {};
  var rrs = text.split('\n');

  for (var _iterator = _createForOfIteratorHelperLoose(rrs), _step; !(_step = _iterator()).done;) {
    var rr = _step.value;

    if (!rr || !rr.trim()) {
      continue;
    }

    var uRR = rr.toUpperCase();

    if (/\s+TXT\s+/.test(uRR)) {
      ret.txt = ret.txt || [];
      ret.txt.push(parseTXT(rr));
    } else if (uRR.indexOf('$ORIGIN') === 0) {
      ret.$origin = rr.split(/\s+/g)[1];
    } else if (uRR.indexOf('$TTL') === 0) {
      ret.$ttl = parseInt(rr.split(/\s+/g)[1], 10);
    } else if (/\s+SOA\s+/.test(uRR)) {
      ret.soa = parseSOA(rr);
    } else if (/\s+NS\s+/.test(uRR)) {
      ret.ns = ret.ns || [];
      ret.ns.push(parseNS(rr));
    } else if (/\s+A\s+/.test(uRR)) {
      ret.a = ret.a || [];
      ret.a.push(parseA(rr, ret.a));
    } else if (/\s+AAAA\s+/.test(uRR)) {
      ret.aaaa = ret.aaaa || [];
      ret.aaaa.push(parseAAAA(rr));
    } else if (/\s+CNAME\s+/.test(uRR)) {
      ret.cname = ret.cname || [];
      ret.cname.push(parseCNAME(rr));
    } else if (/\s+MX\s+/.test(uRR)) {
      ret.mx = ret.mx || [];
      ret.mx.push(parseMX(rr));
    } else if (/\s+PTR\s+/.test(uRR)) {
      ret.ptr = ret.ptr || [];
      ret.ptr.push(parsePTR(rr, ret.ptr, ret.$origin));
    } else if (/\s+SRV\s+/.test(uRR)) {
      ret.srv = ret.srv || [];
      ret.srv.push(parseSRV(rr));
    } else if (/\s+SPF\s+/.test(uRR)) {
      ret.spf = ret.spf || [];
      ret.spf.push(parseSPF(rr));
    } else if (/\s+URI\s+/.test(uRR)) {
      ret.uri = ret.uri || [];
      ret.uri.push(parseURI(rr));
    }
  }

  return ret;
}

function parseSOA(rr) {
  var soa = {};
  var rrTokens = rr.trim().split(/\s+/g);
  var l = rrTokens.length;
  soa.name = rrTokens[0];
  soa.minimum = parseInt(rrTokens[l - 1], 10);
  soa.expire = parseInt(rrTokens[l - 2], 10);
  soa.retry = parseInt(rrTokens[l - 3], 10);
  soa.refresh = parseInt(rrTokens[l - 4], 10);
  soa.serial = parseInt(rrTokens[l - 5], 10);
  soa.rname = rrTokens[l - 6];
  soa.mname = rrTokens[l - 7];
  if (!isNaN(rrTokens[1])) soa.ttl = parseInt(rrTokens[1], 10);
  return soa;
}

function parseNS(rr) {
  var rrTokens = rr.trim().split(/\s+/g);
  var l = rrTokens.length;
  var result = {
    name: rrTokens[0],
    host: rrTokens[l - 1]
  };
  if (!isNaN(rrTokens[1])) result.ttl = parseInt(rrTokens[1], 10);
  return result;
}

function parseA(rr, recordsSoFar) {
  var rrTokens = rr.trim().split(/\s+/g);
  var urrTokens = rr.trim().toUpperCase().split(/\s+/g);
  var l = rrTokens.length;
  var result = {
    name: rrTokens[0],
    ip: rrTokens[l - 1]
  };

  if (urrTokens.lastIndexOf('A') === 0) {
    if (recordsSoFar.length) {
      result.name = recordsSoFar[recordsSoFar.length - 1].name;
    } else {
      result.name = '@';
    }
  }

  if (!isNaN(rrTokens[1])) result.ttl = parseInt(rrTokens[1], 10);
  return result;
}

function parseAAAA(rr) {
  var rrTokens = rr.trim().split(/\s+/g);
  var l = rrTokens.length;
  var result = {
    name: rrTokens[0],
    ip: rrTokens[l - 1]
  };
  if (!isNaN(rrTokens[1])) result.ttl = parseInt(rrTokens[1], 10);
  return result;
}

function parseCNAME(rr) {
  var rrTokens = rr.trim().split(/\s+/g);
  var l = rrTokens.length;
  var result = {
    name: rrTokens[0],
    alias: rrTokens[l - 1]
  };
  if (!isNaN(rrTokens[1])) result.ttl = parseInt(rrTokens[1], 10);
  return result;
}

function parseMX(rr) {
  var rrTokens = rr.trim().split(/\s+/g);
  var l = rrTokens.length;
  var result = {
    name: rrTokens[0],
    preference: parseInt(rrTokens[l - 2], 10),
    host: rrTokens[l - 1]
  };
  if (!isNaN(rrTokens[1])) result.ttl = parseInt(rrTokens[1], 10);
  return result;
}

function parseTXT(rr) {
  var rrTokens = rr.trim().match(/[^\s"']+|"[^"]*"|'[^']*'/g);
  if (!rrTokens) throw new Error('Failure to tokenize TXT record');
  var l = rrTokens.length;
  var indexTXT = rrTokens.indexOf('TXT');

  function stripText(txt) {
    if (txt.indexOf('"') > -1) {
      txt = txt.split('"')[1];
    }

    return txt;
  }

  var tokenTxt;

  if (l - indexTXT - 1 > 1) {
    tokenTxt = [].concat(rrTokens.slice(indexTXT + 1).map(stripText));
  } else {
    tokenTxt = stripText(rrTokens[l - 1]);
  }

  var result = {
    name: rrTokens[0],
    txt: tokenTxt
  };
  if (!isNaN(rrTokens[1])) result.ttl = parseInt(rrTokens[1], 10);
  return result;
}

function parsePTR(rr, recordsSoFar, currentOrigin) {
  var rrTokens = rr.trim().split(/\s+/g);
  var urrTokens = rr.trim().toUpperCase().split(/\s+/g);

  if (urrTokens.lastIndexOf('PTR') === 0 && recordsSoFar[recordsSoFar.length - 1]) {
    rrTokens.unshift(recordsSoFar[recordsSoFar.length - 1].name);
  }

  var l = rrTokens.length;
  var result = {
    name: rrTokens[0],
    fullname: rrTokens[0] + '.' + currentOrigin,
    host: rrTokens[l - 1]
  };
  if (!isNaN(rrTokens[1])) result.ttl = parseInt(rrTokens[1], 10);
  return result;
}

function parseSRV(rr) {
  var rrTokens = rr.trim().split(/\s+/g);
  var l = rrTokens.length;
  var result = {
    name: rrTokens[0],
    target: rrTokens[l - 1],
    priority: parseInt(rrTokens[l - 4], 10),
    weight: parseInt(rrTokens[l - 3], 10),
    port: parseInt(rrTokens[l - 2], 10)
  };
  if (!isNaN(rrTokens[1])) result.ttl = parseInt(rrTokens[1], 10);
  return result;
}

function parseSPF(rr) {
  var rrTokens = rr.trim().split(/\s+/g);
  var result = {
    name: rrTokens[0],
    data: ''
  };
  var l = rrTokens.length;

  while (l-- > 4) {
    result.data = rrTokens[l] + ' ' + result.data.trim();
  }

  if (!isNaN(rrTokens[1])) result.ttl = parseInt(rrTokens[1], 10);
  return result;
}

function parseURI(rr) {
  var rrTokens = rr.trim().split(/\s+/g);
  var l = rrTokens.length;
  var result = {
    name: rrTokens[0],
    target: rrTokens[l - 1].replace(/"/g, ''),
    priority: parseInt(rrTokens[l - 3], 10),
    weight: parseInt(rrTokens[l - 2], 10)
  };
  if (!isNaN(rrTokens[1])) result.ttl = parseInt(rrTokens[1], 10);
  return result;
}

var ZoneFile = /*#__PURE__*/function () {
  function ZoneFile(zoneFile) {
    if (typeof zoneFile === 'object') {
      this.jsonZoneFile = JSON.parse(JSON.stringify(zoneFile));
    } else if (typeof zoneFile === 'string') {
      this.jsonZoneFile = parseZoneFile(zoneFile);
    } else {
      this.jsonZoneFile = undefined;
    }
  }

  var _proto = ZoneFile.prototype;

  _proto.toJSON = function toJSON() {
    return this.jsonZoneFile;
  };

  _proto.toString = function toString() {
    return makeZoneFile(this.toJSON());
  };

  return ZoneFile;
}();

exports.ZoneFile = ZoneFile;
exports.makeZoneFile = makeZoneFile;
exports.parseZoneFile = parseZoneFile;


},{}],129:[function(require,module,exports){
"use strict";function t(t,r){(null==r||r>t.length)&&(r=t.length);for(var n=0,e=new Array(r);n<r;n++)e[n]=t[n];return e}function r(r,n){var e;if("undefined"==typeof Symbol||null==r[Symbol.iterator]){if(Array.isArray(r)||(e=function(r,n){if(r){if("string"==typeof r)return t(r,void 0);var e=Object.prototype.toString.call(r).slice(8,-1);return"Object"===e&&r.constructor&&(e=r.constructor.name),"Map"===e||"Set"===e?Array.from(r):"Arguments"===e||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e)?t(r,void 0):void 0}}(r))||n&&r&&"number"==typeof r.length){e&&(r=e);var a=0;return function(){return a>=r.length?{done:!0}:{done:!1,value:r[a++]}}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}return(e=r[Symbol.iterator]()).next.bind(e)}function n(t,n){return void 0===n&&(n="{$origin}\n{$ttl}\n\n; SOA Record\n{name} {ttl}    IN  SOA {mname}{rname}(\n{serial} ;serial\n{refresh} ;refresh\n{retry} ;retry\n{expire} ;expire\n{minimum} ;minimum ttl\n)\n\n; NS Records\n{ns}\n\n; MX Records\n{mx}\n\n; A Records\n{a}\n\n; AAAA Records\n{aaaa}\n\n; CNAME Records\n{cname}\n\n; PTR Records\n{ptr}\n\n; TXT Records\n{txt}\n\n; SRV Records\n{srv}\n\n; SPF Records\n{spf}\n\n; URI Records\n{uri}\n"),n=function(t,r){var n="";return void 0!==t&&(n+="$ORIGIN "+t),r.replace("{$origin}",n)}(t.$origin,n),n=function(t,r){var n="";return void 0!==t&&(n+="$TTL "+t),r.replace("{$ttl}",n)}(t.$ttl,n),n=function(t,r){var n=r;if(void 0!==t)for(var e in t.name=t.name||"@",t.ttl=t.ttl||"",t)n=n.replace("{"+e+"}",t[e]+"\t");return n}(t.soa,n),n=function(t,n){var e="";if(t)for(var a,i=r(t);!(a=i()).done;){var s=a.value;e+=(s.name||"@")+"\t",s.ttl&&(e+=s.ttl+"\t"),e+="IN\tNS\t"+s.host+"\n"}return n.replace("{ns}",e)}(t.ns,n),n=function(t,n){var e="";if(t)for(var a,i=r(t);!(a=i()).done;){var s=a.value;e+=(s.name||"@")+"\t",s.ttl&&(e+=s.ttl+"\t"),e+="IN\tA\t"+s.ip+"\n"}return n.replace("{a}",e)}(t.a,n),n=function(t,n){var e="";if(t)for(var a,i=r(t);!(a=i()).done;){var s=a.value;e+=(s.name||"@")+"\t",s.ttl&&(e+=s.ttl+"\t"),e+="IN\tAAAA\t"+s.ip+"\n"}return n.replace("{aaaa}",e)}(t.aaaa,n),n=function(t,n){var e="";if(t)for(var a,i=r(t);!(a=i()).done;){var s=a.value;e+=(s.name||"@")+"\t",s.ttl&&(e+=s.ttl+"\t"),e+="IN\tCNAME\t"+s.alias+"\n"}return n.replace("{cname}",e)}(t.cname,n),n=function(t,n){var e="";if(t)for(var a,i=r(t);!(a=i()).done;){var s=a.value;e+=(s.name||"@")+"\t",s.ttl&&(e+=s.ttl+"\t"),e+="IN\tMX\t"+s.preference+"\t"+s.host+"\n"}return n.replace("{mx}",e)}(t.mx,n),n=function(t,n){var e="";if(t)for(var a,i=r(t);!(a=i()).done;){var s=a.value;e+=(s.name||"@")+"\t",s.ttl&&(e+=s.ttl+"\t"),e+="IN\tPTR\t"+s.host+"\n"}return n.replace("{ptr}",e)}(t.ptr,n),n=function(t,n){var e="";if(t)for(var a,i=r(t);!(a=i()).done;){var s=a.value;e+=(s.name||"@")+"\t",s.ttl&&(e+=s.ttl+"\t"),e+="IN\tTXT\t";var o=s.txt;"string"==typeof o?e+='"'+o+'"':o instanceof Array&&(e+=o.map((function(t){return'"'+t+'"'})).join(" ")),e+="\n"}return n.replace("{txt}",e)}(t.txt,n),n=function(t,n){var e="";if(t)for(var a,i=r(t);!(a=i()).done;){var s=a.value;e+=(s.name||"@")+"\t",s.ttl&&(e+=s.ttl+"\t"),e+="IN\tSRV\t"+s.priority+"\t",e+=s.weight+"\t",e+=s.port+"\t",e+=s.target+"\n"}return n.replace("{srv}",e)}(t.srv,n),n=function(t,n){var e="";if(t)for(var a,i=r(t);!(a=i()).done;){var s=a.value;e+=(s.name||"@")+"\t",s.ttl&&(e+=s.ttl+"\t"),e+="IN\tSPF\t"+s.data+"\n"}return n.replace("{spf}",e)}(t.spf,n),(n=function(t,r){r=(r=r.replace("{zone}",t.$origin||!!t.soa&&t.soa.name||"")).replace("{datetime}",(new Date).toISOString());var n=Math.round(Date.now()/1e3);return r.replace("{time}",""+n)}(t,n=function(t,n){var e="";if(t)for(var a,i=r(t);!(a=i()).done;){var s=a.value;e+=(s.name||"@")+"\t",s.ttl&&(e+=s.ttl+"\t"),e+="IN\tURI\t"+s.priority+"\t",e+=s.weight+"\t",e+='"'+s.target+'"\n'}return n.replace("{uri}",e)}(t.uri,n))).replace(/\n{2,}/gim,"\n\n")}function e(t){return function(t){for(var n,e={},g=r(t.split("\n"));!(n=g()).done;){var h=n.value;if(h&&h.trim()){var d=h.toUpperCase();/\s+TXT\s+/.test(d)?(e.txt=e.txt||[],e.txt.push(u(h))):0===d.indexOf("$ORIGIN")?e.$origin=h.split(/\s+/g)[1]:0===d.indexOf("$TTL")?e.$ttl=parseInt(h.split(/\s+/g)[1],10):/\s+SOA\s+/.test(d)?e.soa=a(h):/\s+NS\s+/.test(d)?(e.ns=e.ns||[],e.ns.push(i(h))):/\s+A\s+/.test(d)?(e.a=e.a||[],e.a.push(s(h,e.a))):/\s+AAAA\s+/.test(d)?(e.aaaa=e.aaaa||[],e.aaaa.push(o(h))):/\s+CNAME\s+/.test(d)?(e.cname=e.cname||[],e.cname.push(l(h))):/\s+MX\s+/.test(d)?(e.mx=e.mx||[],e.mx.push(p(h))):/\s+PTR\s+/.test(d)?(e.ptr=e.ptr||[],e.ptr.push(c(h,e.ptr,e.$origin))):/\s+SRV\s+/.test(d)?(e.srv=e.srv||[],e.srv.push(f(h))):/\s+SPF\s+/.test(d)?(e.spf=e.spf||[],e.spf.push(m(h))):/\s+URI\s+/.test(d)&&(e.uri=e.uri||[],e.uri.push(v(h)))}}return e}(t=function(t){for(var r=[],n=/\([\s\S]*?\)/gim,e=n.exec(t);null!==e;){var a=e[0].replace(/\s+/gm," ");r.push({match:e,replacement:a}),e=n.exec(t)}for(var i=t.split(""),s=0,o=r;s<o.length;s++){var l=o[s],p=l.match;i.splice(p.index,p[0].length,l.replacement)}return i.join("").replace(/\(|\)/gim," ")}(t=function(t){return t.replace(/(^|[^\\]);.*/g,(function(t,r){return r||""}))}(t)))}function a(t){var r={},n=t.trim().split(/\s+/g),e=n.length;return r.name=n[0],r.minimum=parseInt(n[e-1],10),r.expire=parseInt(n[e-2],10),r.retry=parseInt(n[e-3],10),r.refresh=parseInt(n[e-4],10),r.serial=parseInt(n[e-5],10),r.rname=n[e-6],r.mname=n[e-7],isNaN(n[1])||(r.ttl=parseInt(n[1],10)),r}function i(t){var r=t.trim().split(/\s+/g),n={name:r[0],host:r[r.length-1]};return isNaN(r[1])||(n.ttl=parseInt(r[1],10)),n}function s(t,r){var n=t.trim().split(/\s+/g),e=t.trim().toUpperCase().split(/\s+/g),a={name:n[0],ip:n[n.length-1]};return 0===e.lastIndexOf("A")&&(a.name=r.length?r[r.length-1].name:"@"),isNaN(n[1])||(a.ttl=parseInt(n[1],10)),a}function o(t){var r=t.trim().split(/\s+/g),n={name:r[0],ip:r[r.length-1]};return isNaN(r[1])||(n.ttl=parseInt(r[1],10)),n}function l(t){var r=t.trim().split(/\s+/g),n={name:r[0],alias:r[r.length-1]};return isNaN(r[1])||(n.ttl=parseInt(r[1],10)),n}function p(t){var r=t.trim().split(/\s+/g),n=r.length,e={name:r[0],preference:parseInt(r[n-2],10),host:r[n-1]};return isNaN(r[1])||(e.ttl=parseInt(r[1],10)),e}function u(t){var r=t.trim().match(/[^\s"']+|"[^"]*"|'[^']*'/g);if(!r)throw new Error("Failure to tokenize TXT record");var n,e=r.length,a=r.indexOf("TXT");function i(t){return t.indexOf('"')>-1&&(t=t.split('"')[1]),t}n=e-a-1>1?[].concat(r.slice(a+1).map(i)):i(r[e-1]);var s={name:r[0],txt:n};return isNaN(r[1])||(s.ttl=parseInt(r[1],10)),s}function c(t,r,n){var e=t.trim().split(/\s+/g);0===t.trim().toUpperCase().split(/\s+/g).lastIndexOf("PTR")&&r[r.length-1]&&e.unshift(r[r.length-1].name);var a={name:e[0],fullname:e[0]+"."+n,host:e[e.length-1]};return isNaN(e[1])||(a.ttl=parseInt(e[1],10)),a}function f(t){var r=t.trim().split(/\s+/g),n=r.length,e={name:r[0],target:r[n-1],priority:parseInt(r[n-4],10),weight:parseInt(r[n-3],10),port:parseInt(r[n-2],10)};return isNaN(r[1])||(e.ttl=parseInt(r[1],10)),e}function m(t){for(var r=t.trim().split(/\s+/g),n={name:r[0],data:""},e=r.length;e-- >4;)n.data=r[e]+" "+n.data.trim();return isNaN(r[1])||(n.ttl=parseInt(r[1],10)),n}function v(t){var r=t.trim().split(/\s+/g),n=r.length,e={name:r[0],target:r[n-1].replace(/"/g,""),priority:parseInt(r[n-3],10),weight:parseInt(r[n-2],10)};return isNaN(r[1])||(e.ttl=parseInt(r[1],10)),e}exports.ZoneFile=function(){function t(t){this.jsonZoneFile="object"==typeof t?JSON.parse(JSON.stringify(t)):"string"==typeof t?e(t):void 0}var r=t.prototype;return r.toJSON=function(){return this.jsonZoneFile},r.toString=function(){return n(this.toJSON())},t}(),exports.makeZoneFile=n,exports.parseZoneFile=e;


},{}]},{},[4])(4)
});
